{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./node_modules/@codemirror/next/commands/dist/index.es.js","webpack:///./node_modules/@codemirror/next/gutter/dist/index.es.js","webpack:///./node_modules/@codemirror/next/highlight/dist/index.es.js","webpack:///./node_modules/@codemirror/next/lang-javascript/dist/index.es.js","webpack:///./node_modules/@codemirror/next/rangeset/dist/index.es.js","webpack:///./node_modules/@codemirror/next/state/dist/index.es.js","webpack:///./node_modules/@codemirror/next/syntax/dist/index.es.js","webpack:///./node_modules/@codemirror/next/text/dist/index.es.js","webpack:///./node_modules/@codemirror/next/view/dist/index.es.js","webpack:///./node_modules/lezer-javascript/dist/index.js","webpack:///./node_modules/lezer-tree/dist/tree.js","webpack:///./node_modules/lezer/dist/index.js","webpack:///./node_modules/process/browser.js","webpack:///./node_modules/style-mod/src/style-mod.js","webpack:///(webpack)/buildin/global.js","webpack:///./src/index.ts"],"names":[],"mappings":";QAAA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;;;;;;;AClFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAwF;;AAExF;AACA;AACA;AACA,uBAAuB,qDAAc;AACrC,mBAAmB,qDAAc;AACjC,KAAK;AACL;AACA;AACA;AACA,6BAA6B,kDAAW;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,qDAAc;AACjC,KAAK;AACL;AACA;AACA;AACA,6BAA6B,kDAAW;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,kBAAkB;AAC3C,oCAAoC,sDAAe;AACnD;AACA;AACA;AACA,uBAAuB,kBAAkB;AACzC,oCAAoC,sDAAe;AACnD;AACA;AACA;AACA,oBAAoB,kBAAkB;AACtC,oCAAoC,sDAAe;AACnD;AACA;AACA;AACA;AACA,aAAa,WAAW;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,qDAAc;AACjC,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA,8BAA8B,kDAAW;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,kBAAkB;AACnD;AACA;AACA;AACA,KAAK;AACL,sCAAsC,WAAW;AACjD;AACA;AACA;AACA;AACA,mBAAmB,qDAAc;AACjC,KAAK;AACL;AACA;AACA;AACA;AACA,0BAA0B,kBAAkB;AAC5C;AACA;AACA;AACA;AACA;AACA,kBAAkB,aAAa,iCAAiC;AAChE;AACA;AACA;AACA;AACA;AACA,oCAAoC,8BAA8B;AAClE;AACA;AACA;AACA,cAAc,aAAa;AAC3B;AACA;AACA;AACA;AACA,kBAAkB,uBAAuB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE4Z;;;;;;;;;;;;;AC1N5Z;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAwF;AAC3B;AACuB;;AAEpF;AACA;AACA;AACA,2BAA2B,oDAAU;AACrC;AACA;AACA;AACA;AACA;AACA,kBAAkB,aAAa;AAC/B;AACA,aAAa,YAAY,+CAAK,iBAAiB;AAC/C;AACA;AACA,0EAA0E,8CAAO;AACjF;AACA;AACA;AACA;AACA,0BAA0B,kDAAQ;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,4CAAK;AAC3B;AACA;AACA,wCAAwC,yDAAU;AAClD;AACA,kBAAkB,gDAAU;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,qBAAqB,4CAAK;AAC1B;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,gDAAU;AAC7B;AACA;AACA;AACA,6BAA6B,wDAAU;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,+CAAS;AAC9D;AACA,oCAAoC,+CAAS;AAC7C;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,UAAU,iDAAW;AACtB;AACA;AACA,gDAAgD,8BAA8B,IAAI;AAClF,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,wDAAU;AACvC,4BAA4B,wDAAU;AACtC;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,iEAAiE;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,yBAAyB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,cAAc;AACjC;AACA;AACA;AACA;AACA;AACA,0BAA0B,iDAAU;AACpC,yBAAyB,4CAAK;AAC9B;AACA,eAAe,4DAAa,UAAU,2CAA2C,EAAE;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,eAAe,oCAAoC;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEyE;;;;;;;;;;;;;ACvVzE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAgD;AACR;AACwB;AACtB;AACO;;AAEjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mDAAQ;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,cAAc;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,KAAK;AAClE;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,KAAK;AACvE;AACA,iFAAiF,KAAK;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,mDAAQ;AAC5B;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,gDAAU;AACtB,YAAY,gDAAU;AACtB;AACA;AACA;AACA;AACA;AACA,uBAAuB,wBAAwB;AAC/C;AACA;AACA,uDAAuD,MAAM;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,qDAAW;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,kDAAW;AACnD;AACA,+BAA+B,gDAAU;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,yDAAe;AACzC;AACA;AACA;AACA,wCAAwC,gDAAU,OAAO,eAAe,GAAG;AAC3E;AACA;AACA,kBAAkB,WAAW;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,gBAAgB;AAC9B,cAAc,gBAAgB;AAC9B,WAAW,gBAAgB;AAC3B,aAAa,gBAAgB;AAC7B,aAAa,gBAAgB;AAC7B,gBAAgB,gBAAgB;AAChC,aAAa,gBAAgB;AAC7B,aAAa,gBAAgB;AAC7B,gCAAgC,gBAAgB;AAChD,eAAe,gBAAgB;AAC/B,gCAAgC,gBAAgB;AAChD,cAAc,gBAAgB;AAC9B,WAAW;AACX,CAAC;;AAE6E;;;;;;;;;;;;;AC1U9E;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA0C;AAC4D;AAC9C;AACZ;;AAE5C,wBAAwB,+DAAe,EAAE,YAAY,GAAG;AACxD;AACA;AACA;AACA,6BAA6B,mDAAW,CAAC,uDAAM,WAAW,sDAAc;AACxE;AACA,eAAe,+DAAe,EAAE,aAAa,WAAW;AACxD;AACA,eAAe,+DAAe,EAAE,aAAa,oBAAoB;AACjE;AACA,eAAe,kDAAU;AACzB;AACA;AACA,kEAAkE;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,GAAG,oDAAY;AAChB,iBAAiB,SAAS,0CAA0C;AACpE,CAAC,GAAG,mDAAY;AAChB,aAAa,6BAA6B;AAC1C,CAAC,GAAG,4DAAS;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,EAAE;AACR;AACA,QAAQ;AACR,CAAC;AACD;AACA,uBAAuB,mCAAmC;;AAE1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,0CAA0C;AACtE,kBAAkB,iFAAiF;AACnG;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,yDAAyD;AACzD;AACA;AACA;AACA;AACA,wCAAwC,kDAAW;AACnD;AACA;AACA,2CAA2C,mDAAW;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,cAAc;AAC3B;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEgD;;;;;;;;;;;;;AC9IhD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAsC;;AAEtC;AACA;AACA;AACA;AACA;AACA,eAAe,sBAAsB;AACrC;AACA,4BAA4B,kCAAkC;AAC9D;AACA;AACA;AACA,sEAAsE,8CAAO;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,oCAAoC;AACtD;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uFAAuF,OAAO;AAC9F;AACA;AACA;AACA;AACA;AACA,uBAAuB,uBAAuB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,yEAAyE;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,2CAA2C;AAChF;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,uBAAuB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,cAAc;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,uBAAuB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,yCAAyC;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,8CAA8C;AACnE,mBAAmB,4CAA4C;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,uBAAuB;AACtD;AACA;AACA;AACA;AACA;AACA,qBAAqB,8CAA8C;AACnE;AACA;AACA;AACA,2CAA2C,QAAQ;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,QAAQ;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,cAAc;AACxC,uBAAuB,cAAc;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA;AACA;AACA;;AAEwD;;;;;;;;;;;;;AC3nBxD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA4C;AACV;AACU;;AAE5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,yCAAyC;AACzD;AACA,cAAc,yCAAyC;AACvD;AACA,iBAAiB,iCAAiC;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,aAAa;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,sDAAQ;AACjE;AACA,oCAAoC,iBAAiB,sDAAQ,6CAA6C;AAC1G;AACA,kCAAkC,yBAAyB,sDAAQ,yCAAyC;AAC5G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,wBAAwB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,uCAAuC;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,mBAAmB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,mBAAmB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,cAAc;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,0BAA0B;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,4CAA4C;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,eAAe;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,yBAAyB;AAC9C;AACA;AACA;AACA;AACA;AACA,yBAAyB,mDAAQ;AACjC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0BAA0B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,gFAAgF;AACxG;AACA;AACA,aAAa,mBAAmB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,aAAa;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,wDAAwD;AACxE;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,wBAAwB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+EAA+E,WAAW;AAC1F,iBAAiB,mBAAmB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE;AAClE;AACA;AACA;AACA;AACA,uFAAuF;AACvF,6CAA6C;AAC7C;AACA;AACA;AACA;AACA,mDAAmD;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,iBAAiB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,kBAAkB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,0DAA0D;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,YAAY,MAAM,UAAU;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,sBAAsB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,QAAQ;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,qCAAqC;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,iEAAiE;AACtF;AACA;AACA,sBAAsB,0EAA0E;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA,wCAAwC,0CAAI;AAC5C,cAAc,0CAAI;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,wCAAwC;AAC3D;AACA;AACA,sBAAsB,2CAA2C;AACjE;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,+CAAI;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE+N;;;;;;;;;;;;;ACnwC/N;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA4C;AACoC;AACxC;;AAExC;AACA;AACA;AACA;AACA;AACA,2BAA2B,mDAAQ;AACnC;AACA,WAAW,kDAAW;AACtB;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA,2BAA2B,mDAAQ;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,MAAM;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,mDAAQ;AACtC;AACA,oCAAoC,+BAA+B;AACnE;AACA;AACA;AACA,sBAAsB,UAAU;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,8BAA8B;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,KAAK;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA,4BAA4B,mDAAQ;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,mCAAmC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,oBAAoB,KAAK;AACnD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,yBAAyB,mDAAQ;AACjC;AACA,WAAW,kDAAW;AACtB;AACA;AACA,6BAA6B,KAAK;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,iDAAU;AAClC,qBAAqB,iDAAU;AAC/B,2BAA2B,4BAA4B,+CAAI,2BAA2B,EAAE;AACxF,+BAA+B,2CAA2C;AAC1E,SAAS;AACT;AACA,YAAY,kDAAW;AACvB;AACA,YAAY,gDAAU;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,mCAAmC;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,mDAAQ;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,mDAAY;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,qDAAqD;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,cAAc;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,0BAA0B;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,UAAU;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA,+CAA+C,2BAA2B;AAC1E;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,wBAAwB,YAAY,mDAAQ,EAAE,mBAAmB,uBAAuB,EAAE,EAAE,EAAE;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE+I;;;;;;;;;;;;;AC3Y/I;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA,qCAAqC,gBAAgB;AACrD;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,WAAW;AAC3C;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4BAA4B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB,mBAAmB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,mBAAmB;AACtC;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA,YAAY;AACZ;;AAEA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA,qDAAqD,IAAI,yBAAyB,YAAY;AAC9F,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,EAAE,MAAM,WAAW;AAC3E,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gDAAgD;AAC/D;AACA;AACA;AACA;AACA,mBAAmB,qCAAqC;AACxD;AACA;AACA,uCAAuC,8CAA8C;AACrF;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,mCAAmC;AAC5D;AACA;AACA,gBAAgB,mCAAmC;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,yBAAyB;AAC1C,oBAAoB,aAAa;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,+CAA+C;AACrE,uBAAuB,4BAA4B;AACnD;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,0BAA0B;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,QAAQ;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,gDAAgD;AACtE;AACA;AACA,0BAA0B,0BAA0B;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,+BAA+B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,8BAA8B;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,mBAAmB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,8BAA8B;AACnD,gBAAgB,uBAAuB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B,iBAAiB,yBAAyB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,cAAc;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,8BAA8B;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE8I;;;;;;;;;;;;;AC/pB9I;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAqJ;AAC7G;AACc;AACf;AACqC;;AAE5E;AACA;AACA,QAAQ,0CAA0C,GAAG,mBAAmB,UAAU,EAAE,EAAE;AACtF;AACA;AACA,sCAAsC,GAAG;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,kCAAkC,KAAK;AACvC,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,oBAAoB;AAC3D;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA,uBAAuB,KAAK;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA,KAAK;AACL;AACA;AACA,uBAAuB,kBAAkB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,2DAA2D;AAC5F,gCAAgC,+DAA+D;AAC/F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,aAAa;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,aAAa;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,cAAc;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,0BAA0B;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,QAAQ;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,QAAQ;AAClC;AACA;AACA,uBAAuB,qBAAqB;AAC5C;AACA;AACA,yBAAyB,cAAc;AACvC,wBAAwB,cAAc;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,oBAAoB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,cAAc;AAChC,oBAAoB,eAAe;AACnC,eAAe,UAAU;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,yBAAyB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,sCAAsC;AACzD;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,6DAA6D;AAChG;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,kBAAkB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,aAAa;AACnC,wBAAwB,uCAAuC;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,aAAa;AACpC;AACA;AACA,qDAAqD;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,gDAAgD;AACnE,YAAY;AACZ,wDAAwD;AACxD,sBAAsB,cAAc;AACpC,2BAA2B,aAAa;AACxC,mBAAmB,gDAAgD;AACnE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,6BAA6B;AAC5C;AACA;AACA;AACA;AACA;AACA,qBAAqB,cAAc;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,WAAW;AACtC;AACA;AACA;AACA,yBAAyB,aAAa;AACtC;AACA,sBAAsB,aAAa;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8BAA8B;AAC/B;AACA;AACA;AACA;AACA,yBAAyB,oDAAU;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,cAAc;AAC/B;AACA,0BAA0B,cAAc;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,aAAa;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,kDAAQ;AACvB;AACA;AACA,iBAAiB,+DAA+D;AAChF;AACA;AACA,kBAAkB,kDAAQ;AAC1B;AACA;AACA,aAAa,aAAa;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,aAAa;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8EAA8E,8CAAO;AACrF;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,8CAAO,eAAe,8CAAO;AAC7E,4CAA4C,8CAAO,eAAe,8CAAO;AACzE;AACA;AACA,kDAAkD,8CAAO;AACzD;AACA;AACA,iBAAiB,aAAa;AAC9B;AACA;AACA;AACA;AACA;AACA,0BAA0B,wEAAwE;AAClG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,2CAA2C;AACpD;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,cAAc,4CAAK;AACnB,oBAAoB,qDAAW;AAC/B;AACA;AACA;AACA;AACA,uBAAuB,mBAAmB;AAC1C;AACA;AACA;AACA,eAAe,qDAAW,UAAU,yBAAyB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,mBAAmB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA,aAAa,qBAAqB;AAClC,aAAa,yBAAyB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA,uBAAuB,0BAA0B;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D;AAC7D;AACA;AACA;AACA,yBAAyB,0BAA0B;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,gCAAgC,0BAA0B;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,cAAc;AAChC,gBAAgB,uBAAuB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,eAAe;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,aAAa;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,yBAAyB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,OAAO;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,OAAO;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,kDAAQ;AAChB;AACA;AACA;AACA;AACA;AACA,aAAa,2CAA2C;AACxD,oBAAoB,iDAAiD;AACrE;;AAEA;AACA;AACA;AACA,mBAAmB,0CAAI;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,gBAAgB,aAAa;AAC9C;AACA;AACA,uBAAuB,wBAAwB;AAC/C;AACA;AACA;AACA;AACA,+DAA+D;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,yBAAyB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,yCAAyC;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,gCAAgC;AAC9C;AACA,kBAAkB,+BAA+B;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8BAA8B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,4CAA4C;AAChE,yBAAyB,gFAAgF;AACzG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,mBAAmB;AACnD,mCAAmC,mBAAmB;AACtD;AACA;AACA,wCAAwC,QAAQ;AAChD,iBAAiB,yBAAyB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,gCAAgC;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,iBAAiB,YAAY,GAAG;AAChD;AACA;AACA;AACA;AACA,2BAA2B;AAC3B,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,YAAY,EAAE,sCAAsC,EAAE,iDAAiD;AAC9H;AACA;AACA;AACA,yBAAyB,kBAAkB;AAC3C;AACA;AACA,gBAAgB;AAChB;AACA;AACA,aAAa,kCAAkC;AAC/C;AACA,aAAa,gBAAgB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,aAAa;AAC9B;AACA;AACA,aAAa,wBAAwB;AACrC,aAAa,wBAAwB;AACrC;AACA;AACA;AACA,aAAa,kCAAkC;AAC/C,kCAAkC,kBAAkB;AACpD,iBAAiB,aAAa;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,eAAe,YAAY,GAAG;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,mCAAmC;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,cAAc;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,0DAA0D;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,aAAa;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,kDAAQ;AAChB;AACA;AACA,wBAAwB,UAAU;AAClC;AACA;AACA;AACA,IAAI,kDAAQ;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA,wBAAwB,UAAU;AAClC;;AAEA;AACA,yBAAyB,4CAAK;AAC9B,gCAAgC,4CAAK;AACrC,2BAA2B,4CAAK;AAChC;AACA;AACA;AACA;AACA,qBAAqB,0BAA0B;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,4CAAK;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE,aAAa;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,aAAa;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,6BAA6B;AACzE,yBAAyB,4CAAK;AAC9B,qEAAqE;AACrE,CAAC;AACD,0BAA0B,4CAAK;AAC/B,qEAAqE;AACrE,CAAC;AACD;AACA,oBAAoB,4CAAK;AACzB,oBAAoB,4CAAK;AACzB,gBAAgB,4CAAK;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mFAAmF,gDAAS;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,yDAAyD;AAC1E;;AAEA;AACA;AACA;AACA;AACA,qCAAqC,QAAQ,GAAG;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,cAAc;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,4BAA4B,sCAAsC,GAAG;AACxG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,+EAA+E;AAC9F,2BAA2B,mDAAmD;AAC9E;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+EAA+E,0CAAI,kDAAkD,mDAAY;AACjJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,iDAAiD;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,wBAAwB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,cAAc;AACvE;AACA;AACA;AACA;AACA,qBAAqB,cAAc;AACnC;AACA;AACA;AACA,qBAAqB,oBAAoB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA,wBAAwB,WAAW;AACnC,aAAa,MAAM;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,kDAAQ;AAChB,4BAA4B,cAAc,WAAW,EAAE,EAAE;AACzD,qBAAqB,EAAE;AACvB;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,+CAA+C;AAC1D;AACA;AACA;AACA;AACA;AACA,iDAAiD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,mDAAY;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,mDAAY;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,kDAAQ;AACZ,gBAAgB,EAAE;AAClB;AACA;AACA,6BAA6B,sBAAsB;AACnD;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA,qBAAqB,gBAAgB;AACrC;AACA;AACA,YAAY;AACZ;AACA,uBAAuB,gBAAgB;AACvC;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB,aAAa,WAAW;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,WAAW;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,mDAAY;AAC1C;AACA,gBAAgB,uBAAuB;AACvC,sBAAsB,kBAAkB;AACxC,kBAAkB,mCAAmC;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,aAAa;AACpD;AACA;AACA;AACA,oCAAoC,mDAAY;AAChD,kCAAkC,mDAAY;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA,iBAAiB,yBAAyB;AAC1C,iBAAiB,wBAAwB;AACzC,iBAAiB,qBAAqB;AACtC,iBAAiB,yBAAyB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,2BAA2B,KAAK;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,SAAS;AACtB,cAAc,8BAA8B;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,WAAW;AACrC;AACA,gCAAgC,0BAA0B;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,eAAe;AAC5B;AACA,iBAAiB,WAAW;AAC5B;AACA;AACA,8BAA8B,WAAW;AACzC,iBAAiB,WAAW;AAC5B;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA,8CAA8C,mEAAmE;AACjH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,2BAA2B;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,eAAe;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,mBAAmB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,mDAAY,qDAAqD,mDAAY;AAC/F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,gCAAgC,+BAA+B,GAAG;AAChH;AACA;AACA,eAAe,qEAAqE;AACpF,aAAa,uBAAuB;AACpC,mBAAmB,cAAc;AACjC,sBAAsB,wBAAwB;AAC9C;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,kCAAkC;AAC9D,4BAA4B,kCAAkC;AAC9D;AACA;AACA;AACA,IAAI,kDAAQ;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uFAAuF,WAAW;AAClG,6CAA6C,yCAAyC;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,mBAAmB;AACxE,cAAc,yDAAW;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE,kCAAkC;AACtG,eAAe,mBAAmB,GAAG,wDAAU;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA,iBAAiB,6DAAe;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,SAAS,kDAAkD,WAAW,8BAA8B;AAClH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,6DAAe;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,MAAM;AACf,iCAAiC;AACjC;AACA;AACA,uBAAuB;AACvB;AACA,wBAAwB;AACxB,oBAAoB,qDAAc;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,WAAW;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,SAAS;AACtB;AACA,2BAA2B,+BAA+B;AAC1D;AACA;AACA,2BAA2B,OAAO;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,2BAA2B;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,aAAa;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,+DAA+D;AAC5F;AACA;AACA,mCAAmC,4DAA4D;AAC/F;AACA;AACA;AACA;AACA,uCAAuC,OAAO;AAC9C;AACA,uBAAuB,kBAAkB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,mBAAmB,SAAS;AAC5B;AACA;AACA;AACA,uBAAuB,kBAAkB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA,YAAY;AACZ;AACA,4BAA4B,OAAO;AACnC;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,2BAA2B;AAC7C;AACA;AACA;AACA;AACA,kBAAkB,4CAA4C;AAC9D;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,UAAU,eAAe;AACzB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,kDAAW;AACpD;AACA;AACA,aAAa,YAAY;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,qCAAqC;AAC9E;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,YAAY;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,kDAAW;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,UAAU;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,yBAAyB;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,gBAAgB;AAC5D;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,kBAAkB,kDAAW;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB,mBAAmB,qDAAc;AACjC;AACA,yBAAyB;AACzB,eAAe,qDAAc;AAC7B;AACA,UAAU;AACV;AACA;AACA,uBAAuB,qDAAc;AACrC,aAAa,aAAa;AAC1B,mBAAmB,qDAAc;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,qDAAc,iBAAiB,qDAAc;AACzF;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,sDAAe;AAClC;AACA;AACA;AACA,SAAS,kBAAkB,UAAU,EAAE;AACvC,SAAS,iBAAiB;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,qCAAqC;AACzE;AACA;AACA;AACA;AACA;AACA,SAAS,iBAAiB;AAC1B;AACA;AACA;AACA;AACA,qBAAqB,6CAAM;AAC3B;AACA,sBAAsB,sDAAe;AACrC,kBAAkB,kDAAW;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,gBAAgB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sFAAsF,kDAAW;AACjG;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,IAAI;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,KAAK;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,WAAW;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA,cAAc;AACd,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,yBAAyB;AACzB;AACA;AACA;AACA;AACA,aAAa,WAAW;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,6CAAM;AAC/B;AACA;AACA;AACA,aAAa,iDAAiD;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,sDAAe;AACpC;AACA;AACA;AACA;AACA;AACA,qBAAqB,6CAAM;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,kDAAW;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,kDAAW;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,mDAAmD;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,sDAAe;AACrD;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,kDAAW;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,6BAA6B;AAC9C;AACA;AACA;AACA;AACA;AACA,oBAAoB,gCAAgC;AACpD;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,qCAAqC;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qGAAqG,kDAAW;AAChH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,yBAAyB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,sBAAsB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,gBAAgB,IAAI,mBAAmB;AAC7D,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,QAAQ,qDAAW;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,iCAAiC;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,WAAW;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,8CAA8C;AAC/E;AACA,6BAA6B,+CAA+C;AAC5E;AACA,yBAAyB,8CAA8C;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,qDAAW;AAChC;AACA;AACA;AACA;AACA,eAAe,iDAAU;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA;AACA;;AAEA;AACA,gBAAgB;;AAE6G;;;;;;;;;;;;;ACn4IhH;;AAEb,8CAA8C,cAAc;;AAE5D,YAAY,mBAAO,CAAC,iDAAO;;AAE3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,uBAAuB,QAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,CAAC,GAAG,iBAAiB;;AAErB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,GAAG,iBAAiB;;AAErB;AACA;AACA;AACA;AACA;AACA,CAAC,GAAG,iBAAiB;;AAErB;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA,iCAAiC,oDAAoD,2QAA2Q,mPAAmP,kNAAkN,IAAI,0EAA0E,IAAI,aAAa,QAAQ,aAAa,6FAA6F,6CAA6C,sEAAsE,kCAAkC,WAAW,QAAQ,IAAI,YAAY,gCAAgC,WAAW,WAAW,4CAA4C,WAAW,mBAAmB,SAAS,WAAW,SAAS,KAAK,MAAM,WAAW,QAAQ,IAAI,UAAU,WAAW,QAAQ,IAAI,WAAW,SAAS,IAAI,WAAW,QAAQ,IAAI,6NAA6N,8BAA8B,IAAI,mEAAmE,+DAA+D,gMAAgM,6IAA6I,IAAI,oGAAoG,GAAG,mFAAmF,mEAAmE,+GAA+G,WAAW,wCAAwC,IAAI,QAAQ,IAAI,2PAA2P,iKAAiK,mNAAmN,mIAAmI,mVAAmV,uDAAuD,6EAA6E,mTAAmT,kRAAkR,kTAAkT,QAAQ,IAAI,uIAAuI,uCAAuC,oGAAoG,IAAI,WAAW,WAAW,uJAAuJ,IAAI,QAAQ,IAAI;AAC7lK,gKAAgK,+JAA+J,oHAAoH,gBAAgB,2MAA2M,uBAAuB,iCAAiC,6IAA6I,4OAA4O,KAAK,6FAA6F,eAAe,kCAAkC,UAAU,GAAG,EAAE,qIAAqI,QAAQ,EAAE,KAAK,QAAQ,EAAE,KAAK,QAAQ,EAAE,2FAA2F,uBAAuB,kOAAkO,gDAAgD,QAAQ,uDAAuD,sCAAsC,2CAA2C,gPAAgP,mJAAmJ,sIAAsI,eAAe,sNAAsN,2BAA2B,6HAA6H,0HAA0H,GAAG,EAAE,gBAAgB,UAAU,8IAA8I,2KAA2K,oJAAoJ,kMAAkM,+BAA+B,iCAAiC,QAAQ,sHAAsH,2BAA2B,kHAAkH,kIAAkI,eAAe,0HAA0H,eAAe,0HAA0H,eAAe,0HAA0H,eAAe,0HAA0H,eAAe,0HAA0H,eAAe,0HAA0H,eAAe,0HAA0H,eAAe,0HAA0H,eAAe,0HAA0H,eAAe,8GAA8G,2BAA2B,oGAAoG,kIAAkI,oHAAoH,gIAAgI,2BAA2B,oCAAoC,mEAAmE,gCAAgC,UAAU,6FAA6F,sBAAsB,+RAA+R,kMAAkM,iIAAiI,gFAAgF,QAAQ,gJAAgJ,oCAAoC,SAAS,QAAQ,mCAAmC,eAAe,QAAQ,+NAA+N,uNAAuN,uIAAuI,eAAe,uTAAuT,iJAAiJ,6CAA6C,2KAA2K,8IAA8I,yHAAyH,8BAA8B,kGAAkG,mHAAmH,oHAAoH,oHAAoH,oHAAoH,oHAAoH,oHAAoH,oHAAoH,oHAAoH,oHAAoH,oHAAoH,oHAAoH,gHAAgH,oHAAoH,2GAA2G,eAAe,IAAI,KAAK,GAAG,EAAE,IAAI,KAAK,KAAK,IAAI,IAAI,sFAAsF,4RAA4R,+GAA+G,mHAAmH,2OAA2O,6GAA6G,oHAAoH,gBAAgB,KAAK,IAAI,KAAK,UAAU,+MAA+M;AAC/jX,0BAA0B,wEAAwE,8ZAA8Z,qJAAqJ,oCAAoC,OAAO,KAAK,GAAG,6DAA6D,sKAAsK,iBAAiB,mEAAmE,2FAA2F,6IAA6I,wHAAwH,sBAAsB,IAAI,gMAAgM,kMAAkM,8PAA8P,wDAAwD,oBAAoB,IAAI,0HAA0H,6NAA6N,+KAA+K,kLAAkL,4FAA4F,EAAE,IAAI,iBAAiB,yHAAyH,qCAAqC,4GAA4G,IAAI,4CAA4C,+DAA+D,OAAO,kBAAkB,wGAAwG,mDAAmD,UAAU,2BAA2B,iRAAiR,KAAK;AAC5tH,8GAA8G,kHAAkH,2NAA2N;AAC3b;AACA,kDAAkD,EAAE,gBAAgB,EAAE,OAAO,EAAE,yBAAyB,EAAE,QAAQ,EAAE,QAAQ,EAAE,kBAAkB,EAAE;AAClJ;AACA;AACA,8DAA8D,GAAG,KAAK,GAAG,oEAAoE,IAAI,IAAI,gDAAgD,KAAK,2BAA2B,gBAAgB,gBAAgB,gBAAgB,gBAAgB,gBAAgB,2LAA2L,sBAAsB,wCAAwC,oEAAoE,6BAA6B,8BAA8B,6BAA6B,aAAa,eAAe,iBAAiB,IAAI,iDAAiD,GAAG,0BAA0B,IAAI,wCAAwC,IAAI,mIAAmI,GAAG,cAAc,IAAI,yBAAyB,GAAG,aAAa,GAAG,yCAAyC,GAAG,cAAc,IAAI,6EAA6E,GAAG,uCAAuC,GAAG,mFAAmF,GAAG,qBAAqB,GAAG,MAAM,SAAS,GAAG,qHAAqH,IAAI,qLAAqL,MAAM,YAAY,MAAM,6HAA6H,4EAA4E,gEAAgE,MAAM,UAAU,OAAO,iCAAiC,wCAAwC,gBAAgB,gBAAgB,gBAAgB,gBAAgB,gBAAgB;AACpnE;AACA;AACA,qBAAqB,4bAA4b;AACjd,IAAI,qCAAqC;AACzC;AACA,CAAC;;AAED;;;;;;;;;;;;;ACvGa;AACb;AACA;AACA;AACA,cAAc,gBAAgB,sCAAsC,iBAAiB,EAAE;AACvF,6BAA6B,uDAAuD;AACpF;AACA;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA,CAAC;AACD,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,kCAAkC,EAAE;AAC9D;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,mCAAmC,sBAAsB,8BAA8B,YAAY,EAAE,EAAE,EAAE;AACzG;AACA;AACA,mCAAmC,sBAAsB,sBAAsB,EAAE;AACjF;AACA;AACA,iCAAiC,sBAAsB,2BAA2B,aAAa,EAAE,EAAE,EAAE;AACrG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,4BAA4B;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,gBAAgB;AAClE;AACA;AACA;AACA,gCAAgC,0BAA0B;AAC1D;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,kBAAkB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,uBAAuB;AAC/C;AACA;AACA;AACA,yCAAyC,gBAAgB;AACzD;AACA;AACA,6CAA6C,qBAAqB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,uBAAuB,EAAE;AACnD;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,qCAAqC,GAAG;AACxC;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,UAAU;AACxC;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,wCAAwC,EAAE;AACpE;AACA;AACA,KAAK;AACL;AACA;AACA,0BAA0B,uCAAuC,EAAE;AACnE;AACA;AACA,KAAK;AACL;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,UAAU,EAAE;AACtC;AACA;AACA,KAAK;AACL;AACA;AACA,0BAA0B,oBAAoB,EAAE;AAChD;AACA;AACA,KAAK;AACL;AACA;AACA,uDAAuD,qBAAqB,EAAE;AAC9E;AACA;AACA;AACA;AACA;AACA,uBAAuB,0BAA0B;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,sCAAsC,EAAE;AAC5E;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,0BAA0B;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,wCAAwC;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,sBAAsB;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,0BAA0B;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,+CAA+C;AACxF;AACA;AACA;AACA;AACA;AACA,kCAAkC,wBAAwB;AAC1D;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,sBAAsB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,4BAA4B;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,cAAc;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,4BAA4B;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,SAAS;AAC5C;AACA;AACA;AACA;AACA,oCAAoC,kBAAkB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,kCAAkC;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,QAAQ;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,uBAAuB,EAAE;AACnD;AACA;AACA,KAAK;AACL;AACA,0BAA0B,sCAAsC,EAAE;AAClE;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,6BAA6B;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,gEAAgE,EAAE;AAC5F;AACA;AACA,KAAK;AACL;AACA,0BAA0B,8DAA8D,EAAE;AAC1F;AACA;AACA,KAAK;AACL;AACA,0BAA0B,8DAA8D,EAAE;AAC1F;AACA;AACA,KAAK;AACL;AACA,0BAA0B,2CAA2C,EAAE;AACvE;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,oCAAoC,EAAE;AAChE;AACA;AACA,KAAK;AACL;AACA,0BAA0B,oCAAoC,EAAE;AAChE;AACA;AACA,KAAK;AACL;AACA,0BAA0B,oCAAoC,EAAE;AAChE;AACA;AACA,KAAK;AACL;AACA,0BAA0B,oCAAoC,EAAE;AAChE;AACA;AACA,KAAK;AACL;AACA,0BAA0B,mBAAmB,EAAE;AAC/C;AACA;AACA,KAAK;AACL,mDAAmD,iBAAiB;AACpE,mDAAmD,sDAAsD;AACzG;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,mBAAmB;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,uCAAuC;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,QAAQ;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,QAAQ;AAClC;AACA;AACA,kBAAkB,QAAQ;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,oGAAoG;AACpG,mCAAmC,0BAA0B;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,qBAAqB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA,gC;;;;;;;;;;;;ACx8BA,+CAAa;;AAEb,8CAA8C,cAAc;;AAE5D,gBAAgB,mBAAO,CAAC,0DAAY;;AAEpC;AACA;AACA,+DAA+D;AAC/D;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU,gBAAgB,sCAAsC,iBAAiB,EAAE;AACnF,yBAAyB,uDAAuD;AAChF;AACA;;AAEA;AACA;AACA,mBAAmB,sBAAsB;AACzC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,mBAAmB,EAAE;AAC7E;AACA;AACA;AACA;AACA,6BAA6B,SAAS;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,UAAU;AACxC,kCAAkC,kBAAkB;AACpD,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf,eAAe;AACf,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,YAAY;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,+DAA+D,EAAE;AACxH,2BAA2B,wDAAwD;AACnF;AACA;AACA;AACA;AACA;AACA,uBAAuB,0DAA0D;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gGAAgG;AAChG;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA,yDAAyD;AACzD;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC,0BAA0B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,oCAAoC,EAAE;AAChE;AACA;AACA,KAAK;AACL;AACA,0BAA0B,oCAAoC,EAAE;AAChE;AACA;AACA,KAAK;AACL;AACA,0BAA0B,oCAAoC,EAAE;AAChE;AACA;AACA,KAAK;AACL;AACA,0BAA0B,oCAAoC,EAAE;AAChE;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,gCAAgC,wBAAwB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,2DAA2D;AAClH,iDAAiD,0CAA0C;AAC3F;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,oDAAoD;AACrH;AACA,CAAC;AACD;AACA;AACA;AACA,iCAAiC,cAAc;AAC/C;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,YAAY;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,YAAY;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,0BAA0B,oBAAoB;AAC9C;AACA,8BAA8B,oBAAoB;AAClD;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,wBAAwB,EAAE;AACpF;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,uBAAuB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,WAAW;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,SAAS;AAClC,sGAAsG,qCAAqC;AAC3I;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,gCAAgC,eAAe;AAC/C,kCAAkC,eAAe;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,mBAAmB;AAC1C;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,kCAAkC,EAAE;AACtF;AACA;AACA,+CAA+C,0BAA0B,EAAE;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,wBAAwB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,QAAQ;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,oBAAoB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,mBAAmB;AAC1C;AACA;AACA;AACA,2BAA2B,6CAA6C;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,gBAAgB;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA,iCAAiC,oBAAoB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,kBAAkB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,OAAO;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,eAAe;AAC9C;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA,iDAAiD,WAAW;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,SAAS;AAClC,oGAAoG,qCAAqC;AACzI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,iCAAiC;AAC7F;AACA;AACA;AACA;AACA,0BAA0B,YAAY;AACtC,4CAA4C;AAC5C;AACA,qDAAqD,WAAW;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,uBAAuB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,+BAA+B,EAAE;AAC3D;AACA;AACA,KAAK;AACL;AACA;AACA,0BAA0B,+BAA+B,EAAE;AAC3D;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,uBAAuB,0BAA0B;AACjD;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,gBAAgB;AACjE;AACA;AACA,+BAA+B,qBAAqB;AACpD;AACA;AACA,8EAA8E,sDAAsD,EAAE;AACtI,kLAAkL,6EAA6E,EAAE;AACjQ;AACA,qBAAqB,wGAAwG;AAC7H,SAAS;AACT;AACA;AACA,CAAC;AACD;AACA;AACA,sCAAsC,qCAAqC;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,sBAAsB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA,yFAAyF,uBAAuB,EAAE;AAClH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AClyCA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qCAAqC;;AAErC;AACA;AACA;;AAEA,2BAA2B;AAC3B;AACA;AACA;AACA,4BAA4B,UAAU;;;;;;;;;;;;;ACvLtC;AAAA;AAAA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,wBAAwB,0BAA0B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,iBAAiB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB,oBAAoB;AACvC;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,uBAAuB;AAC1D;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,qBAAqB,yBAAyB;AAC9C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,wBAAwB;AACpD,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,8CAA8C,iBAAiB,QAAQ;AACvE;;AAEA;AACA;AACA;AACA,kDAAkD;AAClD,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D;AAC3D,IAAI,iBAAiB;AACrB;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD,yBAAyB,KAAK;;;;;;;;;;;;;AC9J9B;;AAEA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;;AAEA;AACA;AACA,4CAA4C;;AAE5C;;;;;;;;;;;;;;;ACnBA,uHAAgD;AAChD,0HAAkD;AAClD,iIAAqD;AACrD,wJAA2D;AAC3D,6HAAmD;AACnD,sIAA6D;AAE7D,IAAM,sBAAsB,GAC1B,qEAAqE;AAEvE,IAAI,KAAK,GAAG,mBAAW,CAAC,MAAM,CAAC;IAC7B,GAAG,EAAE,sBAAsB;IAC3B,UAAU,EAAE;QAEV,4BAA4B;QAC5B,2CAA2C;QAC3C,8CAA8C;QAC9C,+CAA+C;QAC/C,wCAAwC;QACxC,sBAAsB;QACtB,iBAAU,CAAC,gBAAgB,CAAC,EAAE,CAAC;YAC7B,UAAU,EAAE,YAAY;YACxB,QAAQ,EAAE,UAAU;SACrB,CAAC;QAEF,oBAAW,EAAE;QACb,8BAAkB;QAElB,4BAAU,EAAE;KACb;CACF,CAAC;AAEF,IAAI,MAAM,GAAG,IAAI,iBAAU,CAAC,EAAC,KAAK,SAAC,CAAC;AAEpC,6BAA6B;AAC7B,IAAI,YAAY,GAAW,IAAI,CAAC;AAChC,IAAI,YAAY,GAAW,IAAI,CAAC;AAChC,SAAS,YAAY,CAAC,IAAgB,EAAE,KAAiB;IACnD,gCAA4C,EAA3C,oBAAO,EAAE,oBAAkC;IAChD,YAAY,GAAG,OAAO;IACtB,YAAY,GAAG,OAAO;IACtB,OAAO,KAAK;AACd,CAAC;AAED,0BAA0B;AAC1B,SAAS,UAAU,CAAC,IAAgB,EAAE,KAAiB;IACjD,gCAA4C,EAA3C,oBAAO,EAAE,oBAAkC;IAChD,IAAM,SAAS,GAAG,EAAE;IAEpB,IAAI,OAAO,GAAG,YAAY,GAAG,SAAS,EAAE;QACtC,QAAQ,CAAC,aAAa,CAAC,MAAM,CAAC;QAC9B,OAAO,IAAI;KACZ;IACD,IAAI,YAAY,GAAG,OAAO,GAAG,SAAS,EAAE;QACtC,QAAQ,CAAC,YAAY,CAAC,MAAM,CAAC;QAC7B,OAAO,IAAI;KACZ;IACD,IAAI,OAAO,GAAG,YAAY,GAAG,SAAS,EAAE;QACtC,QAAQ,CAAC,YAAY,CAAC,MAAM,CAAC;QAC7B,OAAO,IAAI;KACZ;IACD,IAAI,YAAY,GAAG,OAAO,GAAG,SAAS,EAAE;QACtC,QAAQ,CAAC,UAAU,CAAC,MAAM,CAAC;QAC3B,OAAO,IAAI;KACZ;IAED,OAAO,KAAK;AACd,CAAC;AAED,kCAAkC;AAClC,mCAAmC;AAEnC,IAAI,KAAK,GAAG,MAAM,CAAC,GAAG,CAAC,KAAK;AAC5B,KAAK,CAAC,KAAK,GAAG,OAAO;AACrB,KAAK,CAAC,MAAM,GAAG,OAAO;AAEtB,QAAQ,CAAC,IAAI,CAAC,KAAK,CAAC,MAAM,GAAG,KAAK;AAElC,QAAQ,CAAC,IAAI,CAAC,WAAW,CAAC,MAAM,CAAC,GAAG,CAAC;AAErC,MAAM,CAAC,KAAK,EAAE","file":"index.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/index.ts\");\n","import { EditorSelection, SelectionRange, Transaction, EditorState } from '../../state';\n\nfunction moveSelection(view, dir, granularity) {\n    let transaction = view.state.t().forEachRange(range => {\n        if (!range.empty && granularity != \"lineboundary\")\n            return new SelectionRange(dir == \"left\" || dir == \"backward\" ? range.from : range.to);\n        return new SelectionRange(view.movePos(range.head, dir, granularity, \"move\"));\n    });\n    if (transaction.selection.eq(view.state.selection))\n        return false;\n    if (granularity == \"line\")\n        transaction.annotate(Transaction.preserveGoalColumn, true);\n    view.dispatch(transaction.scrollIntoView());\n    return true;\n}\n/// Move the selection one character to the left (which is backward in\n/// left-to-right text, forward in right-to-left text).\nconst moveCharLeft = view => moveSelection(view, \"left\", \"character\");\n/// Move the selection one character to the right.\nconst moveCharRight = view => moveSelection(view, \"right\", \"character\");\n/// Move the selection one word to the left.\nconst moveWordLeft = view => moveSelection(view, \"left\", \"word\");\n/// Move the selection one word to the right.\nconst moveWordRight = view => moveSelection(view, \"right\", \"word\");\n/// Move the selection one line up.\nconst moveLineUp = view => moveSelection(view, \"backward\", \"line\");\n/// Move the selection one line down.\nconst moveLineDown = view => moveSelection(view, \"forward\", \"line\");\n/// Move the selection to the start of the line.\nconst moveLineStart = view => moveSelection(view, \"backward\", \"lineboundary\");\n/// Move the selection to the end of the line.\nconst moveLineEnd = view => moveSelection(view, \"forward\", \"lineboundary\");\nfunction extendSelection(view, dir, granularity) {\n    let transaction = view.state.t().forEachRange(range => {\n        return new SelectionRange(range.anchor, view.movePos(range.head, dir, granularity, \"extend\"));\n    });\n    if (transaction.selection.eq(view.state.selection))\n        return false;\n    if (granularity == \"line\")\n        transaction.annotate(Transaction.preserveGoalColumn, true);\n    view.dispatch(transaction.scrollIntoView());\n    return true;\n}\n/// Move the selection head one character to the left, while leaving\n/// the anchor in place.\nconst extendCharLeft = view => extendSelection(view, \"left\", \"character\");\n/// Move the selection head one character to the right.\nconst extendCharRight = view => extendSelection(view, \"right\", \"character\");\n/// Move the selection head one word to the left.\nconst extendWordLeft = view => extendSelection(view, \"left\", \"word\");\n/// Move the selection head one word to the right.\nconst extendWordRight = view => extendSelection(view, \"right\", \"word\");\n/// Move the selection head one line up.\nconst extendLineUp = view => extendSelection(view, \"backward\", \"line\");\n/// Move the selection head one line down.\nconst extendLineDown = view => extendSelection(view, \"forward\", \"line\");\n/// Move the selection head to the start of the line.\nconst extendLineStart = view => extendSelection(view, \"backward\", \"lineboundary\");\n/// Move the selection head to the end of the line.\nconst extendLineEnd = view => extendSelection(view, \"forward\", \"lineboundary\");\n/// Move the selection to the start of the document.\nconst selectDocStart = ({ state, dispatch }) => {\n    dispatch(state.t().setSelection(EditorSelection.single(0)).scrollIntoView());\n    return true;\n};\n/// Move the selection to the end of the document.\nconst selectDocEnd = ({ state, dispatch }) => {\n    dispatch(state.t().setSelection(EditorSelection.single(state.doc.length)).scrollIntoView());\n    return true;\n};\n/// Select the entire document.\nconst selectAll = ({ state, dispatch }) => {\n    dispatch(state.t().setSelection(EditorSelection.single(0, state.doc.length)));\n    return true;\n};\nfunction deleteText(view, dir) {\n    let transaction = view.state.t().forEachRange((range, transaction) => {\n        let { from, to } = range;\n        if (from == to) {\n            let target = view.movePos(range.head, dir, \"character\", \"move\");\n            from = Math.min(from, target);\n            to = Math.max(to, target);\n        }\n        if (from == to)\n            return range;\n        transaction.replace(from, to, \"\");\n        return new SelectionRange(from);\n    });\n    if (!transaction.docChanged)\n        return false;\n    view.dispatch(transaction.scrollIntoView());\n    return true;\n}\n/// Delete the character before the cursor (which is the one to left\n/// in left-to-right text, but the one to the right in right-to-left\n/// text).\nconst deleteCharBackward = view => deleteText(view, \"backward\");\n/// Delete the character after the cursor.\nconst deleteCharForward = view => deleteText(view, \"forward\");\n// FIXME support indenting by tab, configurable indent units\nfunction space(n) {\n    let result = \"\";\n    for (let i = 0; i < n; i++)\n        result += \" \";\n    return result;\n}\nfunction getIndentation(state, pos) {\n    for (let f of state.facet(EditorState.indentation)) {\n        let result = f(state, pos);\n        if (result > -1)\n            return result;\n    }\n    return -1;\n}\n/// Replace the selection with a newline and indent the newly created\n/// line(s).\nconst insertNewlineAndIndent = ({ state, dispatch }) => {\n    let i = 0, indentation = state.selection.ranges.map(r => {\n        let indent = getIndentation(state, r.from);\n        return indent > -1 ? indent : /^\\s*/.exec(state.doc.lineAt(r.from).slice(0, 50))[0].length;\n    });\n    dispatch(state.t().forEachRange(({ from, to }, tr) => {\n        let indent = indentation[i++], line = tr.doc.lineAt(to);\n        while (to < line.end && /s/.test(line.slice(to - line.start, to + 1 - line.start)))\n            to++;\n        tr.replace(from, to, [\"\", space(indent)]);\n        return new SelectionRange(from + indent + 1);\n    }).scrollIntoView());\n    return true;\n};\n/// Auto-indent the selected lines. This uses the [indentation\n/// behavor](#state.EditorState^indentation) as source.\nconst indentSelection = ({ state, dispatch }) => {\n    // FIXME this will base all indentation on the same state, which is\n    // wrong (indentation looks at the indent of previous lines, which may\n    // be changed).\n    let lastLine = -1, positions = [];\n    for (let range of state.selection.ranges) {\n        for (let { start, end } = state.doc.lineAt(range.from);;) {\n            if (start != lastLine) {\n                lastLine = start;\n                let indent = getIndentation(state, start), current;\n                if (indent > -1 &&\n                    indent != (current = /^\\s*/.exec(state.doc.slice(start, Math.min(end, start + 100)))[0].length))\n                    positions.push({ pos: start, current, indent });\n            }\n            if (end + 1 > range.to)\n                break;\n            ({ start, end } = state.doc.lineAt(end + 1));\n        }\n    }\n    if (positions.length > 0) {\n        let tr = state.t();\n        for (let { pos, current, indent } of positions) {\n            let start = tr.changes.mapPos(pos);\n            tr.replace(start, start + current, space(indent));\n        }\n        dispatch(tr);\n    }\n    return true;\n};\n/// The default keymap for Linux/Windows/non-Mac platforms. Binds the\n/// arrows for cursor motion, shift-arrow for selection extension,\n/// ctrl-arrows for by-word motion, home/end for line start/end,\n/// ctrl-home/end for document start/end, ctrl-a to select all,\n/// backspace/delete for deletion, and enter for newline-and-indent.\nconst pcBaseKeymap = {\n    \"ArrowLeft\": moveCharLeft,\n    \"ArrowRight\": moveCharRight,\n    \"Shift-ArrowLeft\": extendCharLeft,\n    \"Shift-ArrowRight\": extendCharRight,\n    \"Mod-ArrowLeft\": moveWordLeft,\n    \"Mod-ArrowRight\": moveWordRight,\n    \"Shift-Mod-ArrowLeft\": extendWordLeft,\n    \"Shift-Mod-ArrowRight\": extendWordRight,\n    \"ArrowUp\": moveLineUp,\n    \"ArrowDown\": moveLineDown,\n    \"Shift-ArrowUp\": extendLineUp,\n    \"Shift-ArrowDown\": extendLineDown,\n    \"Home\": moveLineStart,\n    \"End\": moveLineEnd,\n    \"Shift-Home\": extendLineStart,\n    \"Shift-End\": extendLineEnd,\n    \"Mod-Home\": selectDocStart,\n    \"Mod-End\": selectDocEnd,\n    \"Mod-a\": selectAll,\n    \"Backspace\": deleteCharBackward,\n    \"Delete\": deleteCharForward,\n    \"Enter\": insertNewlineAndIndent\n};\n/// The default keymap for Mac platforms. Includes the bindings from\n/// the [PC keymap](#commands.pcBaseKeymap) (using Cmd instead of\n/// Ctrl), and adds Mac-specific default bindings.\nconst macBaseKeymap = {\n    \"Control-b\": moveCharLeft,\n    \"Control-f\": moveCharRight,\n    \"Shift-Control-b\": extendCharLeft,\n    \"Shift-Control-f\": extendCharRight,\n    \"Control-p\": moveLineUp,\n    \"Control-n\": moveLineDown,\n    \"Shift-Control-p\": extendLineUp,\n    \"Shift-Control-n\": extendLineDown,\n    \"Control-a\": moveLineStart,\n    \"Control-e\": moveLineEnd,\n    \"Shift-Control-a\": extendLineStart,\n    \"Shift-Control-e\": extendLineEnd,\n    \"Cmd-ArrowUp\": selectDocStart,\n    \"Cmd-ArrowDown\": selectDocEnd,\n    \"Control-d\": deleteCharForward,\n    \"Control-h\": deleteCharBackward\n};\nfor (let key in pcBaseKeymap)\n    macBaseKeymap[key] = pcBaseKeymap[key];\nconst mac = typeof navigator != \"undefined\" ? /Mac/.test(navigator.platform)\n    : typeof os != \"undefined\" ? os.platform() == \"darwin\" : false;\n/// The default keymap for the current platform.\nconst baseKeymap = mac ? macBaseKeymap : pcBaseKeymap;\n\nexport { baseKeymap, deleteCharBackward, deleteCharForward, extendCharLeft, extendCharRight, extendLineDown, extendLineEnd, extendLineStart, extendLineUp, extendWordLeft, extendWordRight, indentSelection, insertNewlineAndIndent, macBaseKeymap, moveCharLeft, moveCharRight, moveLineDown, moveLineEnd, moveLineStart, moveLineUp, moveWordLeft, moveWordRight, pcBaseKeymap, selectAll, selectDocEnd, selectDocStart };\n","import { EditorView, ViewPlugin, themeClass, BlockType, PluginField } from '../../view';\nimport { RangeValue, Range, RangeSet } from '../../rangeset';\nimport { MapMode, Facet, fillConfig, Annotation, combineConfig } from '../../state';\n\n/// A gutter marker represents a bit of information attached to a line\n/// in a specific gutter. Your own custom markers have to extend this\n/// class.\nclass GutterMarker extends RangeValue {\n    /// @internal\n    compare(other) {\n        return this == other || this.constructor == other.constructor && this.eq(other);\n    }\n    /// Render the DOM node for this marker, if any.\n    toDOM(_view) { return null; }\n    /// Create a range that places this marker at the given position.\n    at(pos) { return new Range(pos, pos, this); }\n}\nGutterMarker.prototype.elementClass = \"\";\nGutterMarker.prototype.startMapMode = GutterMarker.prototype.endMapMode = MapMode.TrackBefore;\nconst defaults = {\n    style: \"\",\n    renderEmptyElements: false,\n    elementStyle: \"\",\n    initialMarkers: () => RangeSet.empty,\n    updateMarkers: (markers) => markers,\n    lineMarker: () => null,\n    initialSpacer: null,\n    updateSpacer: null,\n    domEventHandlers: {}\n};\nconst activeGutters = Facet.define();\n/// Define an editor gutter.\nfunction gutter(config) {\n    return [gutters(), activeGutters.of(fillConfig(config, defaults))];\n}\nconst baseTheme = EditorView.baseTheme({\n    gutters: {\n        background: \"#f5f5f5\",\n        borderRight: \"1px solid silver\",\n        color: \"#999\",\n        display: \"flex\",\n        height: \"100%\",\n        boxSizing: \"border-box\",\n        left: 0\n    },\n    gutter: {\n        display: \"flex !important\",\n        flexDirection: \"column\",\n        flexShrink: 0,\n        boxSizing: \"border-box\",\n        height: \"100%\",\n        overflow: \"hidden\"\n    },\n    gutterElement: {\n        boxSizing: \"border-box\"\n    },\n    \"gutterElement.lineNumber\": {\n        padding: \"0 3px 0 5px\",\n        minWidth: \"20px\",\n        textAlign: \"right\",\n        whiteSpace: \"nowrap\"\n    }\n});\nconst unfixGutters = Facet.define({\n    combine: values => values.some(x => x)\n});\n/// The gutter-drawing plugin is automatically enabled when you add a\n/// gutter, but you can use this function to explicitly configure it.\n///\n/// Unless `fixed` is explicitly set to `false`, the gutters are\n/// fixed, meaning they don't scroll along with the content\n/// horizontally.\nfunction gutters(config) {\n    let result = [\n        gutterView,\n        baseTheme\n    ];\n    if (config && config.fixed === false)\n        result.push(unfixGutters.of(true));\n    return result;\n}\nconst gutterView = ViewPlugin.fromClass(class {\n    constructor(view) {\n        this.view = view;\n        this.dom = document.createElement(\"div\");\n        this.dom.className = themeClass(\"gutters\");\n        this.dom.setAttribute(\"aria-hidden\", \"true\");\n        this.gutters = view.state.facet(activeGutters).map(conf => new SingleGutterView(view, conf));\n        for (let gutter of this.gutters)\n            this.dom.appendChild(gutter.dom);\n        this.fixed = !view.state.facet(unfixGutters);\n        if (this.fixed) {\n            // FIXME IE11 fallback, which doesn't support position: sticky,\n            // by using position: relative + event handlers that realign the\n            // gutter (or just force fixed=false on IE11?)\n            this.dom.style.position = \"sticky\";\n        }\n        view.scrollDOM.insertBefore(this.dom, view.contentDOM);\n    }\n    update(update) {\n        if (!this.updateGutters(update))\n            return;\n        let contexts = this.gutters.map(gutter => new UpdateContext(gutter, this.view.viewport));\n        this.view.viewportLines(line => {\n            let text;\n            if (Array.isArray(line.type))\n                text = line.type.find(b => b.type == BlockType.Text);\n            else\n                text = line.type == BlockType.Text ? line : undefined;\n            if (!text)\n                return;\n            for (let cx of contexts)\n                cx.line(this.view, text);\n        }, 0);\n        for (let cx of contexts)\n            cx.finish();\n        this.dom.style.minHeight = this.view.contentHeight + \"px\";\n        if (update.state.facet(unfixGutters) != !this.fixed) {\n            this.fixed = !this.fixed;\n            this.dom.style.position = this.fixed ? \"sticky\" : \"\";\n        }\n    }\n    updateGutters(update) {\n        let prev = update.prevState.facet(activeGutters), cur = update.state.facet(activeGutters);\n        let change = update.docChanged || update.heightChanged;\n        if (prev == cur) {\n            for (let gutter of this.gutters)\n                if (gutter.update(update))\n                    change = true;\n        }\n        else {\n            change = true;\n            let gutters = [];\n            for (let conf of cur) {\n                let known = prev.indexOf(conf);\n                if (known < 0) {\n                    gutters.push(new SingleGutterView(this.view, conf));\n                }\n                else {\n                    this.gutters[known].update(update);\n                    gutters.push(this.gutters[known]);\n                }\n            }\n            for (let g of this.gutters)\n                g.dom.remove();\n            for (let g of gutters)\n                this.dom.appendChild(g.dom);\n            this.gutters = gutters;\n        }\n        return change;\n    }\n}).provide(PluginField.scrollMargins, value => {\n    if (value.gutters.length == 0 || !value.fixed)\n        return null;\n    return value.view.textDirection == \"ltr\" ? { left: value.dom.offsetWidth } : { right: value.dom.offsetWidth };\n});\nclass UpdateContext {\n    constructor(gutter, viewport) {\n        this.gutter = gutter;\n        this.localMarkers = [];\n        this.i = 0;\n        this.height = 0;\n        this.cursor = gutter.markers.iter(viewport.from);\n    }\n    line(view, line) {\n        if (this.localMarkers.length)\n            this.localMarkers = [];\n        while (this.cursor.value && this.cursor.from <= line.from) {\n            if (this.cursor.from == line.from)\n                this.localMarkers.push(this.cursor.value);\n            this.cursor.next();\n        }\n        let forLine = this.gutter.config.lineMarker(view, line, this.localMarkers);\n        if (forLine)\n            this.localMarkers.unshift(forLine);\n        let gutter = this.gutter;\n        if (this.localMarkers.length == 0 && !gutter.config.renderEmptyElements)\n            return;\n        let above = line.top - this.height;\n        if (this.i == gutter.elements.length) {\n            let newElt = new GutterElement(view, line.height, above, this.localMarkers, gutter.elementClass);\n            gutter.elements.push(newElt);\n            gutter.dom.appendChild(newElt.dom);\n        }\n        else {\n            let markers = this.localMarkers, elt = gutter.elements[this.i];\n            if (sameMarkers(markers, elt.markers)) {\n                markers = elt.markers;\n                this.localMarkers.length = 0;\n            }\n            elt.update(view, line.height, above, markers, gutter.elementClass);\n        }\n        this.height = line.bottom;\n        this.i++;\n    }\n    finish() {\n        let gutter = this.gutter;\n        while (gutter.elements.length > this.i)\n            gutter.dom.removeChild(gutter.elements.pop().dom);\n    }\n}\nclass SingleGutterView {\n    constructor(view, config) {\n        this.view = view;\n        this.config = config;\n        this.elements = [];\n        this.spacer = null;\n        this.dom = document.createElement(\"div\");\n        this.dom.className = themeClass(\"gutter\" + (this.config.style ? \".\" + this.config.style : \"\"));\n        this.elementClass = themeClass(\"gutterElement\" + (this.config.style ? \".\" + this.config.style : \"\"));\n        for (let prop in config.domEventHandlers) {\n            this.dom.addEventListener(prop, (event) => {\n                let line = view.lineAtHeight(event.clientY);\n                if (config.domEventHandlers[prop](view, line, event))\n                    event.preventDefault();\n            });\n        }\n        this.markers = config.initialMarkers(view);\n        if (config.initialSpacer) {\n            this.spacer = new GutterElement(view, 0, 0, [config.initialSpacer(view)], this.elementClass);\n            this.dom.appendChild(this.spacer.dom);\n            this.spacer.dom.style.cssText += \"visibility: hidden; pointer-events: none\";\n        }\n    }\n    update(update) {\n        let prevMarkers = this.markers;\n        this.markers = this.config.updateMarkers(this.markers.map(update.changes), update);\n        if (this.spacer && this.config.updateSpacer) {\n            let updated = this.config.updateSpacer(this.spacer.markers[0], update);\n            if (updated != this.spacer.markers[0])\n                this.spacer.update(update.view, 0, 0, [updated], this.elementClass);\n        }\n        return this.markers == prevMarkers;\n    }\n    destroy() {\n        this.dom.remove();\n    }\n}\nclass GutterElement {\n    constructor(view, height, above, markers, eltClass) {\n        this.height = -1;\n        this.above = 0;\n        this.dom = document.createElement(\"div\");\n        this.update(view, height, above, markers, eltClass);\n    }\n    update(view, height, above, markers, cssClass) {\n        if (this.height != height)\n            this.dom.style.height = (this.height = height) + \"px\";\n        if (this.above != above)\n            this.dom.style.marginTop = (this.above = above) ? above + \"px\" : \"\";\n        if (this.markers != markers) {\n            this.markers = markers;\n            for (let ch; ch = this.dom.lastChild;)\n                ch.remove();\n            let cls = cssClass;\n            for (let m of markers) {\n                let dom = m.toDOM(view);\n                if (dom)\n                    this.dom.appendChild(dom);\n                let c = m.elementClass;\n                if (c)\n                    cls += \" \" + c;\n            }\n            this.dom.className = cls;\n        }\n    }\n}\nfunction sameMarkers(a, b) {\n    if (a.length != b.length)\n        return false;\n    for (let i = 0; i < a.length; i++)\n        if (!a[i].compare(b[i]))\n            return false;\n    return true;\n}\n/// Used to insert markers into the line number gutter.\nconst lineNumberMarkers = Annotation.define();\nconst lineNumberConfig = Facet.define({\n    combine(values) {\n        return combineConfig(values, { formatNumber: String, domEventHandlers: {} }, {\n            domEventHandlers(a, b) {\n                let result = {};\n                for (let event in a)\n                    result[event] = a[event];\n                for (let event in b) {\n                    let exists = result[event], add = b[event];\n                    result[event] = exists ? (view, line, event) => exists(view, line, event) || add(view, line, event) : add;\n                }\n                return result;\n            }\n        });\n    }\n});\nclass NumberMarker extends GutterMarker {\n    constructor(number) {\n        super();\n        this.number = number;\n    }\n    eq(other) { return this.number == other.number; }\n    toDOM(view) {\n        let config = view.state.facet(lineNumberConfig);\n        return document.createTextNode(config.formatNumber(this.number));\n    }\n}\nconst lineNumberGutter = gutter({\n    style: \"lineNumber\",\n    updateMarkers(markers, update) {\n        for (let tr of update.transactions) {\n            let ann = tr.annotation(lineNumberMarkers);\n            if (ann)\n                markers = markers.update(ann);\n        }\n        return markers;\n    },\n    lineMarker(view, line, others) {\n        if (others.length)\n            return null;\n        // FIXME try to make the line number queries cheaper?\n        return new NumberMarker(view.state.doc.lineAt(line.from).number);\n    },\n    initialSpacer(view) {\n        return new NumberMarker(maxLineNumber(view.state.doc.lines));\n    },\n    updateSpacer(spacer, update) {\n        let max = maxLineNumber(update.view.state.doc.lines);\n        return max == spacer.number ? spacer : new NumberMarker(max);\n    }\n});\n/// Create a line number gutter extension. The order in which the\n/// gutters appear is determined by their extension priority.\nfunction lineNumbers(config = {}) {\n    return [\n        lineNumberConfig.of(config),\n        lineNumberGutter\n    ];\n}\nfunction maxLineNumber(lines) {\n    let last = 9;\n    while (last < lines)\n        last = last * 10 + 9;\n    return last;\n}\n\nexport { GutterMarker, gutter, gutters, lineNumberMarkers, lineNumbers };\n","import { NodeProp, NodeType } from 'lezer-tree';\nimport { StyleModule } from 'style-mod';\nimport { ViewPlugin, EditorView, Decoration } from '../../view';\nimport { EditorState } from '../../state';\nimport { RangeSetBuilder } from '../../rangeset';\n\nconst Inherit = 1;\n/// A tag system defines a set of node (token) tags used for\n/// highlighting. You'll usually want to use the\n/// [default](#highlight.defaultTags) set, but it is possible to\n/// define your own custom system when that doesn't fit your use case.\nclass TagSystem {\n    /// Define a tag system. Each tag identifies a type of syntactic\n    /// element, which can have a single type and any number of flags.\n    /// The `flags` argument should be an array of flag names, and the\n    /// `types` argument an array of type names. Type names may have a\n    /// `\"name=parentName\"` format to specify that this type is an\n    /// instance of some other type, which means that, if no styling for\n    /// the type itself is provided, it'll fall back to the parent\n    /// type's styling.\n    ///\n    /// You can specify a `subtypes` property to assign a given number\n    /// of sub-types to each type. These are automatically generated\n    /// types with the base type name suffixed with `#1` to `#`_`N`_\n    /// (where _N_ is the number given in the `subtypes` field) that\n    /// have the base type as parent type.\n    constructor(options) {\n        /// @internal\n        this.typeNames = [\"\"];\n        /// @internal\n        this.typeIDs = Object.create(null);\n        /// A [node\n        /// prop](https://lezer.codemirror.net/docs/ref#tree.NodeProp) used\n        /// to associate styling tag information with syntax tree nodes.\n        this.prop = new NodeProp();\n        this.flags = options.flags;\n        this.types = options.types;\n        this.flagMask = Math.pow(2, this.flags.length) - 1;\n        this.typeShift = this.flags.length + 1;\n        let subtypes = options.subtypes || 0;\n        let parentNames = [undefined];\n        this.typeIDs[\"\"] = 0;\n        let typeID = 1;\n        for (let type of options.types) {\n            let match = /^([\\w\\-]+)(?:=([\\w-]+))?$/.exec(type);\n            if (!match)\n                throw new RangeError(\"Invalid type name \" + type);\n            let id = typeID++;\n            this.typeNames[id] = match[1];\n            this.typeIDs[match[1]] = id;\n            parentNames[id] = match[2];\n            for (let i = 0; i < subtypes; i++) {\n                let subID = typeID++, name = match[1] + \"#\" + (i + 1);\n                this.typeNames[subID] = name;\n                this.typeIDs[name] = subID;\n                parentNames[subID] = match[1];\n            }\n        }\n        this.parents = parentNames.map(name => {\n            if (name == null)\n                return 0;\n            let id = this.typeIDs[name];\n            if (id == null)\n                throw new RangeError(`Unknown parent type '${name}' specified`);\n            return id;\n        });\n        if (this.flags.length > 29 || this.typeNames.length > Math.pow(2, 29 - this.flags.length))\n            throw new RangeError(\"Too many style tag flags to fit in a 30-bit integer\");\n    }\n    /// Parse a tag name into a numeric ID. Only necessary if you are\n    /// manually defining [node properties](#highlight.TagSystem.prop)\n    /// for this system.\n    get(name) {\n        let value = name.charCodeAt(0) == 43 ? 1 : 0; // Check for leading '+'\n        for (let part of (value ? name.slice(1) : name).split(\" \"))\n            if (part) {\n                let flag = this.flags.indexOf(part);\n                if (flag > -1) {\n                    value += 1 << (flag + 1);\n                }\n                else {\n                    let typeID = this.typeIDs[part];\n                    if (typeID == null)\n                        throw new RangeError(`Unknown tag type '${part}'`);\n                    if (value >> this.typeShift)\n                        throw new RangeError(`Multiple tag types specified in '${name}'`);\n                    value += typeID << this.typeShift;\n                }\n            }\n        return value;\n    }\n    /// Create a\n    /// [`PropSource`](https://lezer.codemirror.net/docs/ref#tree.PropSource)\n    /// that adds node properties for this system. `tags` should map\n    /// node type\n    /// [selectors](https://lezer.codemirror.net/docs/ref#tree.NodeType^match)\n    /// to tag names.\n    add(tags) {\n        let match = NodeType.match(tags);\n        return this.prop.add((type) => {\n            let found = match(type);\n            return found == null ? undefined : this.get(found);\n        });\n    }\n    /// Create a highlighter extension for this system, styling the\n    /// given tags using the given CSS objects.\n    highlighter(spec) {\n        let styling = new Styling(this, spec);\n        return [\n            ViewPlugin.define(view => new Highlighter(view, this.prop, styling)).decorations(),\n            EditorView.styleModule.of(styling.module)\n        ];\n    }\n    /// @internal\n    specificity(tag) {\n        let flags = tag & this.flagMask, spec = 0;\n        for (let i = 1; i <= this.flags.length; i++)\n            if (flags & (1 << i))\n                spec++;\n        for (let type = tag >> (this.flags.length + 1); type; type = this.parents[type])\n            spec += 1000;\n        return spec;\n    }\n}\n/// The set of highlighting tags used by regular language packages and\n/// themes.\nconst defaultTags = new TagSystem({\n    flags: [\"invalid\", \"meta\",\n        \"link\", \"strong\", \"emphasis\", \"monospace\",\n        \"changed\", \"inserted\", \"deleted\",\n        \"definition\", \"constant\", \"control\"],\n    subtypes: 7,\n    types: [\n        \"comment\",\n        \"lineComment=comment\",\n        \"blockComment=comment\",\n        \"name\",\n        \"variableName=name\",\n        \"typeName=name\",\n        \"propertyName=name\",\n        \"className=name\",\n        \"labelName=name\",\n        \"namespace=name\",\n        \"literal\",\n        \"string=literal\",\n        \"character=string\",\n        \"number=literal\",\n        \"integer=number\",\n        \"float=number\",\n        \"regexp=literal\",\n        \"escape=literal\",\n        \"color=literal\",\n        \"content\",\n        \"heading=content\",\n        \"list=content\",\n        \"quote=content\",\n        \"keyword\",\n        \"self=keyword\",\n        \"null=keyword\",\n        \"atom=keyword\",\n        \"unit=keyword\",\n        \"modifier=keyword\",\n        \"operatorKeyword=keyword\",\n        \"operator\",\n        \"derefOperator=operator\",\n        \"arithmeticOperator=operator\",\n        \"logicOperator=operator\",\n        \"bitwiseOperator=operator\",\n        \"compareOperator=operator\",\n        \"updateOperator=operator\",\n        \"typeOperator=operator\",\n        \"punctuation\",\n        \"separator=punctuation\",\n        \"bracket=punctuation\",\n        \"angleBracket=bracket\",\n        \"squareBracket=bracket\",\n        \"paren=bracket\",\n        \"brace=bracket\"\n    ]\n});\n/// Used to add a set of tags to a language syntax via\n/// [`Parser.withProps`](https://lezer.codemirror.net/docs/ref#lezer.Parser.withProps).\n/// The argument object can use syntax node selectors (see\n/// [`NodeType.match`](https://lezer.codemirror.net/docs/ref#tree.NodeType^match))\n/// as property names, and tag names (in the [default tag\n/// system](#highlight.defaultTags)) as values.\nconst styleTags = (tags) => defaultTags.add(tags);\n/// Create a highlighter theme that adds the given styles to the given\n/// tags. The spec's property names must be tag names, and the values\n/// [`style-mod`](https://github.com/marijnh/style-mod#documentation)\n/// style objects that define the CSS for that tag.\nconst highlighter = (spec) => defaultTags.highlighter(spec);\nclass StyleRule {\n    constructor(type, flags, specificity, cls) {\n        this.type = type;\n        this.flags = flags;\n        this.specificity = specificity;\n        this.cls = cls;\n    }\n}\nclass Styling {\n    constructor(tags, spec) {\n        this.tags = tags;\n        this.cache = Object.create(null);\n        let modSpec = Object.create(null);\n        let nextCls = 0;\n        let rules = [];\n        for (let prop in spec) {\n            let tag = tags.get(prop);\n            let cls = \"c\" + nextCls++;\n            modSpec[cls] = spec[prop];\n            rules.push(new StyleRule(tag >> tags.typeShift, tag & tags.flagMask, tags.specificity(tag), cls));\n        }\n        this.rules = rules.sort((a, b) => b.specificity - a.specificity);\n        this.module = new StyleModule(modSpec);\n    }\n    match(tag) {\n        let known = this.cache[tag];\n        if (known != null)\n            return known;\n        let result = \"\";\n        let type = tag >> this.tags.typeShift, flags = tag & this.tags.flagMask;\n        for (;;) {\n            for (let rule of this.rules) {\n                if (rule.type == type && (rule.flags & flags) == rule.flags) {\n                    if (result)\n                        result += \" \";\n                    result += this.module[rule.cls];\n                    flags &= ~rule.flags;\n                    if (type)\n                        break;\n                }\n            }\n            if (type)\n                type = this.tags.parents[type];\n            else\n                break;\n        }\n        return this.cache[tag] = result;\n    }\n}\nclass Highlighter {\n    constructor(view, prop, styling) {\n        this.prop = prop;\n        this.styling = styling;\n        this.tree = view.state.tree;\n        this.decorations = this.buildDeco(view.visibleRanges, this.tree);\n    }\n    update(update) {\n        let syntax = update.state.facet(EditorState.syntax);\n        if (!syntax.length) {\n            this.decorations = Decoration.none;\n        }\n        else if (syntax[0].parsePos(update.state) < update.view.viewport.to) {\n            this.decorations = this.decorations.map(update.changes);\n        }\n        else if (this.tree != syntax[0].getTree(update.state) || update.viewportChanged) {\n            this.tree = syntax[0].getTree(update.state);\n            this.decorations = this.buildDeco(update.view.visibleRanges, this.tree);\n        }\n    }\n    buildDeco(ranges, tree) {\n        let builder = new RangeSetBuilder();\n        let start = 0;\n        function flush(pos, style) {\n            if (pos > start && style)\n                builder.add(start, pos, Decoration.mark({ class: style })); // FIXME cache these\n            start = pos;\n        }\n        for (let { from, to } of ranges) {\n            start = from;\n            // The current node's own classes\n            let curClass = \"\";\n            let context = [];\n            let inherited = [];\n            tree.iterate({\n                from, to,\n                enter: (type, start) => {\n                    let inheritedClass = inherited.length ? inherited[inherited.length - 1] : \"\";\n                    let cls = inheritedClass;\n                    let style = type.prop(this.prop);\n                    if (style != null) {\n                        let val = this.styling.match(style);\n                        if (val) {\n                            if (cls)\n                                cls += \" \";\n                            cls += val;\n                        }\n                        if (style & Inherit)\n                            inheritedClass = cls;\n                    }\n                    context.push(cls);\n                    if (inheritedClass)\n                        inherited.push(inheritedClass);\n                    if (cls != curClass) {\n                        flush(start, curClass);\n                        curClass = cls;\n                    }\n                },\n                leave: (_t, _s, end) => {\n                    context.pop();\n                    inherited.pop();\n                    let backTo = context.length ? context[context.length - 1] : \"\";\n                    if (backTo != curClass) {\n                        flush(Math.min(to, end), curClass);\n                        curClass = backTo;\n                    }\n                }\n            });\n        }\n        return builder.finish();\n    }\n}\n/// A default highlighter (works well with light themes).\nconst defaultHighlighter = highlighter({\n    invalid: { color: \"#f00\" },\n    keyword: { color: \"#708\" },\n    atom: { color: \"#219\" },\n    number: { color: \"#164\" },\n    string: { color: \"#a11\" },\n    character: { color: \"#a11\" },\n    regexp: { color: \"#e40\" },\n    escape: { color: \"#e40\" },\n    \"variableName definition\": { color: \"#00f\" },\n    typeName: { color: \"#085\" },\n    \"propertyName definition\": { color: \"#00c\" },\n    comment: { color: \"#940\" },\n    meta: { color: \"#555\" }\n});\n\nexport { TagSystem, defaultHighlighter, defaultTags, highlighter, styleTags };\n","import { parser } from 'lezer-javascript';\nimport { continuedIndent, LezerSyntax, indentNodeProp, flatIndent, foldNodeProp } from '../../syntax';\nimport { languageData, EditorState } from '../../state';\nimport { styleTags } from '../../highlight';\n\nconst statementIndent = continuedIndent({ except: /^{/ });\n/// A syntax provider based on the [Lezer JavaScript\n/// parser](https://github.com/lezer-parser/javascript), extended with\n/// highlighting and indentation information.\nconst javascriptSyntax = new LezerSyntax(parser.withProps(indentNodeProp.add(type => {\n    if (type.name == \"IfStatement\")\n        return continuedIndent({ except: /^({|else\\b)/ });\n    if (type.name == \"TryStatement\")\n        return continuedIndent({ except: /^({|catch|finally)\\b/ });\n    if (type.name == \"LabeledStatement\")\n        return flatIndent;\n    if (type.name == \"SwitchBody\")\n        return context => {\n            let after = context.textAfter, closed = after[0] == \"}\", isCase = /^(case|default)\\b/.test(after);\n            return context.baseIndent + (closed ? 0 : isCase ? 1 : 2) * context.unit;\n        };\n    if (type.name == \"TemplateString\" || type.name == \"BlockComment\")\n        return () => -1;\n    if (/(Statement|Declaration)$/.test(type.name) || type.name == \"Property\")\n        return statementIndent;\n    return undefined;\n}), foldNodeProp.add({\n    Block(tree) { return { from: tree.start + 1, to: tree.end - 1 }; }\n}), languageData.add({\n    Script: { closeBrackets: [\"(\", \"[\", \"{\", \"'\", '\"', \"`\"] }\n}), styleTags({\n    \"get set async static\": \"modifier\",\n    \"for while do if else switch try catch finally return throw break continue default case\": \"keyword control\",\n    \"in of await yield void typeof delete instanceof\": \"operatorKeyword\",\n    \"export import let var const function class extends\": \"keyword definition\",\n    \"with debugger from as\": \"keyword\",\n    TemplateString: \"string#2\",\n    \"BooleanLiteral Super\": \"atom\",\n    this: \"self\",\n    null: \"null\",\n    Star: \"modifier\",\n    VariableName: \"variableName\",\n    VariableDefinition: \"variableName definition\",\n    Label: \"labelName\",\n    PropertyName: \"propertyName\",\n    PropertyNameDefinition: \"propertyName definition\",\n    \"PostfixOp UpdateOp\": \"updateOperator\",\n    LineComment: \"lineComment\",\n    BlockComment: \"blockComment\",\n    Number: \"number\",\n    String: \"string\",\n    ArithOp: \"arithmeticOperator\",\n    LogicOp: \"logicOperator\",\n    BitOp: \"bitwiseOperator\",\n    CompareOp: \"compareOperator\",\n    RegExp: \"regexp\",\n    Equals: \"operator definition\",\n    Spread: \"punctuation\",\n    \"Arrow :\": \"punctuation definition\",\n    \"( )\": \"paren\",\n    \"[ ]\": \"squareBracket\",\n    \"{ }\": \"brace\",\n    \".\": \"derefOperator\",\n    \", ;\": \"separator\"\n})));\n/// Returns an extension that installs the JavaScript syntax provider.\nfunction javascript() { return javascriptSyntax.extension; }\n\n/// Connects an [ESLint](https://eslint.org/) linter to CodeMirror's\n/// [lint](#lint) integration. `eslint` should be an instance of the\n/// [`Linter`](https://eslint.org/docs/developer-guide/nodejs-api#linter)\n/// class, and `config` an optional ESLint configuration. The return\n/// value of this function can be passed to [`linter`](#lint.linter)\n/// to create a JavaScript linting extension.\n///\n/// Note that ESLint targets node, and is tricky to run in the\n/// browser. The [eslint4b](https://github.com/mysticatea/eslint4b)\n/// and\n/// [eslint4b-prebuilt](https://github.com/marijnh/eslint4b-prebuilt/)\n/// packages may help with that.\nfunction esLint(eslint, config) {\n    if (!config) {\n        config = {\n            parserOptions: { ecmaVersion: 2019, sourceType: \"module\" },\n            env: { browser: true, node: true, es6: true, es2015: true, es2017: true, es2020: true },\n            rules: {}\n        };\n        eslint.getRules().forEach((desc, name) => {\n            if (desc.meta.docs.recommended)\n                config.rules[name] = 2;\n        });\n    }\n    function range(state, from = 0, to = state.doc.length) {\n        let fromLine = state.doc.lineAt(from), offset = { line: fromLine.number - 1, col: from - fromLine.start, pos: from };\n        return eslint.verify(state.doc.slice(from, to), config)\n            .map((val) => translateDiagnostic(val, state.doc, offset));\n    }\n    return (view) => {\n        let [syntax] = view.state.facet(EditorState.syntax);\n        if (syntax == javascriptSyntax)\n            return range(view.state);\n        if (!syntax || !(syntax instanceof LezerSyntax && syntax.parser.hasNested))\n            return [];\n        let found = [];\n        // FIXME move to async parsing?\n        syntax.getTree(view.state).iterate({\n            enter(type, start, end) {\n                if (type == javascriptSyntax.docNodeType) {\n                    for (let d of range(view.state, start, end))\n                        found.push(d);\n                    return false;\n                }\n                return undefined;\n            }\n        });\n        return found;\n    };\n}\nfunction mapPos(line, col, doc, offset) {\n    return doc.line(line + offset.line).start + col + (line == 1 ? offset.col - 1 : -1);\n}\nfunction translateDiagnostic(input, doc, offset) {\n    let start = mapPos(input.line, input.column, doc, offset);\n    let result = {\n        from: start,\n        to: input.endLine != null && input.endColumn != 1 ? mapPos(input.endLine, input.endColumn, doc, offset) : start,\n        message: input.message,\n        source: input.ruleId ? \"jshint:\" + input.ruleId : \"jshint\",\n        severity: input.severity == 1 ? \"warning\" : \"error\",\n    };\n    if (input.fix) {\n        let { range, text } = input.fix, from = range[0] + offset.pos - start, to = range[1] + offset.pos - start;\n        result.actions = [{\n                name: \"fix\",\n                apply(view, start) {\n                    view.dispatch(view.state.t().replace(start + from, start + to, text).scrollIntoView());\n                }\n            }];\n    }\n    return result;\n}\n\nexport { esLint, javascript, javascriptSyntax };\n","import { MapMode } from '../../state';\n\n/// Each range is associated with a value, which must inherit from\n/// this class.\nclass RangeValue {\n    /// Compare this value with another value. The default\n    /// implementation compares by identity.\n    eq(other) { return this == other; }\n    /// Create a [range](#rangeset.Range) with this value.\n    range(from, to = from) { return new Range(from, to, this); }\n}\nRangeValue.prototype.startSide = RangeValue.prototype.endSide = 0;\nRangeValue.prototype.point = false;\nRangeValue.prototype.startMapMode = RangeValue.prototype.endMapMode = MapMode.TrackDel;\n/// A range associates a value with a range of positions.\nclass Range {\n    /// @internal\n    constructor(\n    /// The range's start position.\n    from, \n    /// Its end position.\n    to, \n    /// The value associated with this range.\n    value) {\n        this.from = from;\n        this.to = to;\n        this.value = value;\n    }\n}\nfunction cmpRange(a, b) {\n    return a.from - b.from || a.value.startSide - b.value.startSide;\n}\n// The maximum amount of ranges to store in a single chunk\nconst ChunkSize = 250, \n// Chunks with points of this size are never skipped during\n// compare, since moving past those points is likely to speed\n// up, rather than slow down, the comparison.\nBigPointSize = 500, \n// A large (fixnum) value to use for max/min values.\nFar = 1e9;\nclass Chunk {\n    constructor(from, to, value, \n    // Chunks are marked with the largest point that occurs\n    // in them (or -1 for no points), so that scans that are\n    // only interested in points (such as the\n    // heightmap-related logic) can skip range-only chunks.\n    maxPoint) {\n        this.from = from;\n        this.to = to;\n        this.value = value;\n        this.maxPoint = maxPoint;\n    }\n    get length() { return this.to[this.to.length - 1]; }\n    // With side == -1, return the first index where to >= pos. When\n    // side == 1, the first index where from > pos.\n    findIndex(pos, end, side = end * Far, startAt = 0) {\n        if (pos <= 0)\n            return startAt;\n        let arr = end < 0 ? this.to : this.from;\n        for (let lo = startAt, hi = arr.length;;) {\n            if (lo == hi)\n                return lo;\n            let mid = (lo + hi) >> 1;\n            let diff = arr[mid] - pos || (end < 0 ? this.value[mid].startSide : this.value[mid].endSide) - side;\n            if (mid == lo)\n                return diff >= 0 ? lo : hi;\n            if (diff >= 0)\n                hi = mid;\n            else\n                lo = mid + 1;\n        }\n    }\n    between(offset, from, to, f) {\n        for (let i = this.findIndex(from, -1), e = this.findIndex(to, 1, undefined, i); i < e; i++)\n            if (f(this.from[i] + offset, this.to[i] + offset, this.value[i]) === false)\n                return false;\n    }\n    map(offset, changes) {\n        let value = [], from = [], to = [], newPos = -1, maxPoint = -1;\n        for (let i = 0; i < this.value.length; i++) {\n            let val = this.value[i];\n            let newFrom = changes.mapPos(this.from[i] + offset, val.startSide, val.startMapMode);\n            let newTo = changes.mapPos(this.to[i] + offset, val.endSide, val.endMapMode);\n            if (newTo < 0) {\n                if (newFrom < 0)\n                    continue;\n                newTo = -(newTo + 1);\n            }\n            if (newFrom < 0)\n                newFrom = -(newFrom + 1);\n            if ((newTo - newFrom || val.endSide - val.startSide) < 0)\n                continue;\n            if (newPos < 0)\n                newPos = newFrom;\n            if (val.point)\n                maxPoint = Math.max(maxPoint, newTo - newFrom);\n            value.push(val);\n            from.push(newFrom - newPos);\n            to.push(newTo - newPos);\n        }\n        return { mapped: value.length ? new Chunk(from, to, value, maxPoint) : null, pos: newPos };\n    }\n}\n/// A range set stores a collection of [ranges](#rangeset.Range) in a\n/// way that makes them efficient to [map](#rangeset.RangeSet.map) and\n/// [update](#rangeset.RangeSet.update). This is an immutable data\n/// structure.\nclass RangeSet {\n    /// @internal\n    constructor(\n    /// @internal\n    chunkPos, \n    /// @internal\n    chunk, \n    /// @internal\n    nextLayer = RangeSet.empty, \n    /// @internal\n    maxPoint) {\n        this.chunkPos = chunkPos;\n        this.chunk = chunk;\n        this.nextLayer = nextLayer;\n        this.maxPoint = maxPoint;\n    }\n    /// @internal\n    get length() {\n        let last = this.chunk.length - 1;\n        return last < 0 ? 0 : Math.max(this.chunkEnd(last), this.nextLayer.length);\n    }\n    /// @internal\n    get size() {\n        if (this == RangeSet.empty)\n            return 0;\n        let size = this.nextLayer.size;\n        for (let chunk of this.chunk)\n            size += chunk.value.length;\n        return size;\n    }\n    /// @internal\n    chunkEnd(index) {\n        return this.chunkPos[index] + this.chunk[index].length;\n    }\n    /// Update the range set, optionally adding new ranges or filtering\n    /// out existing ones.\n    update({ add = [], sort = false, filter, filterFrom = 0, filterTo = this.length }) {\n        if (add.length == 0 && !filter)\n            return this;\n        if (sort)\n            add.slice().sort(cmpRange);\n        if (this == RangeSet.empty)\n            return add.length ? RangeSet.of(add) : this;\n        let cur = new LayerCursor(this, null, -1).goto(0), i = 0, spill = [];\n        let builder = new RangeSetBuilder();\n        while (cur.value || i < add.length) {\n            if (i < add.length && (cur.from - add[i].from || cur.startSide - add[i].value.startSide) >= 0) {\n                let range = add[i++];\n                if (!builder.addInner(range.from, range.to, range.value))\n                    spill.push(range);\n            }\n            else if (cur.rangeIndex == 1 && cur.chunkIndex < this.chunk.length &&\n                (i == add.length || this.chunkEnd(cur.chunkIndex) < add[i].from) &&\n                (!filter || filterFrom > this.chunkEnd(cur.chunkIndex) || filterTo < this.chunkPos[cur.chunkIndex]) &&\n                builder.addChunk(this.chunkPos[cur.chunkIndex], this.chunk[cur.chunkIndex])) {\n                cur.nextChunk();\n            }\n            else {\n                if (!filter || filterFrom > cur.to || filterTo < cur.from || filter(cur.from, cur.to, cur.value)) {\n                    if (!builder.addInner(cur.from, cur.to, cur.value))\n                        spill.push(new Range(cur.from, cur.to, cur.value));\n                }\n                cur.next();\n            }\n        }\n        return builder.finishInner(this.nextLayer == RangeSet.empty && !spill.length ? RangeSet.empty\n            : this.nextLayer.update({ add: spill, filter, filterFrom, filterTo }));\n    }\n    /// Map this range set through a set of changes, return the new set.\n    map(changes) {\n        if (changes.length == 0 || this == RangeSet.empty)\n            return this;\n        let chunks = [], chunkPos = [], maxPoint = -1;\n        for (let i = 0; i < this.chunk.length; i++) {\n            let start = this.chunkPos[i], chunk = this.chunk[i];\n            let touch = changes.touchesRange(start, start + chunk.length);\n            if (touch === false) {\n                maxPoint = Math.max(maxPoint, chunk.maxPoint);\n                chunks.push(chunk);\n                chunkPos.push(changes.mapPos(start));\n            }\n            else if (touch === true) {\n                let { mapped, pos } = chunk.map(start, changes);\n                if (mapped) {\n                    maxPoint = Math.max(maxPoint, mapped.maxPoint);\n                    chunks.push(mapped);\n                    chunkPos.push(pos);\n                }\n            }\n        }\n        let next = this.nextLayer.map(changes);\n        return chunks.length == 0 ? next : new RangeSet(chunkPos, chunks, next, maxPoint);\n    }\n    /// Iterate over the ranges that touch the region `from` to `to`,\n    /// calling `f` for each. There is no guarantee that the ranges will\n    /// be reported in any order. When the callback returns `false`,\n    /// iteration stops.\n    between(from, to, f) {\n        if (this == RangeSet.empty)\n            return;\n        for (let i = 0; i < this.chunk.length; i++) {\n            let start = this.chunkPos[i], chunk = this.chunk[i];\n            if (to >= start && from <= start + chunk.length &&\n                chunk.between(start, from - start, to - start, f) === false)\n                return;\n        }\n        this.nextLayer.between(from, to, f);\n    }\n    /// Iterate over the ranges in the set that touch the area between\n    /// from and to, ordered by their start position and side.\n    iter(from = 0) {\n        return HeapCursor.from([this]).goto(from);\n    }\n    /// Iterate over two groups of sets, calling methods on `comparator`\n    /// to notify it of possible differences. `textDiff` indicates how\n    /// the underlying data changed between these ranges, and is needed\n    /// to synchronize the iteration. `from` and `to` are coordinates in\n    /// the _new_ space, after these changes.\n    static compare(oldSets, newSets, textDiff, length, comparator) {\n        var _a;\n        let minPoint = (_a = comparator.minPointSize, (_a !== null && _a !== void 0 ? _a : -1));\n        let a = oldSets.filter(set => set.maxPoint >= BigPointSize ||\n            set != RangeSet.empty && newSets.indexOf(set) < 0 && set.maxPoint >= minPoint);\n        let b = newSets.filter(set => set.maxPoint >= BigPointSize ||\n            set != RangeSet.empty && oldSets.indexOf(set) < 0 && set.maxPoint >= minPoint);\n        let sharedChunks = findSharedChunks(a, b);\n        let sideA = new SpanCursor(a, sharedChunks, minPoint);\n        let sideB = new SpanCursor(b, sharedChunks, minPoint);\n        let posA = 0, posB = 0;\n        for (let range of textDiff) {\n            compare(sideA, posA, sideB, posB, range.fromB - posB, comparator);\n            posA = range.toA;\n            posB = range.toB;\n        }\n        compare(sideA, posA, sideB, posB, length - posB, comparator);\n    }\n    /// Iterate over a group of range sets at the same time, notifying\n    /// the iterator about the ranges covering every given piece of\n    /// content.\n    static spans(sets, from, to, iterator) {\n        var _a;\n        let cursor = new SpanCursor(sets, null, (_a = iterator.minPointSize, (_a !== null && _a !== void 0 ? _a : -1))).goto(from), pos = from;\n        for (;;) {\n            let curTo = Math.min(cursor.to, to);\n            if (cursor.point)\n                iterator.point(pos, curTo, cursor.point, cursor.pointFrom < from, cursor.to > to);\n            else if (curTo > pos)\n                iterator.span(pos, curTo, cursor.active);\n            if (cursor.to > to)\n                break;\n            pos = cursor.to;\n            cursor.next();\n        }\n    }\n    /// Create a range set for the given range or array of ranges. By\n    /// default, this expects the ranges to be _sorted_ (by start\n    /// position and, if two start at the same position,\n    /// `value.startSide`). You can pass `true` as second argument to\n    /// cause the method to sort them.\n    static of(ranges, sort = false) {\n        let build = new RangeSetBuilder();\n        for (let range of ranges instanceof Range ? [ranges] : sort ? ranges.slice().sort(cmpRange) : ranges)\n            build.add(range.from, range.to, range.value);\n        return build.finish();\n    }\n}\n/// The empty set of ranges.\nRangeSet.empty = new RangeSet([], [], null, -1);\nRangeSet.empty.nextLayer = RangeSet.empty;\n/// A range set builder is a data structure that helps build up a\n/// [range set](#rangeset.RangeSet) directly, without first allocating\n/// an array of [`Range`](#rangeset.Range) objects.\nclass RangeSetBuilder {\n    constructor() {\n        this.chunks = [];\n        this.chunkPos = [];\n        this.chunkStart = -1;\n        this.last = null;\n        this.lastFrom = -Far;\n        this.lastTo = -Far;\n        this.from = [];\n        this.to = [];\n        this.value = [];\n        this.maxPoint = -1;\n        this.setMaxPoint = -1;\n        this.nextLayer = null;\n    }\n    finishChunk(newArrays) {\n        this.chunks.push(new Chunk(this.from, this.to, this.value, this.maxPoint));\n        this.chunkPos.push(this.chunkStart);\n        this.chunkStart = -1;\n        this.setMaxPoint = Math.max(this.setMaxPoint, this.maxPoint);\n        this.maxPoint = -1;\n        if (newArrays) {\n            this.from = [];\n            this.to = [];\n            this.value = [];\n        }\n    }\n    /// Add a range. Ranges should be added in sorted (by `from` and\n    /// `value.startSide`) order.\n    add(from, to, value) {\n        if (!this.addInner(from, to, value))\n            (this.nextLayer || (this.nextLayer = new RangeSetBuilder)).add(from, to, value);\n    }\n    /// @internal\n    addInner(from, to, value) {\n        let diff = from - this.lastTo || value.startSide - this.last.endSide;\n        if (diff <= 0 && (from - this.lastFrom || value.startSide - this.last.startSide) < 0)\n            throw new Error(\"Ranges must be added sorted by `from` position and `startSide`\");\n        if (diff < 0)\n            return false;\n        if (this.from.length == ChunkSize)\n            this.finishChunk(true);\n        if (this.chunkStart < 0)\n            this.chunkStart = from;\n        this.from.push(from - this.chunkStart);\n        this.to.push(to - this.chunkStart);\n        this.last = value;\n        this.lastFrom = from;\n        this.lastTo = to;\n        this.value.push(value);\n        if (value.point)\n            this.maxPoint = Math.max(this.maxPoint, to - from);\n        return true;\n    }\n    /// @internal\n    addChunk(from, chunk) {\n        if ((from - this.lastTo || chunk.value[0].startSide - this.last.endSide) < 0)\n            return false;\n        if (this.from.length)\n            this.finishChunk(true);\n        this.setMaxPoint = Math.max(this.setMaxPoint, chunk.maxPoint);\n        this.chunks.push(chunk);\n        this.chunkPos.push(from);\n        let last = chunk.value.length - 1;\n        this.last = chunk.value[last];\n        this.lastFrom = chunk.from[last] + from;\n        this.lastTo = chunk.to[last] + from;\n        return true;\n    }\n    /// Finish the range set. Returns the new set. The builder can't be\n    /// used anymore after this has been called.\n    finish() { return this.finishInner(RangeSet.empty); }\n    /// @internal\n    finishInner(next) {\n        if (this.from.length)\n            this.finishChunk(false);\n        if (this.chunks.length == 0)\n            return next;\n        let result = new RangeSet(this.chunkPos, this.chunks, this.nextLayer ? this.nextLayer.finishInner(next) : next, this.setMaxPoint);\n        this.from = null; // Make sure further `add` calls produce errors\n        return result;\n    }\n}\nfunction findSharedChunks(a, b) {\n    let inA = new Map();\n    for (let set of a)\n        for (let i = 0; i < set.chunk.length; i++)\n            if (set.chunk[i].maxPoint < BigPointSize)\n                inA.set(set.chunk[i], set.chunkPos[i]);\n    let shared = new Set();\n    for (let set of b)\n        for (let i = 0; i < set.chunk.length; i++)\n            if (inA.get(set.chunk[i]) == set.chunkPos[i])\n                shared.add(set.chunk[i]);\n    return shared;\n}\nclass LayerCursor {\n    constructor(layer, skip, minPoint) {\n        this.layer = layer;\n        this.skip = skip;\n        this.minPoint = minPoint;\n    }\n    get startSide() { return this.value ? this.value.startSide : 0; }\n    get endSide() { return this.value ? this.value.endSide : 0; }\n    goto(pos, side = -Far) {\n        this.chunkIndex = this.rangeIndex = 0;\n        this.gotoInner(pos, side, false);\n        return this;\n    }\n    gotoInner(pos, side, forward) {\n        while (this.chunkIndex < this.layer.chunk.length) {\n            let next = this.layer.chunk[this.chunkIndex];\n            if (!(this.skip && this.skip.has(next) ||\n                this.layer.chunkEnd(this.chunkIndex) < pos ||\n                next.maxPoint < this.minPoint))\n                break;\n            this.chunkIndex++;\n            forward = false;\n        }\n        let rangeIndex = this.chunkIndex == this.layer.chunk.length ? 0\n            : this.layer.chunk[this.chunkIndex].findIndex(pos - this.layer.chunkPos[this.chunkIndex], -1, side);\n        if (!forward || this.rangeIndex < rangeIndex)\n            this.rangeIndex = rangeIndex;\n        this.next();\n    }\n    forward(pos, side) {\n        if ((this.to - pos || this.endSide - side) < 0)\n            this.gotoInner(pos, side, true);\n    }\n    next() {\n        for (;;) {\n            if (this.chunkIndex == this.layer.chunk.length) {\n                this.from = this.to = Far;\n                this.value = null;\n                break;\n            }\n            else {\n                let chunkPos = this.layer.chunkPos[this.chunkIndex], chunk = this.layer.chunk[this.chunkIndex];\n                let from = chunkPos + chunk.from[this.rangeIndex];\n                this.from = from;\n                this.to = chunkPos + chunk.to[this.rangeIndex];\n                this.value = chunk.value[this.rangeIndex];\n                if (++this.rangeIndex == chunk.value.length) {\n                    this.chunkIndex++;\n                    if (this.skip) {\n                        while (this.chunkIndex < this.layer.chunk.length && this.skip.has(this.layer.chunk[this.chunkIndex]))\n                            this.chunkIndex++;\n                    }\n                    this.rangeIndex = 0;\n                }\n                if (this.minPoint < 0 || this.value.point && this.to - this.from >= this.minPoint)\n                    break;\n            }\n        }\n    }\n    nextChunk() {\n        this.chunkIndex++;\n        this.rangeIndex = 0;\n        this.next();\n    }\n    compare(other) {\n        return this.from - other.from || this.startSide - other.startSide || this.to - other.to || this.endSide - other.endSide;\n    }\n}\nclass HeapCursor {\n    constructor(heap) {\n        this.heap = heap;\n    }\n    static from(sets, skip = null, minPoint = -1) {\n        let heap = [];\n        for (let set of sets)\n            for (let cur = set; cur != RangeSet.empty; cur = cur.nextLayer) {\n                if (cur.maxPoint >= minPoint)\n                    heap.push(new LayerCursor(cur, skip, minPoint));\n            }\n        return heap.length == 1 ? heap[0] : new HeapCursor(heap);\n    }\n    get startSide() { return this.value ? this.value.startSide : 0; }\n    goto(pos, side = -Far) {\n        for (let cur of this.heap)\n            cur.goto(pos, side);\n        for (let i = this.heap.length >> 1; i >= 0; i--)\n            heapBubble(this.heap, i);\n        this.next();\n        return this;\n    }\n    forward(pos, side) {\n        for (let cur of this.heap)\n            cur.forward(pos, side);\n        for (let i = this.heap.length >> 1; i >= 0; i--)\n            heapBubble(this.heap, i);\n        if ((this.to - pos || this.value.endSide - side) < 0)\n            this.next();\n    }\n    next() {\n        if (this.heap.length == 0) {\n            this.from = this.to = Far;\n            this.value = null;\n        }\n        else {\n            let top = this.heap[0];\n            this.from = top.from;\n            this.to = top.to;\n            this.value = top.value;\n            if (top.value)\n                top.next();\n            heapBubble(this.heap, 0);\n        }\n    }\n}\nfunction heapBubble(heap, index) {\n    for (let cur = heap[index];;) {\n        let childIndex = (index << 1) + 1;\n        if (childIndex >= heap.length)\n            break;\n        let child = heap[childIndex];\n        if (childIndex + 1 < heap.length && child.compare(heap[childIndex + 1]) >= 0) {\n            child = heap[childIndex + 1];\n            childIndex++;\n        }\n        if (cur.compare(child) < 0)\n            break;\n        heap[childIndex] = cur;\n        heap[index] = child;\n        index = childIndex;\n    }\n}\nclass SpanCursor {\n    constructor(sets, skip, minPoint) {\n        this.minPoint = minPoint;\n        this.active = [];\n        this.activeTo = [];\n        this.minActive = -1;\n        // A currently active point range, if any\n        this.point = null;\n        this.pointFrom = 0;\n        this.to = -Far;\n        this.endSide = 0;\n        this.cursor = HeapCursor.from(sets, skip, minPoint);\n    }\n    goto(pos, side = -Far) {\n        this.cursor.goto(pos, side);\n        this.active.length = this.activeTo.length = 0;\n        this.minActive = -1;\n        this.to = pos;\n        this.endSide = side;\n        this.next();\n        return this;\n    }\n    forward(pos, side) {\n        while (this.minActive > -1 && (this.activeTo[this.minActive] - pos || this.active[this.minActive].endSide - side) < 0)\n            this.removeActive(this.minActive);\n        this.cursor.forward(pos, side);\n    }\n    removeActive(index) {\n        remove(this.active, index);\n        remove(this.activeTo, index);\n        this.minActive = findMinIndex(this.active, this.activeTo);\n    }\n    // After calling this, if `this.point` != null, the next range is a\n    // point. Otherwise, it's a regular range, covered by `this.active`.\n    next() {\n        let from = this.to;\n        this.point = null;\n        for (;;) {\n            let a = this.minActive;\n            if (a > -1 && (this.activeTo[a] - this.cursor.from || this.active[a].endSide - this.cursor.startSide) < 0) {\n                if (this.activeTo[a] > from) {\n                    this.to = this.activeTo[a];\n                    this.endSide = this.active[a].endSide;\n                    break;\n                }\n                this.removeActive(a);\n            }\n            else if (!this.cursor.value) {\n                this.to = this.endSide = Far;\n                break;\n            }\n            else if (this.cursor.from > from) {\n                this.to = this.cursor.from;\n                this.endSide = this.cursor.startSide;\n                break;\n            }\n            else {\n                let nextVal = this.cursor.value;\n                if (!nextVal.point) { // Opening a range\n                    this.active.push(nextVal);\n                    this.activeTo.push(this.cursor.to);\n                    this.minActive = findMinIndex(this.active, this.activeTo);\n                    this.cursor.next();\n                }\n                else { // New point\n                    this.point = nextVal;\n                    this.pointFrom = this.cursor.from;\n                    this.to = this.cursor.to;\n                    this.endSide = nextVal.endSide;\n                    this.cursor.next();\n                    if (this.to > from)\n                        this.forward(this.to, this.endSide);\n                    break;\n                }\n            }\n        }\n    }\n}\nfunction compare(a, startA, b, startB, length, comparator) {\n    a.goto(startA);\n    b.goto(startB);\n    let endB = startB + length;\n    let pos = startB, dPos = startB - startA;\n    for (;;) {\n        let diff = (a.to + dPos) - b.to || a.endSide - b.endSide;\n        let end = diff < 0 ? a.to + dPos : b.to, clipEnd = Math.min(end, endB);\n        if (a.point || b.point) {\n            if (!(a.point && b.point && (a.point == b.point || a.point.eq(b.point))))\n                comparator.comparePoint(pos, clipEnd, a.point, b.point);\n        }\n        else {\n            if (clipEnd > pos && !sameSet(a.active, b.active))\n                comparator.compareRange(pos, clipEnd, a.active, b.active);\n        }\n        if (end > endB)\n            break;\n        pos = end;\n        if (diff <= 0)\n            a.next();\n        if (diff >= 0)\n            b.next();\n    }\n}\nfunction sameSet(a, b) {\n    if (a.length != b.length)\n        return false;\n    outer: for (let i = 0; i < a.length; i++) {\n        for (let j = 0; j < b.length; j++)\n            if (a[i] == b[i] || a[i].eq(b[j]))\n                continue outer;\n        return false;\n    }\n    return true;\n}\nfunction remove(array, index) {\n    let last = array.pop();\n    if (index != array.length)\n        array[index] = last;\n}\nfunction findMinIndex(value, array) {\n    let found = -1, foundPos = Far;\n    for (let i = 0; i < array.length; i++)\n        if ((array[i] - foundPos || value[i].endSide - value[found].endSide) < 0) {\n            found = i;\n            foundPos = array[i];\n        }\n    return found;\n}\n\nexport { Range, RangeSet, RangeSetBuilder, RangeValue };\n","import { charType, Text } from '../../text';\nexport { Text } from '../../text';\nimport { NodeProp, Tree } from 'lezer-tree';\n\n/// A single selection range. When\n/// [`allowMultipleSelections`](#state.EditorState^allowMultipleSelections)\n/// is enabled, a [selection](#state.EditorSelection) may hold\n/// multiple ranges. By default, selections hold exactly one range.\nclass SelectionRange {\n    /// Create a range. `head` defaults to `anchor` when not given.\n    constructor(\n    /// The anchor of the rangethe side that doesn't move when you\n    /// extend it.\n    anchor, \n    /// The head of the range, which is moved when the range is\n    /// [extended](#state.SelectionRange.extend).\n    head = anchor) {\n        this.anchor = anchor;\n        this.head = head;\n    }\n    /// The lower side of the range.\n    get from() { return Math.min(this.anchor, this.head); }\n    /// The upper side of the range.\n    get to() { return Math.max(this.anchor, this.head); }\n    /// True when `anchor` and `head` are at the same position.\n    get empty() { return this.anchor == this.head; }\n    /// Map this range through a mapping.\n    map(mapping) {\n        let anchor = mapping.mapPos(this.anchor), head = mapping.mapPos(this.head);\n        if (anchor == this.anchor && head == this.head)\n            return this;\n        else\n            return new SelectionRange(anchor, head);\n    }\n    /// Extend this range to cover at least `from` to `to`.\n    extend(from, to = from) {\n        if (from <= this.anchor && to >= this.anchor)\n            return new SelectionRange(from, to);\n        let head = Math.abs(from - this.anchor) > Math.abs(to - this.anchor) ? from : to;\n        return new SelectionRange(this.anchor, head);\n    }\n    /// Compare this range to another range.\n    eq(other) {\n        return this.anchor == other.anchor && this.head == other.head;\n    }\n    /// Return a JSON-serializable object representing the range.\n    toJSON() { return this; }\n    /// Convert a JSON representation of a range to a `SelectionRange`\n    /// instance.\n    static fromJSON(json) {\n        if (!json || typeof json.anchor != \"number\" || typeof json.head != \"number\")\n            throw new RangeError(\"Invalid JSON representation for SelectionRange\");\n        return new SelectionRange(json.anchor, json.head);\n    }\n    /// @internal FIXME export?\n    static groupAt(state, pos, bias = 1) {\n        // FIXME at some point, take language-specific identifier characters into account\n        let line = state.doc.lineAt(pos), linePos = pos - line.start;\n        if (line.length == 0)\n            return new SelectionRange(pos);\n        if (linePos == 0)\n            bias = 1;\n        else if (linePos == line.length)\n            bias = -1;\n        let read = linePos + (bias < 0 ? -1 : 0), type = charType(line.slice(read, read + 1));\n        let from = pos, to = pos;\n        for (let lineFrom = linePos; lineFrom > 0 && charType(line.slice(lineFrom - 1, lineFrom)) == type; lineFrom--)\n            from--;\n        for (let lineTo = linePos; lineTo < line.length && charType(line.slice(lineTo, lineTo + 1)) == type; lineTo++)\n            to++;\n        return new SelectionRange(to, from);\n    }\n}\n/// An editor selection holds one or more selection ranges.\nclass EditorSelection {\n    /// @internal\n    constructor(\n    /// The ranges in the selection, sorted by position. Ranges cannot\n    /// overlap (but they may touch, if they aren't empty).\n    ranges, \n    /// The index of the _primary_ range in the selection (which is\n    /// usually the range that was added last).\n    primaryIndex = 0) {\n        this.ranges = ranges;\n        this.primaryIndex = primaryIndex;\n    }\n    /// Map a selection through a mapping. Mostly used to adjust the\n    /// selection position for changes.\n    map(mapping) {\n        return EditorSelection.create(this.ranges.map(r => r.map(mapping)), this.primaryIndex);\n    }\n    /// Compare this selection to another selection.\n    eq(other) {\n        if (this.ranges.length != other.ranges.length ||\n            this.primaryIndex != other.primaryIndex)\n            return false;\n        for (let i = 0; i < this.ranges.length; i++)\n            if (!this.ranges[i].eq(other.ranges[i]))\n                return false;\n        return true;\n    }\n    /// Get the primary selection range. Usually, you should make sure\n    /// your code applies to _all_ ranges, by using transaction methods\n    /// like [`forEachRange`](#state.transaction.forEachRange).\n    get primary() { return this.ranges[this.primaryIndex]; }\n    /// Make sure the selection only has one range. Returns a selection\n    /// holding only the primary range from this selection.\n    asSingle() {\n        return this.ranges.length == 1 ? this : new EditorSelection([this.primary]);\n    }\n    /// Extend this selection with an extra range.\n    addRange(range, primary = true) {\n        return EditorSelection.create([range].concat(this.ranges), primary ? 0 : this.primaryIndex + 1);\n    }\n    /// Replace a given range with another range, and then normalize the\n    /// selection to merge and sort ranges if necessary.\n    replaceRange(range, which = this.primaryIndex) {\n        let ranges = this.ranges.slice();\n        ranges[which] = range;\n        return EditorSelection.create(ranges, this.primaryIndex);\n    }\n    /// Convert this selection to an object that can be serialized to\n    /// JSON.\n    toJSON() {\n        return this.ranges.length == 1 ? this.ranges[0].toJSON() :\n            { ranges: this.ranges.map(r => r.toJSON()), primaryIndex: this.primaryIndex };\n    }\n    /// Create a selection from a JSON representation.\n    static fromJSON(json) {\n        if (json && Array.isArray(json.ranges)) {\n            if (typeof json.primaryIndex != \"number\" || json.primaryIndex >= json.ranges.length)\n                throw new RangeError(\"Invalid JSON representation for EditorSelection\");\n            return new EditorSelection(json.ranges.map((r) => SelectionRange.fromJSON(r)), json.primaryIndex);\n        }\n        return new EditorSelection([SelectionRange.fromJSON(json)]);\n    }\n    /// Create a selection holding a single range.\n    static single(anchor, head = anchor) {\n        return new EditorSelection([new SelectionRange(anchor, head)], 0);\n    }\n    /// Sort and merge the given set of ranges, creating a valid\n    /// selection.\n    static create(ranges, primaryIndex = 0) {\n        for (let pos = 0, i = 0; i < ranges.length; i++) {\n            let range = ranges[i];\n            if (range.empty ? range.from <= pos : range.from < pos)\n                return normalized(ranges.slice(), primaryIndex);\n            pos = range.to;\n        }\n        return new EditorSelection(ranges, primaryIndex);\n    }\n}\nfunction normalized(ranges, primaryIndex = 0) {\n    let primary = ranges[primaryIndex];\n    ranges.sort((a, b) => a.from - b.from);\n    primaryIndex = ranges.indexOf(primary);\n    for (let i = 1; i < ranges.length; i++) {\n        let range = ranges[i], prev = ranges[i - 1];\n        if (range.empty ? range.from <= prev.to : range.from < prev.to) {\n            let from = prev.from, to = Math.max(range.to, prev.to);\n            if (i <= primaryIndex)\n                primaryIndex--;\n            ranges.splice(--i, 2, range.anchor > range.head ? new SelectionRange(to, from) : new SelectionRange(from, to));\n        }\n    }\n    return new EditorSelection(ranges, primaryIndex);\n}\nfunction checkSelection(selection, doc) {\n    for (let range of selection.ranges)\n        if (range.to > doc.length)\n            throw new RangeError(\"Selection points outside of document\");\n}\n\nlet nextID = 0;\n/// A facet is a value that is assicated with a state and can be\n/// influenced by any number of extensions. Extensions can provide\n/// input values for the facet, and the facet combines those into an\n/// output value.\n///\n/// Examples of facets are the theme styles associated with an editor\n/// (which are all stored) or the tab size (which is reduced to a\n/// single value, using the input with the hightest precedence).\nclass Facet {\n    constructor(\n    /// @internal\n    combine, \n    /// @internal\n    compareInput, \n    /// @internal\n    compare, isStatic) {\n        this.combine = combine;\n        this.compareInput = compareInput;\n        this.compare = compare;\n        this.isStatic = isStatic;\n        /// @internal\n        this.id = nextID++;\n        this.default = combine([]);\n    }\n    /// Define a new facet.\n    static define(config = {}) {\n        return new Facet(config.combine || ((a) => a), config.compareInput || ((a, b) => a === b), config.compare || (!config.combine ? sameArray : (a, b) => a === b), !!config.static);\n    }\n    /// Returns an extension that adds the given value for this facet.\n    of(value) {\n        return new FacetProvider([], this, 0 /* Static */, value);\n    }\n    /// Create an extension that computes a value for the facet from a\n    /// state. You must take care to declare the parts of the state that\n    /// this value depends on, since your function is only called again\n    /// for a new state when one of those parts changed.\n    ///\n    /// In most cases, you'll want to use\n    /// [`StateField.provide`](#state.StateField^provide) instead.\n    compute(deps, get) {\n        if (this.isStatic)\n            throw new Error(\"Can't compute a static facet\");\n        return new FacetProvider(deps, this, 1 /* Single */, get);\n    }\n    /// Create an extension that computes zero or more values for this\n    /// facet from a state.\n    computeN(deps, get) {\n        if (this.isStatic)\n            throw new Error(\"Can't compute a static facet\");\n        return new FacetProvider(deps, this, 2 /* Multi */, get);\n    }\n}\nfunction sameArray(a, b) {\n    return a == b || a.length == b.length && a.every((e, i) => e === b[i]);\n}\nclass FacetProvider {\n    constructor(dependencies, facet, type, value) {\n        this.dependencies = dependencies;\n        this.facet = facet;\n        this.type = type;\n        this.value = value;\n        this.id = nextID++;\n    }\n    dynamicSlot(addresses) {\n        let getter = this.value;\n        let compare = this.facet.compareInput;\n        let idx = addresses[this.id] >> 1, multi = this.type == 2 /* Multi */;\n        let depDoc = false, depSel = false, depAddrs = [];\n        for (let dep of this.dependencies) {\n            if (dep == \"doc\")\n                depDoc = true;\n            else if (dep == \"selection\")\n                depSel = true;\n            else if ((addresses[dep.id] & 1) == 0)\n                depAddrs.push(addresses[dep.id]);\n        }\n        return (state, tr) => {\n            if (!tr || tr.reconfigured) {\n                state.values[idx] = getter(state);\n                return 1 /* Changed */;\n            }\n            else {\n                let depChanged = (depDoc && tr.docChanged) || (depSel && (tr.docChanged || tr.selectionSet)) ||\n                    depAddrs.some(addr => (ensureAddr(state, addr) & 1 /* Changed */) > 0);\n                if (!depChanged)\n                    return 0;\n                let newVal = getter(state), oldVal = tr.startState.values[idx];\n                if (multi ? compareArray(newVal, oldVal, compare) : compare(newVal, oldVal))\n                    return 0;\n                state.values[idx] = newVal;\n                return 1 /* Changed */;\n            }\n        };\n    }\n}\nfunction compareArray(a, b, compare) {\n    if (a.length != b.length)\n        return false;\n    for (let i = 0; i < a.length; i++)\n        if (!compare(a[i], b[i]))\n            return false;\n    return true;\n}\nfunction dynamicFacetSlot(addresses, facet, providers) {\n    let providerAddrs = providers.map(p => addresses[p.id]);\n    let providerTypes = providers.map(p => p.type);\n    let dynamic = providerAddrs.filter(p => !(p & 1));\n    let idx = addresses[facet.id] >> 1;\n    return (state, tr) => {\n        let oldAddr = !tr ? null : tr.reconfigured ? tr.startState.config.address[facet.id] : idx << 1;\n        let changed = oldAddr == null;\n        for (let dynAddr of dynamic) {\n            if (ensureAddr(state, dynAddr) & 1 /* Changed */)\n                changed = true;\n        }\n        if (!changed)\n            return 0;\n        let values = [];\n        for (let i = 0; i < providerAddrs.length; i++) {\n            let value = getAddr(state, providerAddrs[i]);\n            if (providerTypes[i] == 2 /* Multi */)\n                for (let val of value)\n                    values.push(val);\n            else\n                values.push(value);\n        }\n        let newVal = facet.combine(values);\n        if (oldAddr != null && facet.compare(newVal, getAddr(tr.startState, oldAddr)))\n            return 0;\n        state.values[idx] = newVal;\n        return 1 /* Changed */;\n    };\n}\n/// Fields can store additional information in an editor state, and\n/// keep it in sync with the rest of the state.\nclass StateField {\n    constructor(\n    /// @internal\n    id, createF, updateF, compareF, \n    /// @internal\n    facets) {\n        this.id = id;\n        this.createF = createF;\n        this.updateF = updateF;\n        this.compareF = compareF;\n        this.facets = facets;\n    }\n    /// Define a state field.\n    static define(config) {\n        return new StateField(nextID++, config.create, config.update, config.compare || ((a, b) => a === b), []);\n    }\n    provide(facet, get, prec) {\n        let provider = facet.compute([this], get ? state => get(state.field(this)) : state => state.field(this));\n        return new StateField(this.id, this.createF, this.updateF, this.compareF, this.facets.concat(maybePrec(prec, provider)));\n    }\n    /// Extends the field to provide zero or more input values for the\n    /// given facet.\n    provideN(facet, get, prec) {\n        let provider = facet.computeN([this], state => get(state.field(this)));\n        return new StateField(this.id, this.createF, this.updateF, this.compareF, this.facets.concat(maybePrec(prec, provider)));\n    }\n    /// @internal\n    slot(addresses) {\n        let idx = addresses[this.id] >> 1;\n        return (state, tr) => {\n            let oldIdx = !tr ? null : tr.reconfigured ? tr.startState.config.address[this.id] >> 1 : idx;\n            if (oldIdx == null) {\n                state.values[idx] = this.createF(state);\n                return 1 /* Changed */;\n            }\n            else {\n                let oldVal = tr.startState.values[oldIdx], value = this.updateF(oldVal, tr, state);\n                if (this.compareF(oldVal, value))\n                    return 0;\n                state.values[idx] = value;\n                return 1 /* Changed */;\n            }\n        };\n    }\n}\n/// By default extensions are registered in the order they are\n/// provided in a flattening of the nested arrays that were provided.\n/// Individual extension values can be assigned a precedence to\n/// override this. Extensions that do not have a precedence set get\n/// the precedence of the nearest parent with a precedence, or\n/// [`Default`](#state.Precedence.Default) if there is no such parent.\n/// The final ordering of extensions is determined by first sorting by\n/// precedence and then by order within each precedence.\nclass Precedence {\n    constructor(\n    /// @internal\n    val) {\n        this.val = val;\n    }\n    /// Tag an extension with this precedence.\n    set(extension) {\n        return new PrecExtension(extension, this.val);\n    }\n}\n/// A precedence below the default precedence, which will cause\n/// default-precedence extensions to override it even if they are\n/// specified later in the extension ordering.\nPrecedence.Fallback = new Precedence(3);\n/// The regular default precedence.\nPrecedence.Default = new Precedence(2);\n/// A higher-than-default precedence.\nPrecedence.Extend = new Precedence(1);\n/// Precedence above the `Default` and `Extend` precedences.\nPrecedence.Override = new Precedence(0);\nfunction maybePrec(prec, ext) {\n    return prec == null ? ext : prec.set(ext);\n}\nclass PrecExtension {\n    constructor(e, prec) {\n        this.e = e;\n        this.prec = prec;\n    }\n}\nclass GroupExtension {\n    constructor(extension, group) {\n        this.extension = extension;\n        this.group = group;\n    }\n}\n/// Extension groups can be used to make a configuration dynamic.\n/// [Wrapping](#state.ExtensionGroup.of) an extension in a group\n/// allows you to later replace it with\n/// [`Transaction.replaceExtension`](#state.Transaction.replaceExtension).\n/// A given group may only occur once within a given configuration.\nclass ExtensionGroup {\n    /// Define a new group. The name is used only for debugging\n    /// purposes.\n    constructor(name) {\n        this.name = name;\n    }\n    /// Tag the given extension with this group.\n    of(extension) { return new GroupExtension(extension, this); }\n}\nclass Configuration {\n    constructor(source, replacements, dynamicSlots, address, staticValues) {\n        this.source = source;\n        this.replacements = replacements;\n        this.dynamicSlots = dynamicSlots;\n        this.address = address;\n        this.staticValues = staticValues;\n        this.statusTemplate = [];\n        while (this.statusTemplate.length < staticValues.length)\n            this.statusTemplate.push(0 /* Uninitialized */);\n    }\n    staticFacet(facet) {\n        let addr = this.address[facet.id];\n        return addr == null ? facet.default : this.staticValues[addr >> 1];\n    }\n    static resolve(extension, replacements = new Map, oldState) {\n        let fields = [];\n        let facets = Object.create(null);\n        for (let ext of flatten(extension, replacements)) {\n            if (ext instanceof StateField)\n                fields.push(ext);\n            else\n                (facets[ext.facet.id] || (facets[ext.facet.id] = [])).push(ext);\n        }\n        let address = Object.create(null);\n        let staticValues = [];\n        let dynamicSlots = [];\n        for (let field of fields) {\n            address[field.id] = dynamicSlots.length << 1;\n            dynamicSlots.push(a => field.slot(a));\n        }\n        for (let id in facets) {\n            let providers = facets[id], facet = providers[0].facet;\n            if (providers.every(p => p.type == 0 /* Static */)) {\n                address[facet.id] = (staticValues.length << 1) | 1;\n                let value = facet.combine(providers.map(p => p.value));\n                let oldAddr = oldState ? oldState.config.address[facet.id] : null;\n                if (oldAddr != null) {\n                    let oldVal = getAddr(oldState, oldAddr);\n                    if (facet.compare(value, oldVal))\n                        value = oldVal;\n                }\n                staticValues.push(value);\n            }\n            else {\n                for (let p of providers) {\n                    if (p.type == 0 /* Static */) {\n                        address[p.id] = (staticValues.length << 1) | 1;\n                        staticValues.push(p.value);\n                    }\n                    else {\n                        address[p.id] = dynamicSlots.length << 1;\n                        dynamicSlots.push(a => p.dynamicSlot(a));\n                    }\n                }\n                address[facet.id] = dynamicSlots.length << 1;\n                dynamicSlots.push(a => dynamicFacetSlot(a, facet, providers));\n            }\n        }\n        return new Configuration(extension, replacements, dynamicSlots.map(f => f(address)), address, staticValues);\n    }\n}\nfunction flatten(extension, replacements) {\n    let result = [[], [], [], []];\n    let seen = new Set();\n    let groupsSeen = new Set();\n    (function inner(ext, prec) {\n        if (seen.has(ext))\n            return;\n        seen.add(ext);\n        if (Array.isArray(ext)) {\n            for (let e of ext)\n                inner(e, prec);\n        }\n        else if (ext instanceof GroupExtension) {\n            if (groupsSeen.has(ext.group))\n                throw new RangeError(`Duplicate use of group '${ext.group.name}' in extensions`);\n            groupsSeen.add(ext.group);\n            inner(replacements.get(ext.group) || ext.extension, prec);\n        }\n        else if (ext.extension) {\n            inner(ext.extension, prec);\n        }\n        else if (ext instanceof PrecExtension) {\n            inner(ext.e, ext.prec);\n        }\n        else {\n            result[prec].push(ext);\n            if (ext instanceof StateField)\n                inner(ext.facets, prec);\n        }\n    })(extension, Precedence.Default.val);\n    return result.reduce((a, b) => a.concat(b));\n}\nfunction ensureAddr(state, addr) {\n    if (addr & 1)\n        return 2 /* Computed */;\n    let idx = addr >> 1;\n    let status = state.status[idx];\n    if (status == 4 /* Computing */)\n        throw new Error(\"Cyclic dependency between fields and/or facets\");\n    if (status & 2 /* Computed */)\n        return status;\n    state.status[idx] = 4 /* Computing */;\n    let changed = state.config.dynamicSlots[idx](state, state.applying);\n    return state.status[idx] = 2 /* Computed */ | changed;\n}\nfunction getAddr(state, addr) {\n    return addr & 1 ? state.config.staticValues[addr >> 1] : state.values[addr >> 1];\n}\n\nconst allowMultipleSelections = Facet.define({\n    combine: values => values.some(v => v),\n    static: true\n});\nlet annotationID = 0;\n/// Annotations are tagged values that are used to add metadata to\n/// transactions in an extensible way.\nclass Annotation {\n    constructor() {\n        /// @internal\n        this.id = annotationID++;\n    }\n    /// Define a new type of annotation.\n    static define() { return new Annotation(); }\n}\n/// A node prop that can be stored on a grammar's top node to\n/// associate information with the language. Different extension might\n/// use different properties from this object (which they typically\n/// export as an interface).\nconst languageData = new NodeProp();\n// FIXME add a view plugin that schedules background parsing\n// FIXME add a way to be notified when the document is fully parsed\n\nconst empty = [];\n/// Distinguishes different ways in which positions can be mapped.\nvar MapMode;\n(function (MapMode) {\n    /// Map a position to a valid new position, even when its context\n    /// was deleted.\n    MapMode[MapMode[\"Simple\"] = 0] = \"Simple\";\n    /// Return a negative number if a deletion happens across the\n    /// position. This number will be `-(newPos + 1)`, where `newPos` is\n    /// the result you'd get with `MapMode.Simple`.\n    MapMode[MapMode[\"TrackDel\"] = 1] = \"TrackDel\";\n    /// Return a negative number if the character _before_ the position\n    /// is deleted. The result is encoded the same way as with\n    /// `MapMode.TrackDel`.\n    MapMode[MapMode[\"TrackBefore\"] = 2] = \"TrackBefore\";\n    /// Return a negative number if the character _after_ the position is\n    /// deleted.\n    MapMode[MapMode[\"TrackAfter\"] = 3] = \"TrackAfter\";\n})(MapMode || (MapMode = {}));\n/// A change description describes a document change. This is usually\n/// used as a superclass of [`Change`](#state.Change), but can be used\n/// to store change data without storing the replacement string\n/// content.\nclass ChangeDesc {\n    /// Create a description that replaces the text between positions\n    /// `from` and `to` with a new string of length `length`.\n    constructor(\n    /// The start position of the change.\n    from, \n    /// The end of the change (as a pre-change document position).\n    to, \n    /// The length of the replacing content.\n    length) {\n        this.from = from;\n        this.to = to;\n        this.length = length;\n    }\n    /// Get the change description of the inverse of this change.\n    get invertedDesc() { return new ChangeDesc(this.from, this.from + this.length, this.to - this.from); }\n    /// @internal\n    mapPos(pos, bias = -1, mode = MapMode.Simple) {\n        let { from, to, length } = this;\n        if (pos < from)\n            return pos;\n        if (pos > to)\n            return pos + (length - (to - from));\n        if (pos == to || pos == from) {\n            if (from < pos && mode == MapMode.TrackBefore || to > pos && mode == MapMode.TrackAfter)\n                return -pos - 1;\n            return (from == to ? bias <= 0 : pos == from) ? from : from + length;\n        }\n        pos = from + (bias <= 0 ? 0 : length);\n        return mode != MapMode.Simple ? -pos - 1 : pos;\n    }\n    /// Return a JSON-serializeable object representing this value.\n    toJSON() { return this; }\n    /// Create a change description from its JSON representation.\n    static fromJSON(json) {\n        if (!json || typeof json.from != \"number\" || typeof json.to != \"number\" || typeof json.length != \"number\")\n            throw new RangeError(\"Invalid JSON representation for ChangeDesc\");\n        return new ChangeDesc(json.from, json.to, json.length);\n    }\n}\n/// Change objects describe changes to the document.\nclass Change extends ChangeDesc {\n    /// Create a change that replaces `from` to `to` with `text`. The\n    /// text is given as an array of lines. When it doesn't span lines,\n    /// the array has a single element. When it does, a new element is\n    /// added for every line. It should never have zero elements.\n    constructor(from, to, \n    /// The replacement content.\n    text) {\n        super(from, to, textLength(text));\n        this.from = from;\n        this.to = to;\n        this.text = text;\n    }\n    /// Create the inverse of this change when applied to the given\n    /// document. `change.invert(doc).apply(change.apply(doc))` gets you\n    /// the same document as the original `doc`.\n    invert(doc) {\n        return new Change(this.from, this.from + this.length, doc.sliceLines(this.from, this.to));\n    }\n    /// Apply this change to the given content, returning an updated\n    /// version of the document.\n    apply(doc) {\n        return doc.replace(this.from, this.to, this.text);\n    }\n    /// Map this change through a mapping, producing a new change that\n    /// can be applied to a post-mapping document. May return null if\n    /// the mapping completely replaces the region this change would\n    /// apply to.\n    map(mapping) {\n        let from = mapping.mapPos(this.from, 1), to = mapping.mapPos(this.to, -1);\n        return from > to ? null : new Change(from, to, this.text);\n    }\n    /// A change description for this change.\n    get desc() { return new ChangeDesc(this.from, this.to, this.length); }\n    /// Produce a JSON-serializable object representing this change.\n    toJSON() {\n        return { from: this.from, to: this.to, text: this.text };\n    }\n    /// Read a change instance from its JSON representation.\n    static fromJSON(json) {\n        if (!json || typeof json.from != \"number\" || typeof json.to != \"number\" ||\n            !Array.isArray(json.text) || json.text.length == 0 || json.text.some((val) => typeof val != \"string\"))\n            throw new RangeError(\"Invalid JSON representation for Change\");\n        return new Change(json.from, json.to, json.text);\n    }\n}\nfunction textLength(text) {\n    let length = -1;\n    for (let line of text)\n        length += line.length + 1;\n    return length;\n}\n/// A change set holds a sequence of changes or change descriptions.\nclass ChangeSet {\n    /// @internal\n    constructor(\n    /// The changes in this set.\n    changes, \n    /// @internal\n    mirror = empty) {\n        this.changes = changes;\n        this.mirror = mirror;\n        this._changedRanges = null;\n    }\n    /// The number of changes in the set.\n    get length() {\n        return this.changes.length;\n    }\n    /// Change sets can track which changes are inverses of each other,\n    /// to allow robust position mapping in situations where changes are\n    /// undone and then redone again. This queries which change is the\n    /// mirror image of a given change (by index).\n    getMirror(n) {\n        for (let i = 0; i < this.mirror.length; i++)\n            if (this.mirror[i] == n)\n                return this.mirror[i + (i % 2 ? -1 : 1)];\n        return null;\n    }\n    /// Append a change to this set, returning an extended set. `mirror`\n    /// may be the index of a change already in the set, which\n    /// [mirrors](#state.ChangeSet.getMirror) the new change.\n    append(change, mirror) {\n        return new ChangeSet(this.changes.concat(change), mirror != null ? this.mirror.concat(this.length, mirror) : this.mirror);\n    }\n    /// Append another change set to this one.\n    appendSet(changes) {\n        return changes.length == 0 ? this :\n            this.length == 0 ? changes :\n                new ChangeSet(this.changes.concat(changes.changes), this.mirror.concat(changes.mirror.map(i => i + this.length)));\n    }\n    /// @internal\n    mapPos(pos, bias = -1, mode = MapMode.Simple) {\n        return this.mapInner(pos, bias, mode, 0, this.length);\n    }\n    /// @internal\n    mapInner(pos, bias, mode, fromI, toI) {\n        let dir = toI < fromI ? -1 : 1;\n        let recoverables = null;\n        let hasMirrors = this.mirror.length > 0, rec, mirror, deleted = false;\n        for (let i = fromI - (dir < 0 ? 1 : 0), endI = toI - (dir < 0 ? 1 : 0); i != endI; i += dir) {\n            let { from, to, length } = this.changes[i];\n            if (dir < 0) {\n                let len = to - from;\n                to = from + length;\n                length = len;\n            }\n            if (pos < from)\n                continue;\n            if (pos > to) {\n                pos += length - (to - from);\n                continue;\n            }\n            // Change touches this position\n            if (recoverables && (rec = recoverables[i]) != null) { // There's a recovery for this change, and it applies\n                pos = from + rec;\n                continue;\n            }\n            if (hasMirrors && (mirror = this.getMirror(i)) != null &&\n                (dir > 0 ? mirror > i && mirror < toI : mirror < i && mirror >= toI)) { // A mirror exists\n                if (pos > from && pos < to) { // If this change deletes the position, skip forward to the mirror\n                    i = mirror;\n                    pos = this.changes[i].from + (pos - from);\n                    continue;\n                }\n                (recoverables || (recoverables = {}))[mirror] = pos - from;\n            }\n            if (pos > from && pos < to) {\n                if (mode != MapMode.Simple)\n                    deleted = true;\n                pos = bias <= 0 ? from : from + length;\n            }\n            else {\n                if (from < pos && mode == MapMode.TrackBefore || to > pos && mode == MapMode.TrackAfter)\n                    deleted = true;\n                pos = (from == to ? bias <= 0 : pos == from) ? from : from + length;\n            }\n        }\n        return deleted ? -pos - 1 : pos;\n    }\n    /// Check whether these changes touch a given range. When one of the\n    /// changes entirely covers the range, the string `\"cover\"` is\n    /// returned.\n    touchesRange(from, to) {\n        let result = false;\n        for (let change of this.changes) {\n            if (change.to >= from && change.from <= to) {\n                if (change.from < from && change.to > to)\n                    return \"cover\";\n                result = true;\n            }\n            let diff = change.length - (change.to - change.from);\n            if (from > change.from)\n                from += diff;\n            if (to > change.to)\n                to += diff;\n        }\n        return result;\n    }\n    /// Get a partial [mapping](#state.Mapping) covering part of this\n    /// change set.\n    partialMapping(from, to = this.length) {\n        if (from == 0 && to == this.length)\n            return this;\n        return new PartialMapping(this, from, to);\n    }\n    /// Summarize this set of changes as a minimal sequence of changed\n    /// ranges, sored by position. For example, if you have changes\n    /// deleting between 1 and 4 and inserting a character at 1, the\n    /// result would be a single range saying 1 to 4 in the old doc was\n    /// replaced with range 1 to 2 in the new doc.\n    changedRanges() {\n        if (this._changedRanges)\n            return this._changedRanges;\n        let set = [];\n        for (let i = 0; i < this.length; i++) {\n            let change = this.changes[i];\n            let fromA = change.from, toA = change.to, fromB = change.from, toB = change.from + change.length;\n            if (i < this.length - 1) {\n                let mapping = this.partialMapping(i + 1);\n                fromB = mapping.mapPos(fromB, 1);\n                toB = mapping.mapPos(toB, -1);\n            }\n            if (i > 0) {\n                let mapping = this.partialMapping(i, 0);\n                fromA = mapping.mapPos(fromA, 1);\n                toA = mapping.mapPos(toA, -1);\n            }\n            new ChangedRange(fromA, toA, fromB, toB).addToSet(set);\n        }\n        return this._changedRanges = set;\n    }\n    /// Convert a set of changes to a set of change descriptions.\n    get desc() {\n        if (this.changes.length == 0 || this.changes[0] instanceof ChangeDesc)\n            return this;\n        return new ChangeSet(this.changes.map(ch => ch.desc), this.mirror);\n    }\n    /// Create a JSON-serializable representation of this change set.\n    toJSON() {\n        let changes = this.changes.map(change => change.toJSON());\n        return this.mirror.length == 0 ? changes : { mirror: this.mirror, changes };\n    }\n    /// Read a change set from its JSON representation.\n    static fromJSON(ChangeType, json) {\n        let mirror, changes;\n        if (Array.isArray(json)) {\n            mirror = empty;\n            changes = json;\n        }\n        else if (!json || !Array.isArray(json.mirror) || !Array.isArray(json.changes)) {\n            throw new RangeError(\"Invalid JSON representation for ChangeSet\");\n        }\n        else {\n            ({ mirror, changes } = json);\n        }\n        return new ChangeSet(changes.map((ch) => ChangeType.fromJSON(ch)), mirror);\n    }\n}\n/// The empty change set.\nChangeSet.empty = new ChangeSet(empty);\nclass PartialMapping {\n    constructor(changes, from, to) {\n        this.changes = changes;\n        this.from = from;\n        this.to = to;\n    }\n    mapPos(pos, bias = -1, mode = MapMode.Simple) {\n        return this.changes.mapInner(pos, bias, mode, this.from, this.to);\n    }\n}\n/// A changed range represents a replacement as two absolute ranges,\n/// one pointing into the old document (the replaced content) and one\n/// pointing into the new document (the content that replaces it).\nclass ChangedRange {\n    // FIXME store unchanged ranges instead?\n    constructor(\n    /// The start of the replaced range in the old document.\n    fromA, \n    /// The end of the replaced range in the old document.\n    toA, \n    /// The start of the replacing range in the new document.\n    fromB, \n    /// The end of the replacing range in the new document.\n    toB) {\n        this.fromA = fromA;\n        this.toA = toA;\n        this.fromB = fromB;\n        this.toB = toB;\n    }\n    /// @internal\n    join(other) {\n        return new ChangedRange(Math.min(this.fromA, other.fromA), Math.max(this.toA, other.toA), Math.min(this.fromB, other.fromB), Math.max(this.toB, other.toB));\n    }\n    /// @internal\n    // FIXME used by view. Document?\n    addToSet(set) {\n        let i = set.length, me = this;\n        for (; i > 0; i--) {\n            let range = set[i - 1];\n            if (range.fromA > me.toA)\n                continue;\n            if (range.toA < me.fromA)\n                break;\n            me = me.join(range);\n            set.splice(i - 1, 1);\n        }\n        set.splice(i, 0, me);\n        return set;\n    }\n    /// The difference in document length created by this change\n    /// (positive when the document grew).\n    get lenDiff() { return (this.toB - this.fromB) - (this.toA - this.fromA); }\n    /// @internal\n    static mapPos(pos, bias, changes) {\n        let off = 0;\n        for (let range of changes) {\n            if (pos < range.fromA)\n                break;\n            if (pos <= range.toA) {\n                let side = range.toA == range.fromA ? bias : pos == range.fromA ? -1 : pos == range.toA ? 1 : bias;\n                return side < 0 ? range.fromB : range.toB;\n            }\n            off = range.toB - range.toA;\n        }\n        return pos + off;\n    }\n}\n\n/// Changes to the editor state are grouped into transactions.\n/// Usually, a user action creates a single transaction, which may\n/// contain zero or more document changes. Create a transaction by\n/// calling [`EditorState.t`](#state.EditorState.t).\n///\n/// Transactions are mutable, and usually built up piece by piece with\n/// updating methods and method chaining (most methods return the\n/// transaction itself). Once they are\n/// [applied](#state.Transaction.apply), they can't be updated\n/// anymore.\nclass Transaction {\n    /// @internal\n    constructor(\n    /// The state from which the transaction starts.\n    startState, time = Date.now()) {\n        this.startState = startState;\n        /// The document changes made by this transaction.\n        this.changes = ChangeSet.empty;\n        /// The document versions after each of the changes.\n        this.docs = [];\n        this._annotations = Object.create(null);\n        this.flags = 0;\n        /// @internal\n        this.reconfigureData = null;\n        this.state = null;\n        this.selection = startState.selection;\n        this._annotations[Transaction.time.id] = time;\n    }\n    /// The document at the end of the transaction.\n    get doc() {\n        let last = this.docs.length - 1;\n        return last < 0 ? this.startState.doc : this.docs[last];\n    }\n    /// Add annotations to this transaction. Annotations can provide\n    /// additional information about the transaction.\n    annotate(annotation, value) {\n        this.ensureOpen();\n        this._annotations[annotation.id] = value;\n        return this;\n    }\n    /// Get the value of the given annotation type, if any.\n    annotation(annotation) {\n        return this._annotations[annotation.id];\n    }\n    /// Add a change to this transaction. If `mirror` is given, it\n    /// should be the index (in `this.changes.changes`) at which the\n    /// mirror image of this change sits.\n    change(change, mirror) {\n        this.ensureOpen();\n        if (change.from == change.to && change.length == 0)\n            return this;\n        if (change.from < 0 || change.to < change.from || change.to > this.doc.length)\n            throw new RangeError(`Invalid change ${change.from} to ${change.to}`);\n        this.changes = this.changes.append(change, mirror);\n        this.docs.push(change.apply(this.doc));\n        this.selection = this.selection.map(change);\n        return this;\n    }\n    /// Indicates whether the transaction changed the document.\n    get docChanged() {\n        return this.changes.length > 0;\n    }\n    /// Add a change replacing the given document range with the given\n    /// content.\n    replace(from, to, text) {\n        return this.change(new Change(from, to, typeof text == \"string\" ? this.startState.splitLines(text) : text));\n    }\n    /// Replace all selection ranges with the given content.\n    replaceSelection(text) {\n        let content = typeof text == \"string\" ? this.startState.splitLines(text) : text;\n        return this.forEachRange(range => {\n            let change = new Change(range.from, range.to, content);\n            this.change(change);\n            return new SelectionRange(range.from + change.length);\n        });\n    }\n    /// Run the given function for each selection range. The method will\n    /// map the ranges to reflect deletions/insertions that happen\n    /// before them. At the end, set the new selection to the ranges\n    /// returned by the function (again, automatically mapped to for\n    /// changes that happened after them).\n    forEachRange(f) {\n        let sel = this.selection, start = this.changes.length, newRanges = [];\n        for (let range of sel.ranges) {\n            let before = this.changes.length;\n            let result = f(range.map(this.changes.partialMapping(start)), this);\n            if (this.changes.length > before) {\n                let mapping = this.changes.partialMapping(before);\n                for (let i = 0; i < newRanges.length; i++)\n                    newRanges[i] = newRanges[i].map(mapping);\n            }\n            newRanges.push(result);\n        }\n        return this.setSelection(EditorSelection.create(newRanges, sel.primaryIndex));\n    }\n    /// Update the selection.\n    setSelection(selection) {\n        this.ensureOpen();\n        if (!this.startState.facet(allowMultipleSelections))\n            selection = selection.asSingle();\n        checkSelection(selection, this.doc);\n        this.selection = selection;\n        this.flags |= 1 /* SelectionSet */;\n        return this;\n    }\n    /// Tells you whether this transaction explicitly sets a new\n    /// selection (as opposed to just mapping the selection through\n    /// changes).\n    get selectionSet() {\n        return (this.flags & 1 /* SelectionSet */) > 0;\n    }\n    /// Set a flag on this transaction that indicates that the editor\n    /// should scroll the selection into view after applying it.\n    scrollIntoView() {\n        this.ensureOpen();\n        this.flags |= 2 /* ScrollIntoView */;\n        return this;\n    }\n    /// Query whether the selection should be scrolled into view after\n    /// applying this transaction.\n    get scrolledIntoView() {\n        return (this.flags & 2 /* ScrollIntoView */) > 0;\n    }\n    /// Provice new content for a given [extension\n    /// group](#state.ExtensionGroup) in the current configuration. (If\n    /// the group isn't present in the configuration, this will not have\n    /// any effect.)\n    replaceExtension(group, content) {\n        this.ensureOpen();\n        if (!this.reconfigureData) {\n            let replaced = new Map();\n            this.startState.config.replacements.forEach((ext, group) => replaced.set(group, ext));\n            this.reconfigureData = { base: this.startState.config.source, replaced };\n        }\n        this.reconfigureData.replaced.set(group, content);\n        return this;\n    }\n    /// Move to an entirely new state configuration.\n    reconfigure(extension) {\n        this.ensureOpen();\n        this.reconfigureData = { base: extension, replaced: new Map };\n        return this;\n    }\n    /// Indicates whether the transaction reconfigures the state.\n    get reconfigured() {\n        return this.reconfigureData != null;\n    }\n    ensureOpen() {\n        if (this.state)\n            throw new Error(\"Transactions may not be modified after being applied\");\n    }\n    /// Apply this transaction, computing a new editor state. May be\n    /// called multiple times (the result is cached). The transaction\n    /// cannot be further modified after this has been called.\n    apply() {\n        return this.state || (this.state = this.startState.applyTransaction(this));\n    }\n    /// Create a set of changes that undo the changes made by this\n    /// transaction.\n    invertedChanges() {\n        if (!this.changes.length)\n            return ChangeSet.empty;\n        let changes = [], set = this.changes;\n        for (let i = set.length - 1; i >= 0; i--)\n            changes.push(set.changes[i].invert(i == 0 ? this.startState.doc : this.docs[i - 1]));\n        return new ChangeSet(changes, set.mirror.length ? set.mirror.map(i => set.length - i - 1) : set.mirror);\n    }\n}\n/// Annotation used to store transaction timestamps.\nTransaction.time = Annotation.define();\n/// Annotation used to indicate that this transaction shouldn't\n/// clear the goal column, which is used during vertical cursor\n/// motion (so that moving over short lines doesn't reset the\n/// horizontal position to the end of the shortest line). Should\n/// generally only be set by commands that perform vertical motion.\nTransaction.preserveGoalColumn = Annotation.define();\n/// Annotation used to associate a transaction with a user interface\n/// event. The view will set this to...\n///\n///  - `\"paste\"` when pasting content\n///  - `\"cut\"` when cutting\n///  - `\"drop\"` when content is inserted via drag-and-drop\n///  - `\"keyboard\"` when moving the selection via the keyboard\n///  - `\"pointer\"` when moving the selection through the pointing device\nTransaction.userEvent = Annotation.define();\n/// Annotation indicating whether a transaction should be added to\n/// the undo history or not.\nTransaction.addToHistory = Annotation.define();\n\nconst DefaultIndentUnit = 2, DefaultTabsize = 4, DefaultSplit = /\\r\\n?|\\n/;\n/// The editor state class is a persistent (immutable) data structure.\n/// To update a state, you [create](#state.EditorState.t) and\n/// [apply](#state.Transaction.apply) a\n/// [transaction](#state.Transaction), which produces a _new_ state\n/// instance, without modifying the original object.\n///\n/// As such, _never_ mutate properties of a state directly. That'll\n/// just break things.\nclass EditorState {\n    /// @internal\n    constructor(\n    /// @internal\n    config, \n    /// The current document.\n    doc, \n    /// The current selection.\n    selection, tr = null) {\n        this.config = config;\n        this.doc = doc;\n        this.selection = selection;\n        /// @internal\n        this.applying = null;\n        this.status = config.statusTemplate.slice();\n        if (tr && !tr.reconfigured) {\n            this.values = tr.startState.values.slice();\n        }\n        else {\n            this.values = config.dynamicSlots.map(_ => null);\n            // Copy over old values for shared facets/fields if this is a reconfigure\n            if (tr)\n                for (let id in config.address) {\n                    let cur = config.address[id], prev = tr.startState.config.address[id];\n                    if (prev != null && (cur & 1) == 0)\n                        this.values[cur >> 1] = getAddr(tr.startState, prev);\n                }\n        }\n        this.applying = tr;\n        for (let i = 0; i < this.config.dynamicSlots.length; i++)\n            ensureAddr(this, i << 1);\n        this.applying = null;\n    }\n    field(field, require = true) {\n        let addr = this.config.address[field.id];\n        if (addr == null) {\n            if (require)\n                throw new RangeError(\"Field is not present in this state\");\n            return undefined;\n        }\n        ensureAddr(this, addr);\n        return getAddr(this, addr);\n    }\n    /// Start a new transaction from this state. When not given, the\n    /// timestamp defaults to\n    /// [`Date.now()`](https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/now).\n    t(timestamp) {\n        return new Transaction(this, timestamp);\n    }\n    /// Join an array of lines using the state's [line\n    /// separator](#state.EditorState^lineSeparator).\n    joinLines(text) { return text.join(this.facet(EditorState.lineSeparator) || \"\\n\"); }\n    /// Split a string into lines using the state's [line\n    /// separator](#state.EditorState^lineSeparator).\n    splitLines(text) { return text.split(this.facet(EditorState.lineSeparator) || DefaultSplit); }\n    /// Get the value of a state [behavior](#extension.Behavior).\n    facet(facet) {\n        let addr = this.config.address[facet.id];\n        if (addr == null)\n            return facet.default;\n        ensureAddr(this, addr);\n        return getAddr(this, addr);\n    }\n    /// Convert this state to a JSON-serializable object.\n    toJSON() {\n        // FIXME plugin state serialization\n        return {\n            doc: this.joinLines(this.doc.sliceLines(0, this.doc.length)),\n            selection: this.selection.toJSON()\n        };\n    }\n    /// Deserialize a state from its JSON representation.\n    static fromJSON(json, config = {}) {\n        if (!json || typeof json.doc != \"string\")\n            throw new RangeError(\"Invalid JSON representation for EditorState\");\n        return EditorState.create({\n            doc: json.doc,\n            selection: EditorSelection.fromJSON(json.selection),\n            extensions: config.extensions\n        });\n    }\n    /// @internal\n    applyTransaction(tr) {\n        let reconf = tr.reconfigureData, config = reconf ? Configuration.resolve(reconf.base, reconf.replaced, this) : this.config;\n        return new EditorState(config, tr.doc, tr.selection, tr);\n    }\n    /// Create a new state. You'll usually only need this when\n    /// initializing an editorupdated states are created by applying\n    /// transactions.\n    static create(config = {}) {\n        let configuration = Configuration.resolve(config.extensions || []);\n        let doc = config.doc instanceof Text ? config.doc\n            : Text.of((config.doc || \"\").split(configuration.staticFacet(EditorState.lineSeparator) || DefaultSplit));\n        let selection = config.selection || EditorSelection.single(0);\n        checkSelection(selection, doc);\n        if (!configuration.staticFacet(allowMultipleSelections))\n            selection = selection.asSingle();\n        return new EditorState(configuration, doc, selection);\n    }\n    /// The size (in columns) of a tab in the document, determined by\n    /// the [`tabSize`](#state.EditorState^tabSize) behavior.\n    get tabSize() { return this.facet(EditorState.tabSize); }\n    /// The size of an indent unit in the document. Determined by the\n    /// [`indentUnit`](#state.EditorState^indentUnit) facet.\n    get indentUnit() { return this.facet(EditorState.indentUnit); }\n    /// Get the syntax tree for this state, which is the current\n    /// (possibly incomplete) parse tree of the [syntax](#state.Syntax)\n    /// with the highest precedence, or the empty tree if there is no\n    /// syntax available.\n    get tree() {\n        let syntax = this.facet(EditorState.syntax);\n        return syntax.length ? syntax[0].getTree(this) : Tree.empty;\n    }\n}\n/// A facet that, when enabled, causes the editor to allow multiple\n/// ranges to be selected. You should probably not use this\n/// directly, but let a plugin like\n/// [multiple-selections](#multiple-selections) handle it (which\n/// also makes sure the selections are visible in the view).\nEditorState.allowMultipleSelections = allowMultipleSelections;\n/// Facet that defines a way to query for automatic indentation\n/// depth at the start of a given line.\nEditorState.indentation = Facet.define();\n/// Configures the tab size to use in this state. The first\n/// (highest-precedence) value of the behavior is used.\nEditorState.tabSize = Facet.define({\n    combine: values => values.length ? values[0] : DefaultTabsize\n});\n/// The line separator to use. By default, any of `\"\\n\"`, `\"\\r\\n\"`\n/// and `\"\\r\"` is treated as a separator when splitting lines, and\n/// lines are joined with `\"\\n\"`.\n///\n/// When you configure a value here, only that precise separator\n/// will be used, allowing you to round-trip documents through the\n/// editor without normalizing line separators.\nEditorState.lineSeparator = Facet.define({\n    combine: values => values.length ? values[0] : undefined,\n    static: true\n});\n/// Facet for overriding the unit (in columns) by which\n/// indentation happens. When not set, this defaults to 2.\nEditorState.indentUnit = Facet.define({\n    combine: values => values.length ? values[0] : DefaultIndentUnit\n});\n/// Facet that registers a parsing service for the state.\nEditorState.syntax = Facet.define();\n/// A facet that registers a code folding service. When called\n/// with the extent of a line, it'll return a range object when a\n/// foldable that starts on that line (but continues beyond it) can\n/// be found.\nEditorState.foldable = Facet.define();\n\n/// Utility function for combining behaviors to fill in a config\n/// object from an array of provided configs. Will, by default, error\n/// when a field gets two values that aren't ===-equal, but you can\n/// provide combine functions per field to do something else.\nfunction combineConfig(configs, defaults, // Should hold only the optional properties of Config, but I haven't managed to express that\ncombine = {}) {\n    let result = {};\n    for (let config of configs)\n        for (let key of Object.keys(config)) {\n            let value = config[key], current = result[key];\n            if (current === undefined)\n                result[key] = value;\n            else if (current === value || value === undefined) ; // No conflict\n            else if (Object.hasOwnProperty.call(combine, key))\n                result[key] = combine[key](current, value);\n            else\n                throw new Error(\"Config merge conflict for field \" + key);\n        }\n    for (let key in defaults)\n        if (result[key] === undefined)\n            result[key] = defaults[key];\n    return result;\n}\n/// Defaults the fields in a configuration object to values given in\n/// `defaults` if they are not already present.\nfunction fillConfig(config, defaults) {\n    let result = {};\n    for (let key in config)\n        result[key] = config[key];\n    for (let key in defaults)\n        if (result[key] === undefined)\n            result[key] = defaults[key];\n    return result;\n}\n\nexport { Annotation, Change, ChangeDesc, ChangeSet, ChangedRange, EditorSelection, EditorState, ExtensionGroup, Facet, MapMode, Precedence, SelectionRange, StateField, Transaction, combineConfig, fillConfig, languageData };\n","import { NodeProp, Tree } from 'lezer-tree';\nimport { EditorState, Annotation, StateField, languageData } from '../../state';\nimport { ViewPlugin } from '../../view';\n\n/// A syntax tree node prop used to associate indentation strategies\n/// with node types. Such a strategy is a function from an indentation\n/// context to a number. That number may be -1, to indicate that no\n/// definitive indentation can be determined, or a column number to\n/// which the given line should be indented.\nconst indentNodeProp = new NodeProp();\nfunction syntaxIndentation(syntax) {\n    return EditorState.indentation.of((state, pos) => {\n        return computeIndentation(state, syntax.getTree(state), pos);\n    });\n}\n// Compute the indentation for a given position from the syntax tree.\nfunction computeIndentation(state, ast, pos) {\n    let tree = ast.resolve(pos);\n    // Enter previous nodes that end in empty error terms, which means\n    // they were broken off by error recovery, so that indentation\n    // works even if the constructs haven't been finished.\n    for (let scan = tree, scanPos = pos;;) {\n        let last = scan.childBefore(scanPos);\n        if (!last)\n            break;\n        if (last.type.prop(NodeProp.error) && last.start == last.end) {\n            tree = scan;\n            scanPos = last.start;\n        }\n        else {\n            scan = last;\n            scanPos = scan.end + 1;\n        }\n    }\n    for (; tree; tree = tree.parent) {\n        let strategy = indentStrategy(tree.type) || (tree.parent == null ? topIndent : null);\n        if (strategy)\n            return strategy(new IndentContext(state, pos, tree));\n    }\n    return -1;\n}\nfunction indentStrategy(type) {\n    let strategy = type.prop(indentNodeProp);\n    if (!strategy) {\n        let delim = type.prop(NodeProp.delim);\n        if (delim)\n            return delimitedIndent({ closing: delim.split(\" \")[1] });\n    }\n    return strategy;\n}\nfunction topIndent() { return 0; }\n/// Objects of this type provide context information and helper\n/// methods to indentation functions.\nclass IndentContext {\n    /// @internal\n    constructor(\n    /// The editor state.\n    state, \n    /// The position at which indentation is being computed.\n    pos, \n    /// The syntax tree node for which the indentation strategy is\n    /// registered.\n    node) {\n        this.state = state;\n        this.pos = pos;\n        this.node = node;\n    }\n    /// The indent unit (number of spaces per indentation level).\n    get unit() { return this.state.indentUnit; }\n    /// Get the text directly after `this.pos`, either the entire line\n    /// or the next 50 characters, whichever is shorter.\n    get textAfter() {\n        return this.state.doc.slice(this.pos, Math.min(this.pos + 50, this.state.doc.lineAt(this.pos).end)).match(/^\\s*(.*)/)[1];\n    }\n    /// find the column position (taking tabs into account) of the given\n    /// position in the given string.\n    countColumn(line, pos) {\n        // FIXME use extending character information\n        if (pos < 0)\n            pos = line.length;\n        let tab = this.state.tabSize;\n        for (var i = 0, n = 0;;) {\n            let nextTab = line.indexOf(\"\\t\", i);\n            if (nextTab < 0 || nextTab >= pos)\n                return n + (pos - i);\n            n += nextTab - i;\n            n += tab - (n % tab);\n            i = nextTab + 1;\n        }\n    }\n    /// Find the indentation column of the given document line.\n    lineIndent(line) {\n        let text = line.slice(0, Math.min(50, line.length, this.node.start > line.start ? this.node.start - line.start : 1e8));\n        return this.countColumn(text, text.search(/\\S/));\n    }\n    /// Get the indentation at the reference line for `this.tree`, which\n    /// is the line on which it starts, unless there is a node that is\n    /// _not_ a parent of this node covering the start of that line. If\n    /// so, the line at the start of that node is tried, again skipping\n    /// on if it is covered by another such node.\n    get baseIndent() {\n        let line = this.state.doc.lineAt(this.node.start);\n        // Skip line starts that are covered by a sibling (or cousin, etc)\n        for (;;) {\n            let atBreak = this.node.resolve(line.start);\n            while (atBreak.parent && atBreak.parent.start == atBreak.start)\n                atBreak = atBreak.parent;\n            if (isParent(atBreak, this.node))\n                break;\n            line = this.state.doc.lineAt(atBreak.start);\n        }\n        return this.lineIndent(line);\n    }\n    /// Find the column for the given position.\n    column(pos) {\n        let line = this.state.doc.lineAt(pos);\n        return this.countColumn(line.slice(0, pos - line.start), pos - line.start);\n    }\n}\nfunction isParent(parent, of) {\n    for (let cur = of; cur; cur = cur.parent)\n        if (parent == cur)\n            return true;\n    return false;\n}\n// Check whether a delimited node is aligned (meaning there are\n// non-skipped nodes on the same line as the opening delimiter). And\n// if so, return the opening token.\nfunction bracketedAligned(context) {\n    let tree = context.node;\n    let openToken = tree.childAfter(tree.start);\n    if (!openToken)\n        return null;\n    let openLine = context.state.doc.lineAt(openToken.start);\n    for (let pos = openToken.end;;) {\n        let next = tree.childAfter(pos);\n        if (!next)\n            return null;\n        if (!next.type.prop(NodeProp.skipped))\n            return next.start < openLine.end ? openToken : null;\n        pos = next.end;\n    }\n}\n/// An indentation strategy for delimited (usually bracketed) nodes.\n/// Will, by default, indent one unit more than the parent's base\n/// indent unless the line starts with a closing token. When `align`\n/// is true and there are non-skipped nodes on the node's opening\n/// line, the content of the node will be aligned with the end of the\n/// opening node, like this:\n///\n///     foo(bar,\n///         baz)\nfunction delimitedIndent({ closing, align = true, units = 1 }) {\n    return (context) => {\n        let closed = context.textAfter.slice(0, closing.length) == closing;\n        let aligned = align ? bracketedAligned(context) : null;\n        if (aligned)\n            return closed ? context.column(aligned.start) : context.column(aligned.end);\n        return context.baseIndent + (closed ? 0 : context.unit * units);\n    };\n}\n/// An indentation strategy that aligns a node content to its base\n/// indentation.\nconst flatIndent = (context) => context.baseIndent;\n/// Creates an indentation strategy that, by default, indents\n/// continued lines one unit more than the node's base indentation.\n/// You can provide `except` to prevent indentation of lines that\n/// match a pattern (for example `/^else\\b/` in `if`/`else`\n/// constructs), and you can change the amount of units used with the\n/// `units` option.\nfunction continuedIndent({ except, units = 1 } = {}) {\n    return (context) => {\n        let matchExcept = except && except.test(context.textAfter);\n        return context.baseIndent + (matchExcept ? 0 : units * context.unit);\n    };\n}\n\n/// This node prop is used to associate folding information with node\n/// types. Given a subtree, it should check whether that tree is\n/// foldable and return the range that can be collapsed when it is.\nconst foldNodeProp = new NodeProp();\nfunction syntaxFolding(syntax) {\n    return EditorState.foldable.of((state, start, end) => {\n        let inner = syntax.getTree(state).resolve(end);\n        let found = null;\n        for (let cur = inner; cur; cur = cur.parent) {\n            if (cur.end <= end || cur.start > end)\n                continue;\n            if (found && cur.start < start)\n                break;\n            let prop = cur.type.prop(foldNodeProp);\n            if (prop) {\n                let value = prop(cur, state);\n                if (value && value.from <= end && value.from >= start && value.to > end)\n                    found = value;\n            }\n        }\n        return found;\n    });\n}\n\n/// A [syntax provider](#state.Syntax) based on a\n/// [Lezer](https://lezer.codemirror.net) parser.\nclass LezerSyntax {\n    /// Create a syntax instance for the given parser. You'll usually\n    /// want to use the\n    /// [`withProps`](https://lezer.codemirror.net/docs/ref/#lezer.Parser.withProps)\n    /// method to register CodeMirror-specific syntax node props in the\n    /// parser, before passing it to this constructor.\n    constructor(parser) {\n        this.parser = parser;\n        let setSyntax = Annotation.define();\n        this.field = StateField.define({\n            create(state) { return SyntaxState.advance(Tree.empty, parser, state.doc); },\n            update(value, tr) { return value.apply(tr, parser, setSyntax); }\n        });\n        this.extension = [\n            EditorState.syntax.of(this),\n            this.field,\n            ViewPlugin.define(view => new HighlightWorker(view, this, setSyntax)),\n            syntaxIndentation(this),\n            syntaxFolding(this)\n        ];\n    }\n    getTree(state) {\n        return state.field(this.field).tree;\n    }\n    parsePos(state) {\n        return state.field(this.field).upto;\n    }\n    ensureTree(state, upto, timeout = 100) {\n        let field = state.field(this.field);\n        if (field.upto >= upto)\n            return field.updatedTree;\n        if (!field.parse)\n            field.startParse(this.parser, state.doc);\n        if (field.parse.pos < upto) {\n            let done = work(field.parse, timeout, upto);\n            if (done)\n                return field.stopParse(done, state.doc.length);\n        }\n        return field.parse.pos < upto ? null : field.stopParse();\n    }\n    get docNodeType() { return this.parser.group.types[1]; }\n    languageDataAt(state, pos) {\n        let type = this.parser.group.types[1];\n        if (this.parser.hasNested) {\n            let tree = this.getTree(state);\n            let target = tree.resolve(pos);\n            while (target) {\n                if (target.type.prop(NodeProp.top)) {\n                    type = target.type;\n                    break;\n                }\n                target = target.parent;\n            }\n        }\n        return (type.prop(languageData) || nothing);\n    }\n}\nconst nothing = {};\nclass DocStream {\n    constructor(doc, length = doc.length) {\n        this.doc = doc;\n        this.length = length;\n        this.cursorPos = 0;\n        this.string = \"\";\n        this.cursor = doc.iter();\n    }\n    get(pos) {\n        if (pos >= this.length)\n            return -1;\n        let stringStart = this.cursorPos - this.string.length;\n        if (pos < stringStart || pos >= this.cursorPos) {\n            if (pos < this.cursorPos) { // Reset the cursor if we have to go back\n                this.cursor = this.doc.iter();\n                this.cursorPos = 0;\n            }\n            this.string = this.cursor.next(pos - this.cursorPos).value;\n            this.cursorPos = pos + this.string.length;\n            stringStart = this.cursorPos - this.string.length;\n        }\n        return this.string.charCodeAt(pos - stringStart);\n    }\n    read(from, to) {\n        let stringStart = this.cursorPos - this.string.length;\n        if (from < stringStart || to >= this.cursorPos)\n            return this.doc.slice(from, to);\n        else\n            return this.string.slice(from - stringStart, to - stringStart);\n    }\n    clip(at) {\n        return new DocStream(this.doc, at);\n    }\n}\nfunction work(parse, time, upto = 5000000 /* MaxPos */) {\n    let endTime = Date.now() + time;\n    for (;;) {\n        let done = parse.advance();\n        if (done)\n            return done;\n        if (parse.pos > upto || Date.now() > endTime)\n            return null;\n    }\n}\nfunction takeTree(parse, base) {\n    let parsed = parse.forceFinish();\n    let after = base.applyChanges([{ fromA: 0, toA: parse.pos, fromB: 0, toB: parse.pos }]);\n    return parsed.append(after);\n}\nclass SyntaxState {\n    constructor(tree, upto) {\n        this.tree = tree;\n        this.upto = upto;\n        this.parse = null;\n        this.updatedTree = tree;\n    }\n    static advance(tree, parser, doc) {\n        let parse = parser.startParse(new DocStream(doc), { cache: tree });\n        let done = work(parse, 25 /* Apply */);\n        return done ? new SyntaxState(done, doc.length) : new SyntaxState(takeTree(parse, tree), parse.pos);\n    }\n    apply(tr, parser, annotation) {\n        let given = tr.annotation(annotation);\n        return given || (!tr.docChanged && this) || SyntaxState.advance((this.parse ? takeTree(this.parse, this.updatedTree) : this.updatedTree).applyChanges(tr.changes.changedRanges()), parser, tr.doc);\n    }\n    startParse(parser, doc) {\n        this.parse = parser.startParse(new DocStream(doc), { cache: this.updatedTree });\n    }\n    stopParse(tree, upto) {\n        if (!tree)\n            tree = takeTree(this.parse, this.updatedTree);\n        this.updatedTree = tree;\n        this.upto = (upto !== null && upto !== void 0 ? upto : this.parse.pos);\n        this.parse = null;\n        return tree;\n    }\n}\nlet requestIdle = typeof window != \"undefined\" && window.requestIdleCallback ||\n    ((callback, { timeout }) => setTimeout(callback, timeout));\nlet cancelIdle = typeof window != \"undefined\" && window.cancelIdleCallback || clearTimeout;\n// FIXME figure out some way to back off from full re-parses when the\n// document is largeyou could waste a lot of battery re-parsing a\n// multi-megabyte document every time you insert a backtick, even if\n// it happens in the background.\nclass HighlightWorker {\n    constructor(view, syntax, setSyntax) {\n        this.view = view;\n        this.syntax = syntax;\n        this.setSyntax = setSyntax;\n        this.working = -1;\n        this.work = this.work.bind(this);\n        this.scheduleWork();\n    }\n    update(update) {\n        if (update.docChanged)\n            this.scheduleWork();\n    }\n    scheduleWork() {\n        if (this.working > -1)\n            return;\n        let { state } = this.view, field = state.field(this.syntax.field);\n        if (field.upto >= state.doc.length)\n            return;\n        this.working = requestIdle(this.work, { timeout: 200 /* Pause */ });\n    }\n    work(deadline) {\n        this.working = -1;\n        let { state } = this.view, field = state.field(this.syntax.field);\n        if (field.upto >= state.doc.length)\n            return;\n        if (!field.parse)\n            field.startParse(this.syntax.parser, state.doc);\n        let done = work(field.parse, deadline ? Math.max(25 /* MinSlice */, deadline.timeRemaining()) : 100 /* Slice */);\n        if (done || field.parse.badness > .8)\n            this.view.dispatch(state.t().annotate(this.setSyntax, new SyntaxState(field.stopParse(done, state.doc.length), state.doc.length)));\n        else\n            this.scheduleWork();\n    }\n    destroy() {\n        if (this.working >= 0)\n            cancelIdle(this.working);\n    }\n}\n\nfunction mkMatchProp() { return new NodeProp({ deserialize(str) { return str.split(\" \"); } }); }\n/// A node prop that encodes information about which other nodes match\n/// this node as delimiters. Should hold a space-separated list of\n/// node names of the closing nodes that match this node.\nconst openNodeProp = mkMatchProp();\n/// Like `openNodeProp`, but for closing nodes. Should hold a\n/// space-separated list of opening node names that match this closing\n/// delimiter.\nconst closeNodeProp = mkMatchProp();\n\nexport { IndentContext, LezerSyntax, closeNodeProp, continuedIndent, delimitedIndent, flatIndent, foldNodeProp, indentNodeProp, openNodeProp };\n","let extendingChars = /[\\u0300-\\u036f\\u0483-\\u0489\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u064b-\\u065e\\u0670\\u06d6-\\u06dc\\u06de-\\u06e4\\u06e7\\u06e8\\u06ea-\\u06ed\\u0711\\u0730-\\u074a\\u0b82\\u0bbe\\u0bc0\\u0bcd\\u0bd7\\u0d3e\\u0d41-\\u0d44\\u0d4d\\u0d57\\u0d62\\u0d63\\u0e31\\u0e34-\\u0e3a\\u0e47-\\u0e4e\\u0eb1\\u0eb4-\\u0eb9\\u0ebb\\u0ebc\\u0ec8-\\u0ecd\\u180b-\\u180d\\u18a9\\u200c\\u200d]/;\ntry {\n    extendingChars = new RegExp(\"\\\\p{Grapheme_Extend}\", \"u\");\n}\ncatch (_) { }\n/// Test whether a given code unit (as in, the thing that `charCodeAt`\n/// returns) extends the character before it.\nfunction isExtendingChar(code) {\n    return code >= 768 && (code >= 0xdc00 && code < 0xe000 || extendingChars.test(String.fromCharCode(code)));\n}\nconst nonASCIISingleCaseWordChar = /[\\u00df\\u0587\\u0590-\\u05f4\\u0600-\\u06ff\\u3040-\\u309f\\u30a0-\\u30ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\uac00-\\ud7af]/;\nlet wordChar;\ntry {\n    wordChar = new RegExp(\"[\\\\p{Alphabetic}_]\", \"u\");\n}\ncatch (_) { }\n// FIXME this doesn't work for astral chars yet (need different calling convention)\nfunction isWordCharBasic(ch) {\n    if (wordChar)\n        return wordChar.test(ch);\n    return /\\w/.test(ch) || ch > \"\\x80\" &&\n        (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch));\n}\n/// Test whether the given character is a word character.\nfunction isWordChar(ch, wordChars) {\n    if (!wordChars)\n        return isWordCharBasic(ch);\n    if (wordChars.source.indexOf(\"\\\\w\") > -1 && isWordCharBasic(ch))\n        return true;\n    return wordChars.test(ch);\n}\n/// This is used to group characters into three categoriesword\n/// characters, whitespace, and anything else. It is used, by default,\n/// to do things like selecting by word.\nvar CharType;\n(function (CharType) {\n    CharType[CharType[\"Word\"] = 0] = \"Word\";\n    CharType[CharType[\"Space\"] = 1] = \"Space\";\n    CharType[CharType[\"Other\"] = 2] = \"Other\";\n})(CharType || (CharType = {}));\n/// Determine the character type for a given character.\nfunction charType(ch, wordChars) {\n    // FIXME make this configurable in a better way\n    return /\\s/.test(ch) ? CharType.Space : isWordChar(ch, wordChars) ? CharType.Word : CharType.Other;\n}\n/// Find the code point at the given position in a string (as in the\n/// [`codePointAt`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/codePointAt)\n/// string method).\nfunction codePointAt(str, pos) {\n    let code0 = str.charCodeAt(pos);\n    if (code0 < 0xd800 || code0 > 0xdbff || pos + 1 == str.length)\n        return code0;\n    let code1 = str.charCodeAt(pos + 1);\n    if (code1 < 0xdc00 || code1 > 0xdfff)\n        return code0;\n    return ((code0 - 0xd800) << 10) + (code1 - 0xdc00) + 0x10000;\n}\n/// Given a Unicode codepoint, return the JavaScript string that\n/// respresents it (as in\n/// [`String.fromCodePoint`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/fromCodePoint).\nfunction fromCodePoint(code) {\n    if (code <= 0xffff)\n        return String.fromCharCode(code);\n    code -= 0x10000;\n    return String.fromCharCode((code >> 10) + 0xd800, (code & 1023) + 0xdc00);\n}\n/// The first character that takes up two positions in a JavaScript\n/// string. It is often useful to compare with this after calling\n/// `codePointAt`, to figure out whether your character takes up 1 or\n/// 2 index positions.\nconst minPairCodePoint = 0x10000;\n\n/// Count the column position at the given offset into the string,\n/// taking extending characters and tab size into account.\nfunction countColumn(string, n, tabSize) {\n    for (let i = 0; i < string.length; i++) {\n        let code = string.charCodeAt(i);\n        if (code == 9)\n            n += tabSize - (n % tabSize);\n        else if (code < 768 || !isExtendingChar(code))\n            n++;\n    }\n    return n;\n}\n/// Find the offset that corresponds to the given column position in a\n/// string, taking extending characters and tab size into account.\nfunction findColumn(string, n, col, tabSize) {\n    for (let i = 0; i < string.length; i++) {\n        let code = string.charCodeAt(i);\n        if (isExtendingChar(code))\n            continue;\n        if (n >= col)\n            return { offset: i, leftOver: 0 };\n        n += code == 9 ? tabSize - (n % tabSize) : 1;\n    }\n    return { offset: string.length, leftOver: col - n };\n}\n\n/// The document tree type.\nclass Text {\n    /// @internal\n    constructor() { }\n    /// Get the line description around the given position.\n    lineAt(pos) {\n        if (pos < 0 || pos > this.length)\n            throw new RangeError(`Invalid position ${pos} in document of length ${this.length}`);\n        for (let i = 0; i < lineCache.length; i += 2) {\n            if (lineCache[i] != this)\n                continue;\n            let line = lineCache[i + 1];\n            if (line.start <= pos && line.end >= pos)\n                return line;\n        }\n        return cacheLine(this, this.lineInner(pos, false, 1, 0).finish(this));\n    }\n    /// Get the description for the given (1-based) line number.\n    line(n) {\n        if (n < 1 || n > this.lines)\n            throw new RangeError(`Invalid line number ${n} in ${this.lines}-line document`);\n        for (let i = 0; i < lineCache.length; i += 2) {\n            if (lineCache[i] != this)\n                continue;\n            let line = lineCache[i + 1];\n            if (line.number == n)\n                return line;\n        }\n        return cacheLine(this, this.lineInner(n, true, 1, 0).finish(this));\n    }\n    /// Replace a range of the text with the given lines. `text` should\n    /// have a length of at least one.\n    replace(from, to, text) {\n        if (text.length == 0)\n            throw new RangeError(\"An inserted range must have at least one line\");\n        return this.replaceInner(from, to, text, textLength(text));\n    }\n    /// Retrieve the lines between the given points.\n    sliceLines(from, to = this.length) {\n        return this.sliceTo(from, to, [\"\"]);\n    }\n    /// Retrieve the text between the given points.\n    slice(from, to, lineSeparator = \"\\n\") {\n        return this.sliceLines(from, to).join(lineSeparator);\n    }\n    /// Test whether this text is equal to another instance.\n    eq(other) { return this == other || eqContent(this, other); }\n    /// Iterate over the text. When `dir` is `-1`, iteration happens\n    /// from end to start. This will return lines and the breaks between\n    /// them as separate strings, and for long lines, might split lines\n    /// themselves into multiple chunks as well.\n    iter(dir = 1) { return new RawTextCursor(this, dir); }\n    /// Iterate over a range of the text. When `from` > `to`, the\n    /// iterator will run in reverse.\n    iterRange(from, to = this.length) { return new PartialTextCursor(this, from, to); }\n    /// Iterate over lines in the text, starting at position (_not_ line\n    /// number) `from`. An iterator returned by this combines all text\n    /// on a line into a single string (which may be expensive for very\n    /// long lines), and skips line breaks (its\n    /// [`lineBreak`](#text.TextIterator.lineBreak) property is always\n    /// false).\n    iterLines(from = 0) { return new LineCursor(this, from); }\n    /// Flattens the document into a single string, using `\"\\n\"` as line\n    /// separator.\n    toString() { return this.slice(0, this.length); }\n    /// Create a `Text` instance for the given array of lines.\n    static of(text) {\n        if (text.length == 0)\n            throw new RangeError(\"A document must have at least one line\");\n        let length = textLength(text);\n        return length < 1024 /* MaxLeaf */ ? new TextLeaf(text, length) : TextNode.from(TextLeaf.split(text, []), length);\n    }\n}\nlet lineCache = [], lineCachePos = -2, lineCacheSize = 12;\nfunction cacheLine(text, line) {\n    lineCachePos = (lineCachePos + 2) % lineCacheSize;\n    lineCache[lineCachePos] = text;\n    lineCache[lineCachePos + 1] = line;\n    return line;\n}\n// Leaves store an array of strings. There are always line breaks\n// between these strings (though not between adjacent leaves). These\n// are limited in length, so that bigger documents are constructed as\n// a tree structure. Long lines will be broken into a number of\n// single-line leaves.\nclass TextLeaf extends Text {\n    constructor(text, length = textLength(text)) {\n        super();\n        this.text = text;\n        this.length = length;\n    }\n    get lines() { return this.text.length; }\n    get children() { return null; }\n    replaceInner(from, to, text, length) {\n        return Text.of(appendText(this.text, appendText(text, sliceText(this.text, 0, from)), to));\n    }\n    sliceTo(from, to = this.length, target) {\n        return appendText(this.text, target, from, to);\n    }\n    lineInner(target, isLine, line, offset) {\n        for (let i = 0;; i++) {\n            let string = this.text[i], end = offset + string.length;\n            if ((isLine ? line : end) >= target)\n                return new Line(offset, end, line, string);\n            offset = end + 1;\n            line++;\n        }\n    }\n    decomposeStart(to, target) {\n        target.push(new TextLeaf(sliceText(this.text, 0, to), to));\n    }\n    decomposeEnd(from, target) {\n        target.push(new TextLeaf(sliceText(this.text, from), this.length - from));\n    }\n    lastLineLength() { return this.text[this.text.length - 1].length; }\n    firstLineLength() { return this.text[0].length; }\n    static split(text, target) {\n        let part = [], length = -1;\n        for (let line of text) {\n            for (;;) {\n                let newLength = length + line.length + 1;\n                if (newLength < 512 /* BaseLeaf */) {\n                    length = newLength;\n                    part.push(line);\n                    break;\n                }\n                let cut = 512 /* BaseLeaf */ - length - 1, after = line.charCodeAt(cut);\n                if (after >= 0xdc00 && after < 0xe000)\n                    cut++;\n                part.push(line.slice(0, cut));\n                target.push(new TextLeaf(part, 512 /* BaseLeaf */));\n                line = line.slice(cut);\n                length = -1;\n                part = [];\n            }\n        }\n        if (length != -1)\n            target.push(new TextLeaf(part, length));\n        return target;\n    }\n}\n// Nodes provide the tree structure of the `Text` type. They store a\n// number of other nodes or leaves, taking care to balance itself on\n// changes.\nclass TextNode extends Text {\n    constructor(children, length) {\n        super();\n        this.children = children;\n        this.length = length;\n        this.lines = 1;\n        for (let child of children)\n            this.lines += child.lines - 1;\n    }\n    replaceInner(from, to, text, length) {\n        let lengthDiff = length - (to - from), newLength = this.length + lengthDiff;\n        if (newLength <= 512 /* BaseLeaf */)\n            return new TextLeaf(appendText(this.sliceLines(to), appendText(text, this.sliceTo(0, from, [\"\"]))), newLength);\n        let children;\n        for (let i = 0, pos = 0; i < this.children.length; i++) {\n            let child = this.children[i], end = pos + child.length;\n            if (from >= pos && to <= end &&\n                (lengthDiff > 0\n                    ? child.length + lengthDiff < Math.max(newLength >> (3 /* BranchShift */ - 1), 1024 /* MaxLeaf */)\n                    : child.length + lengthDiff > newLength >> (3 /* BranchShift */ + 1))) {\n                // Fast path: if the change only affects one child and the\n                // child's size remains in the acceptable range, only update\n                // that child\n                children = this.children.slice();\n                children[i] = child.replace(from - pos, to - pos, text);\n                return new TextNode(children, newLength);\n            }\n            else if (end >= from) {\n                // Otherwise, we must build up a new array of children\n                if (children == null)\n                    children = this.children.slice(0, i);\n                if (pos < from) {\n                    if (end == from)\n                        children.push(child);\n                    else\n                        child.decomposeStart(from - pos, children);\n                }\n                if (pos <= from && end >= from)\n                    TextLeaf.split(text, children);\n                if (pos >= to)\n                    children.push(child);\n                else if (end > to)\n                    child.decomposeEnd(to - pos, children);\n            }\n            pos = end;\n        }\n        return children ? TextNode.from(children, newLength) : this;\n    }\n    sliceTo(from, to, target) {\n        let pos = 0;\n        for (let child of this.children) {\n            let end = pos + child.length;\n            if (to > pos && from < end)\n                child.sliceTo(Math.max(0, from - pos), Math.min(child.length, to - pos), target);\n            pos = end;\n        }\n        return target;\n    }\n    lineInner(target, isLine, line, offset) {\n        for (let i = 0;; i++) {\n            let child = this.children[i], end = offset + child.length, endLine = line + child.lines - 1;\n            if ((isLine ? endLine : end) >= target) {\n                let inner = child.lineInner(target, isLine, line, offset), add;\n                if (inner.start == offset && (add = this.lineLengthTo(i))) {\n                    inner.start -= add;\n                    inner.content = null;\n                }\n                if (inner.end == end && (add = this.lineLengthFrom(i + 1))) {\n                    inner.end += add;\n                    inner.content = null;\n                }\n                return inner;\n            }\n            offset = end;\n            line = endLine;\n        }\n    }\n    decomposeStart(to, target) {\n        for (let i = 0, pos = 0;; i++) {\n            let child = this.children[i], end = pos + child.length;\n            if (end <= to) {\n                target.push(child);\n            }\n            else {\n                if (pos < to)\n                    child.decomposeStart(to - pos, target);\n                break;\n            }\n            pos = end;\n        }\n    }\n    decomposeEnd(from, target) {\n        let pos = 0;\n        for (let child of this.children) {\n            let end = pos + child.length;\n            if (pos >= from)\n                target.push(child);\n            else if (end > from && pos < from)\n                child.decomposeEnd(from - pos, target);\n            pos = end;\n        }\n    }\n    lineLengthTo(to) {\n        let length = 0;\n        for (let i = to - 1; i >= 0; i--) {\n            let child = this.children[i];\n            if (child.lines > 1)\n                return length + child.lastLineLength();\n            length += child.length;\n        }\n        return length;\n    }\n    lastLineLength() { return this.lineLengthTo(this.children.length); }\n    lineLengthFrom(from) {\n        let length = 0;\n        for (let i = from; i < this.children.length; i++) {\n            let child = this.children[i];\n            if (child.lines > 1)\n                return length + child.firstLineLength();\n            length += child.length;\n        }\n        return length;\n    }\n    firstLineLength() { return this.lineLengthFrom(0); }\n    static from(children, length) {\n        if (length < 1024 /* MaxLeaf */) {\n            let text = [\"\"];\n            for (let child of children)\n                child.sliceTo(0, child.length, text);\n            return new TextLeaf(text, length);\n        }\n        let chunkLength = Math.max(512 /* BaseLeaf */, length >> 3 /* BranchShift */), maxLength = chunkLength << 1, minLength = chunkLength >> 1;\n        let chunked = [], currentLength = 0, currentChunk = [];\n        function add(child) {\n            let childLength = child.length, last;\n            if (childLength > maxLength && child instanceof TextNode) {\n                for (let node of child.children)\n                    add(node);\n            }\n            else if (childLength > minLength && (currentLength > minLength || currentLength == 0)) {\n                flush();\n                chunked.push(child);\n            }\n            else if (child instanceof TextLeaf && currentLength > 0 &&\n                (last = currentChunk[currentChunk.length - 1]) instanceof TextLeaf &&\n                child.length + last.length <= 512 /* BaseLeaf */) {\n                currentLength += childLength;\n                currentChunk[currentChunk.length - 1] = new TextLeaf(appendText(child.text, last.text.slice()), child.length + last.length);\n            }\n            else {\n                if (currentLength + childLength > chunkLength)\n                    flush();\n                currentLength += childLength;\n                currentChunk.push(child);\n            }\n        }\n        function flush() {\n            if (currentLength == 0)\n                return;\n            chunked.push(currentChunk.length == 1 ? currentChunk[0] : TextNode.from(currentChunk, currentLength));\n            currentLength = 0;\n            currentChunk.length = 0;\n        }\n        for (let child of children)\n            add(child);\n        flush();\n        return chunked.length == 1 ? chunked[0] : new TextNode(chunked, length);\n    }\n}\nText.empty = Text.of([\"\"]);\nfunction textLength(text) {\n    let length = -1;\n    for (let line of text)\n        length += line.length + 1;\n    return length;\n}\nfunction appendText(text, target, from = 0, to = 1e9) {\n    for (let pos = 0, i = 0, first = true; i < text.length && pos <= to; i++) {\n        let line = text[i], end = pos + line.length;\n        if (end >= from) {\n            if (end > to)\n                line = line.slice(0, to - pos);\n            if (pos < from)\n                line = line.slice(from - pos);\n            if (first) {\n                target[target.length - 1] += line;\n                first = false;\n            }\n            else\n                target.push(line);\n        }\n        pos = end + 1;\n    }\n    return target;\n}\nfunction sliceText(text, from, to) {\n    return appendText(text, [\"\"], from, to);\n}\nfunction eqContent(a, b) {\n    if (a.length != b.length || a.lines != b.lines)\n        return false;\n    let iterA = new RawTextCursor(a), iterB = new RawTextCursor(b);\n    for (let offA = 0, offB = 0;;) {\n        if (iterA.lineBreak != iterB.lineBreak || iterA.done != iterB.done) {\n            return false;\n        }\n        else if (iterA.done) {\n            return true;\n        }\n        else if (iterA.lineBreak) {\n            iterA.next();\n            iterB.next();\n            offA = offB = 0;\n        }\n        else {\n            let strA = iterA.value.slice(offA), strB = iterB.value.slice(offB);\n            if (strA.length == strB.length) {\n                if (strA != strB)\n                    return false;\n                iterA.next();\n                iterB.next();\n                offA = offB = 0;\n            }\n            else if (strA.length > strB.length) {\n                if (strA.slice(0, strB.length) != strB)\n                    return false;\n                offA += strB.length;\n                iterB.next();\n                offB = 0;\n            }\n            else {\n                if (strB.slice(0, strA.length) != strA)\n                    return false;\n                offB += strA.length;\n                iterA.next();\n                offA = 0;\n            }\n        }\n    }\n}\nclass RawTextCursor {\n    constructor(text, dir = 1) {\n        this.dir = dir;\n        this.done = false;\n        this.lineBreak = false;\n        this.value = \"\";\n        this.nodes = [text];\n        this.offsets = [dir > 0 ? 0 : text instanceof TextLeaf ? text.text.length : text.children.length];\n    }\n    next(skip = 0) {\n        for (;;) {\n            let last = this.nodes.length - 1;\n            if (last < 0) {\n                this.done = true;\n                this.value = \"\";\n                this.lineBreak = false;\n                return this;\n            }\n            let top = this.nodes[last];\n            let offset = this.offsets[last];\n            if (top instanceof TextLeaf) {\n                // Internal offset with lineBreak == false means we have to\n                // count the line break at this position\n                if (offset != (this.dir > 0 ? 0 : top.text.length) && !this.lineBreak) {\n                    this.lineBreak = true;\n                    if (skip == 0) {\n                        this.value = \"\\n\";\n                        return this;\n                    }\n                    skip--;\n                    continue;\n                }\n                // Otherwise, move to the next string\n                let next = top.text[offset - (this.dir < 0 ? 1 : 0)];\n                this.offsets[last] = (offset += this.dir);\n                if (offset == (this.dir > 0 ? top.text.length : 0)) {\n                    this.nodes.pop();\n                    this.offsets.pop();\n                }\n                this.lineBreak = false;\n                if (next.length > skip) {\n                    this.value = skip == 0 ? next : this.dir > 0 ? next.slice(skip) : next.slice(0, next.length - skip);\n                    return this;\n                }\n                skip -= next.length;\n            }\n            else if (offset == (this.dir > 0 ? top.children.length : 0)) {\n                this.nodes.pop();\n                this.offsets.pop();\n            }\n            else {\n                let next = top.children[this.dir > 0 ? offset : offset - 1], len = next.length;\n                this.offsets[last] = offset + this.dir;\n                if (skip > len) {\n                    skip -= len;\n                }\n                else {\n                    this.nodes.push(next);\n                    this.offsets.push(this.dir > 0 ? 0 : next instanceof TextLeaf ? next.text.length : next.children.length);\n                }\n            }\n        }\n    }\n}\nclass PartialTextCursor {\n    constructor(text, start, end) {\n        this.value = \"\";\n        this.cursor = new RawTextCursor(text, start > end ? -1 : 1);\n        if (start > end) {\n            this.skip = text.length - start;\n            this.limit = start - end;\n        }\n        else {\n            this.skip = start;\n            this.limit = end - start;\n        }\n    }\n    next() {\n        if (this.limit <= 0) {\n            this.limit = -1;\n        }\n        else {\n            let { value, lineBreak } = this.cursor.next(this.skip);\n            this.skip = 0;\n            this.value = value;\n            let len = lineBreak ? 1 : value.length;\n            if (len > this.limit)\n                this.value = this.cursor.dir > 0 ? value.slice(0, this.limit) : value.slice(len - this.limit);\n            this.limit -= this.value.length;\n        }\n        return this;\n    }\n    get lineBreak() { return this.cursor.lineBreak; }\n    get done() { return this.limit < 0; }\n}\nclass LineCursor {\n    constructor(text, from = 0) {\n        this.value = \"\";\n        this.done = false;\n        this.cursor = text.iter();\n        this.skip = from;\n    }\n    next() {\n        if (this.cursor.done) {\n            this.done = true;\n            this.value = \"\";\n            return this;\n        }\n        for (this.value = \"\";;) {\n            let { value, lineBreak, done } = this.cursor.next(this.skip);\n            this.skip = 0;\n            if (done || lineBreak)\n                return this;\n            this.value += value;\n        }\n    }\n    get lineBreak() { return false; }\n}\n// FIXME rename start/end to from/to for consistency with other types?\n/// This type describes a line in the document. It is created\n/// on-demand when lines are [queried](#text.Text.lineAt).\nclass Line {\n    /// @internal\n    constructor(\n    /// The position of the start of the line.\n    start, \n    /// The position at the end of the line (_before_ the line break,\n    /// if this isn't the last line).\n    end, \n    /// This line's line number (1-based).\n    number, \n    /// @internal\n    content) {\n        this.start = start;\n        this.end = end;\n        this.number = number;\n        this.content = content;\n    }\n    /// The length of the line (not including any line break after it).\n    get length() { return this.end - this.start; }\n    /// Retrieve a part of the content of this line. This is a method,\n    /// rather than, say, a string property, to avoid concatenating long\n    /// lines whenever they are accessed. Try to write your code, if it\n    /// is going to be doing a lot of line-reading, to read only the\n    /// parts it needs.\n    slice(from = 0, to = this.length) {\n        if (typeof this.content == \"string\")\n            return to == from + 1 ? this.content.charAt(from) : this.content.slice(from, to);\n        if (from == to)\n            return \"\";\n        let result = this.content.slice(from, to);\n        if (from == 0 && to == this.length)\n            this.content = result;\n        return result;\n    }\n    /// @internal\n    finish(text) {\n        if (this.content == null)\n            this.content = new LineContent(text, this.start);\n        return this;\n    }\n}\nclass LineContent {\n    constructor(doc, start) {\n        this.doc = doc;\n        this.start = start;\n        this.cursor = null;\n        this.strings = null;\n    }\n    // FIXME quadratic complexity (somewhat) when iterating long lines in small pieces\n    slice(from, to) {\n        if (!this.cursor) {\n            this.cursor = this.doc.iter();\n            this.strings = [this.cursor.next(this.start).value];\n        }\n        for (let result = \"\", pos = 0, i = 0;; i++) {\n            if (i == this.strings.length)\n                this.strings.push(this.cursor.next().value);\n            let string = this.strings[i], end = pos + string.length;\n            if (end <= from)\n                continue;\n            result += string.slice(Math.max(0, from - pos), Math.min(string.length, to - pos));\n            if (end >= to)\n                return result;\n            pos += string.length;\n        }\n    }\n}\n\nexport { CharType, Line, Text, charType, codePointAt, countColumn, findColumn, fromCodePoint, isExtendingChar, isWordChar, minPairCodePoint };\n","import { MapMode, Facet, ChangeSet, ChangedRange, SelectionRange, EditorSelection, Change, Transaction, EditorState, Precedence } from '../../state';\nimport { StyleModule } from 'style-mod';\nimport { RangeValue, RangeSet } from '../../rangeset';\nexport { Range } from '../../rangeset';\nimport { Text, countColumn, findColumn, isExtendingChar } from '../../text';\n\nlet [nav, doc] = typeof navigator != \"undefined\"\n    ? [navigator, document]\n    : [{ userAgent: \"\", vendor: \"\", platform: \"\" }, { documentElement: { style: {} } }];\nconst ie_edge = /Edge\\/(\\d+)/.exec(nav.userAgent);\nconst ie_upto10 = /MSIE \\d/.test(nav.userAgent);\nconst ie_11up = /Trident\\/(?:[7-9]|\\d{2,})\\..*rv:(\\d+)/.exec(nav.userAgent);\nconst ie = !!(ie_upto10 || ie_11up || ie_edge);\nconst gecko = !ie && /gecko\\/(\\d+)/i.test(nav.userAgent);\nconst chrome = !ie && /Chrome\\/(\\d+)/.exec(nav.userAgent);\nconst webkit = !ie && 'WebkitAppearance' in doc.documentElement.style;\nvar browser = {\n    mac: /Mac/.test(nav.platform),\n    ie,\n    ie_version: ie_upto10 ? doc.documentMode || 6 : ie_11up ? +ie_11up[1] : ie_edge ? +ie_edge[1] : 0,\n    gecko,\n    gecko_version: gecko ? +(/Firefox\\/(\\d+)/.exec(nav.userAgent) || [0, 0])[1] : 0,\n    chrome: !!chrome,\n    chrome_version: chrome ? +chrome[1] : 0,\n    ios: !ie && /AppleWebKit/.test(nav.userAgent) && /Mobile\\/\\w+/.test(nav.userAgent),\n    android: /Android\\b/.test(nav.userAgent),\n    webkit,\n    safari: /Apple Computer/.test(nav.vendor),\n    webkit_version: webkit ? +(/\\bAppleWebKit\\/(\\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0,\n    tabSize: doc.documentElement.style.tabSize != null ? \"tab-size\" : \"-moz-tab-size\"\n};\n\nfunction getSelection(root) {\n    return (root.getSelection ? root.getSelection() : document.getSelection());\n}\n// Work around Chrome issue https://bugs.chromium.org/p/chromium/issues/detail?id=447523\n// (isCollapsed inappropriately returns true in shadow dom)\nfunction selectionCollapsed(domSel) {\n    let collapsed = domSel.isCollapsed;\n    if (collapsed && browser.chrome && domSel.rangeCount && !domSel.getRangeAt(0).collapsed)\n        collapsed = false;\n    return collapsed;\n}\nfunction hasSelection(dom, selection) {\n    if (!selection.anchorNode)\n        return false;\n    try {\n        // Firefox will raise 'permission denied' errors when accessing\n        // properties of `sel.anchorNode` when it's in a generated CSS\n        // element.\n        return dom.contains(selection.anchorNode.nodeType == 3 ? selection.anchorNode.parentNode : selection.anchorNode);\n    }\n    catch (_) {\n        return false;\n    }\n}\nfunction clientRectsFor(dom) {\n    if (dom.nodeType == 3) {\n        let range = document.createRange();\n        range.setEnd(dom, dom.nodeValue.length);\n        range.setStart(dom, 0);\n        return range.getClientRects();\n    }\n    else if (dom.nodeType == 1) {\n        return dom.getClientRects();\n    }\n    else {\n        return [];\n    }\n}\n// Scans forward and backward through DOM positions equivalent to the\n// given one to see if the two are in the same place (i.e. after a\n// text node vs at the end of that text node)\nfunction isEquivalentPosition(node, off, targetNode, targetOff) {\n    return targetNode ? (scanFor(node, off, targetNode, targetOff, -1) ||\n        scanFor(node, off, targetNode, targetOff, 1)) : false;\n}\nfunction domIndex(node) {\n    for (var index = 0;; index++) {\n        node = node.previousSibling;\n        if (!node)\n            return index;\n    }\n}\nfunction scanFor(node, off, targetNode, targetOff, dir) {\n    for (;;) {\n        if (node == targetNode && off == targetOff)\n            return true;\n        if (off == (dir < 0 ? 0 : maxOffset(node))) {\n            if (node.nodeName == \"DIV\")\n                return false;\n            let parent = node.parentNode;\n            if (!parent || parent.nodeType != 1)\n                return false;\n            off = domIndex(node) + (dir < 0 ? 0 : 1);\n            node = parent;\n        }\n        else if (node.nodeType == 1) {\n            node = node.childNodes[off + (dir < 0 ? -1 : 0)];\n            off = dir < 0 ? maxOffset(node) : 0;\n        }\n        else {\n            return false;\n        }\n    }\n}\nfunction maxOffset(node) {\n    return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;\n}\nfunction windowRect(win) {\n    return { left: 0, right: win.innerWidth,\n        top: 0, bottom: win.innerHeight };\n}\nconst ScrollSpace = 5;\nfunction scrollRectIntoView(dom, rect) {\n    let doc = dom.ownerDocument, win = doc.defaultView;\n    for (let cur = dom.parentNode; cur;) {\n        if (cur.nodeType == 1) { // Element\n            let bounding, top = cur == document.body;\n            if (top) {\n                bounding = windowRect(win);\n            }\n            else {\n                if (cur.scrollHeight <= cur.clientHeight && cur.scrollWidth <= cur.clientWidth) {\n                    cur = cur.parentNode;\n                    continue;\n                }\n                let rect = cur.getBoundingClientRect();\n                // Make sure scrollbar width isn't included in the rectangle\n                bounding = { left: rect.left, right: rect.left + cur.clientWidth,\n                    top: rect.top, bottom: rect.top + cur.clientHeight };\n            }\n            let moveX = 0, moveY = 0;\n            if (rect.top < bounding.top)\n                moveY = -(bounding.top - rect.top + ScrollSpace);\n            else if (rect.bottom > bounding.bottom)\n                moveY = rect.bottom - bounding.bottom + ScrollSpace;\n            if (rect.left < bounding.left)\n                moveX = -(bounding.left - rect.left + ScrollSpace);\n            else if (rect.right > bounding.right)\n                moveX = rect.right - bounding.right + ScrollSpace;\n            if (moveX || moveY) {\n                if (top) {\n                    win.scrollBy(moveX, moveY);\n                }\n                else {\n                    if (moveY) {\n                        let start = cur.scrollTop;\n                        cur.scrollTop += moveY;\n                        moveY = cur.scrollTop - start;\n                    }\n                    if (moveX) {\n                        let start = cur.scrollLeft;\n                        cur.scrollLeft += moveX;\n                        moveX = cur.scrollLeft - start;\n                    }\n                    rect = { left: rect.left - moveX, top: rect.top - moveY,\n                        right: rect.right - moveX, bottom: rect.bottom - moveY };\n                }\n            }\n            if (top)\n                break;\n            cur = cur.parentNode;\n        }\n        else if (cur.nodeType == 11) { // A shadow root\n            cur = cur.host;\n        }\n        else {\n            break;\n        }\n    }\n}\nclass DOMSelection {\n    constructor() {\n        this.anchorNode = null;\n        this.anchorOffset = 0;\n        this.focusNode = null;\n        this.focusOffset = 0;\n    }\n    eq(domSel) {\n        return this.anchorNode == domSel.anchorNode && this.anchorOffset == domSel.anchorOffset &&\n            this.focusNode == domSel.focusNode && this.focusOffset == domSel.focusOffset;\n    }\n    set(domSel) {\n        this.anchorNode = domSel.anchorNode;\n        this.anchorOffset = domSel.anchorOffset;\n        this.focusNode = domSel.focusNode;\n        this.focusOffset = domSel.focusOffset;\n    }\n}\nlet preventScrollSupported = null;\n// Feature-detects support for .focus({preventScroll: true}), and uses\n// a fallback kludge when not supported.\nfunction focusPreventScroll(dom) {\n    if (dom.setActive)\n        return dom.setActive(); // in IE\n    if (preventScrollSupported)\n        return dom.focus(preventScrollSupported);\n    let stack = [];\n    for (let cur = dom; cur; cur = cur.parentNode) {\n        stack.push(cur, dom.scrollTop, dom.scrollLeft);\n        if (cur == cur.ownerDocument)\n            break;\n    }\n    dom.focus(preventScrollSupported == null ? {\n        get preventScroll() {\n            preventScrollSupported = { preventScroll: true };\n            return true;\n        }\n    } : undefined);\n    if (!preventScrollSupported) {\n        preventScrollSupported = false;\n        for (let i = 0; i < stack.length;) {\n            let elt = stack[i++], top = stack[i++], left = stack[i++];\n            if (elt.scrollTop != top)\n                elt.scrollTop = top;\n            if (elt.scrollLeft != left)\n                elt.scrollLeft = left;\n        }\n    }\n}\n\nclass DOMPos {\n    constructor(node, offset, precise = true) {\n        this.node = node;\n        this.offset = offset;\n        this.precise = precise;\n    }\n    static before(dom, precise) { return new DOMPos(dom.parentNode, domIndex(dom), precise); }\n    static after(dom, precise) { return new DOMPos(dom.parentNode, domIndex(dom) + 1, precise); }\n}\nconst none = [];\nclass ContentView {\n    constructor() {\n        this.parent = null;\n        this.dom = null;\n        this.dirty = 2 /* Node */;\n    }\n    get editorView() {\n        if (!this.parent)\n            throw new Error(\"Accessing view in orphan content view\");\n        return this.parent.editorView;\n    }\n    get overrideDOMText() { return null; }\n    get posAtStart() {\n        return this.parent ? this.parent.posBefore(this) : 0;\n    }\n    get posAtEnd() {\n        return this.posAtStart + this.length;\n    }\n    posBefore(view) {\n        let pos = this.posAtStart;\n        for (let child of this.children) {\n            if (child == view)\n                return pos;\n            pos += child.length + child.breakAfter;\n        }\n        throw new RangeError(\"Invalid child in posBefore\");\n    }\n    posAfter(view) {\n        return this.posBefore(view) + view.length;\n    }\n    coordsAt(pos) { return null; }\n    sync() {\n        if (this.dirty & 2 /* Node */) {\n            let parent = this.dom, pos = parent.firstChild;\n            for (let child of this.children) {\n                if (child.dirty) {\n                    if (pos && !child.dom && !ContentView.get(pos)) {\n                        let prev = pos.previousSibling;\n                        if (child.reuseDOM(pos))\n                            pos = prev ? prev.nextSibling : parent.firstChild;\n                    }\n                    child.sync();\n                    child.dirty = 0 /* Not */;\n                }\n                pos = syncNodeInto(parent, pos, child.dom);\n            }\n            while (pos)\n                pos = rm(pos);\n        }\n        else if (this.dirty & 1 /* Child */) {\n            for (let child of this.children)\n                if (child.dirty) {\n                    child.sync();\n                    child.dirty = 0 /* Not */;\n                }\n        }\n    }\n    reuseDOM(dom) { return false; }\n    localPosFromDOM(node, offset) {\n        let after;\n        if (node == this.dom) {\n            after = this.dom.childNodes[offset];\n        }\n        else {\n            let bias = maxOffset(node) == 0 ? 0 : offset == 0 ? -1 : 1;\n            for (;;) {\n                let parent = node.parentNode;\n                if (parent == this.dom)\n                    break;\n                if (bias == 0 && parent.firstChild != parent.lastChild) {\n                    if (node == parent.firstChild)\n                        bias = -1;\n                    else\n                        bias = 1;\n                }\n                node = parent;\n            }\n            if (bias < 0)\n                after = node;\n            else\n                after = node.nextSibling;\n        }\n        if (after == this.dom.firstChild)\n            return 0;\n        while (after && !ContentView.get(after))\n            after = after.nextSibling;\n        if (!after)\n            return this.length;\n        for (let i = 0, pos = 0;; i++) {\n            let child = this.children[i];\n            if (child.dom == after)\n                return pos;\n            pos += child.length + child.breakAfter;\n        }\n    }\n    domBoundsAround(from, to, offset = 0) {\n        let fromI = -1, fromStart = -1, toI = -1, toEnd = -1;\n        for (let i = 0, pos = offset; i < this.children.length; i++) {\n            let child = this.children[i], end = pos + child.length;\n            if (pos < from && end > to)\n                return child.domBoundsAround(from, to, pos);\n            if (end >= from && fromI == -1) {\n                fromI = i;\n                fromStart = pos;\n            }\n            if (end >= to && toI == -1) {\n                toI = i;\n                toEnd = end;\n                break;\n            }\n            pos = end + child.breakAfter;\n        }\n        return { from: fromStart, to: toEnd,\n            startDOM: (fromI ? this.children[fromI - 1].dom.nextSibling : null) || this.dom.firstChild,\n            endDOM: toI < this.children.length - 1 ? this.children[toI + 1].dom : null };\n    }\n    // FIXME track precise dirty ranges, to avoid full DOM sync on every touched node?\n    markDirty(andParent = false) {\n        if (this.dirty & 2 /* Node */)\n            return;\n        this.dirty |= 2 /* Node */;\n        this.markParentsDirty(andParent);\n    }\n    markParentsDirty(childList) {\n        for (let parent = this.parent; parent; parent = parent.parent) {\n            if (childList)\n                parent.dirty |= 2 /* Node */;\n            if (parent.dirty & 1 /* Child */)\n                return;\n            parent.dirty |= 1 /* Child */;\n            childList = false;\n        }\n    }\n    setParent(parent) {\n        if (this.parent != parent) {\n            this.parent = parent;\n            if (this.dirty)\n                this.markParentsDirty(true);\n        }\n    }\n    setDOM(dom) {\n        this.dom = dom;\n        dom.cmView = this;\n    }\n    get rootView() {\n        for (let v = this;;) {\n            let parent = v.parent;\n            if (!parent)\n                return v;\n            v = parent;\n        }\n    }\n    replaceChildren(from, to, children = none) {\n        this.markDirty();\n        for (let i = from; i < to; i++)\n            this.children[i].parent = null;\n        this.children.splice(from, to - from, ...children);\n        for (let i = 0; i < children.length; i++)\n            children[i].setParent(this);\n    }\n    ignoreMutation(rec) { return false; }\n    ignoreEvent(event) { return false; }\n    childCursor(pos = this.length) {\n        return new ChildCursor(this.children, pos, this.children.length);\n    }\n    childPos(pos, bias = 1) {\n        return this.childCursor().findPos(pos, bias);\n    }\n    toString() {\n        let name = this.constructor.name.replace(\"View\", \"\");\n        return name + (this.children.length ? \"(\" + this.children.join() + \")\" :\n            this.length ? \"[\" + (name == \"Text\" ? this.text : this.length) + \"]\" : \"\") +\n            (this.breakAfter ? \"#\" : \"\");\n    }\n    static get(node) { return node.cmView; }\n}\nContentView.prototype.breakAfter = 0;\n// Remove a DOM node and return its next sibling.\nfunction rm(dom) {\n    let next = dom.nextSibling;\n    dom.parentNode.removeChild(dom);\n    return next;\n}\nfunction syncNodeInto(parent, pos, dom) {\n    if (dom.parentNode == parent) {\n        while (pos != dom)\n            pos = rm(pos);\n        pos = dom.nextSibling;\n    }\n    else {\n        parent.insertBefore(dom, pos);\n    }\n    return pos;\n}\nclass ChildCursor {\n    constructor(children, pos, i) {\n        this.children = children;\n        this.pos = pos;\n        this.i = i;\n        this.off = 0;\n    }\n    findPos(pos, bias = 1) {\n        for (;;) {\n            if (pos > this.pos || pos == this.pos &&\n                (bias > 0 || this.i == 0 || this.children[this.i - 1].breakAfter)) {\n                this.off = pos - this.pos;\n                return this;\n            }\n            let next = this.children[--this.i];\n            this.pos -= next.length + next.breakAfter;\n        }\n    }\n}\n\nfunction combineAttrs(source, target) {\n    for (let name in source) {\n        if (name == \"class\" && target.class)\n            target.class += \" \" + source.class;\n        else if (name == \"style\" && target.style)\n            target.style += \";\" + source.style;\n        else\n            target[name] = source[name];\n    }\n    return target;\n}\nfunction attrsEq(a, b) {\n    if (a == b)\n        return true;\n    if (!a || !b)\n        return false;\n    let keysA = Object.keys(a), keysB = Object.keys(b);\n    if (keysA.length != keysB.length)\n        return false;\n    for (let key of keysA) {\n        if (keysB.indexOf(key) == -1 || a[key] !== b[key])\n            return false;\n    }\n    return true;\n}\nfunction updateAttrs(dom, prev, attrs) {\n    if (prev)\n        for (let name in prev)\n            if (!(attrs && name in attrs))\n                dom.removeAttribute(name);\n    if (attrs)\n        for (let name in attrs)\n            if (!(prev && prev[name] == attrs[name]))\n                dom.setAttribute(name, attrs[name]);\n}\n\nconst none$1 = [];\nclass InlineView extends ContentView {\n    match(other) { return false; }\n    get children() { return none$1; }\n    getSide() { return 0; }\n}\nconst MaxJoinLen = 256;\nclass TextView extends InlineView {\n    constructor(text, tagName, clss, attrs) {\n        super();\n        this.text = text;\n        this.tagName = tagName;\n        this.attrs = attrs;\n        this.textDOM = null;\n        this.class = clss;\n    }\n    get length() { return this.text.length; }\n    createDOM(textDOM) {\n        let tagName = this.tagName || (this.attrs || this.class ? \"span\" : null);\n        this.textDOM = textDOM || document.createTextNode(this.text);\n        if (tagName) {\n            let dom = document.createElement(tagName);\n            dom.appendChild(this.textDOM);\n            if (this.class)\n                dom.className = this.class;\n            if (this.attrs)\n                for (let name in this.attrs)\n                    dom.setAttribute(name, this.attrs[name]);\n            this.setDOM(dom);\n        }\n        else {\n            this.setDOM(this.textDOM);\n        }\n    }\n    sync() {\n        if (!this.dom)\n            this.createDOM();\n        if (this.textDOM.nodeValue != this.text) {\n            this.textDOM.nodeValue = this.text;\n            let dom = this.dom;\n            if (this.textDOM != dom && (this.dom.firstChild != this.textDOM || dom.lastChild != this.textDOM)) {\n                while (dom.firstChild)\n                    dom.removeChild(dom.firstChild);\n                dom.appendChild(this.textDOM);\n            }\n        }\n    }\n    reuseDOM(dom) {\n        if (dom.nodeType != 3)\n            return false;\n        this.createDOM(dom);\n        return true;\n    }\n    merge(from, to = this.length, source = null) {\n        if (source &&\n            (!(source instanceof TextView) ||\n                source.tagName != this.tagName || source.class != this.class ||\n                !attrsEq(source.attrs, this.attrs) || this.length - (to - from) + source.length > MaxJoinLen))\n            return false;\n        this.text = this.text.slice(0, from) + (source ? source.text : \"\") + this.text.slice(to);\n        this.markDirty();\n        return true;\n    }\n    slice(from, to = this.length) {\n        return new TextView(this.text.slice(from, to), this.tagName, this.class, this.attrs);\n    }\n    localPosFromDOM(node, offset) {\n        return node == this.textDOM ? offset : offset ? this.text.length : 0;\n    }\n    domAtPos(pos) { return new DOMPos(this.textDOM, pos); }\n    domBoundsAround(from, to, offset) {\n        return { from: offset, to: offset + this.length, startDOM: this.dom, endDOM: this.dom.nextSibling };\n    }\n    coordsAt(pos) {\n        return textCoords(this.textDOM, pos);\n    }\n}\nfunction textCoords(text, pos) {\n    let range = document.createRange();\n    if (browser.chrome || browser.gecko) {\n        // These browsers reliably return valid rectangles for empty ranges\n        range.setEnd(text, pos);\n        range.setStart(text, pos);\n        return range.getBoundingClientRect();\n    }\n    else {\n        // Otherwise, get the rectangle around a character and take one side\n        let extend = pos == 0 ? 1 : -1;\n        range.setEnd(text, pos + (extend > 0 ? 1 : 0));\n        range.setStart(text, pos - (extend < 0 ? 1 : 0));\n        let rect = range.getBoundingClientRect();\n        let x = extend < 0 ? rect.right : rect.left;\n        return { left: x, right: x, top: rect.top, bottom: rect.bottom };\n    }\n}\n// Also used for collapsed ranges that don't have a placeholder widget!\nclass WidgetView extends InlineView {\n    constructor(widget, length, side, open) {\n        super();\n        this.widget = widget;\n        this.length = length;\n        this.side = side;\n        this.open = open;\n    }\n    static create(widget, length, side, open = 0) {\n        return new (widget.customView || WidgetView)(widget, length, side, open);\n    }\n    slice(from, to = this.length) { return WidgetView.create(this.widget, to - from, this.side); }\n    sync() {\n        if (!this.dom || !this.widget.updateDOM(this.dom)) {\n            this.setDOM(this.widget.toDOM(this.editorView));\n            this.dom.contentEditable = \"false\";\n        }\n    }\n    getSide() { return this.side; }\n    merge(from, to = this.length, source = null) {\n        if (source) {\n            if (!(source instanceof WidgetView) || !source.open ||\n                from > 0 && !(source.open & 1 /* Start */) ||\n                to < this.length && !(source.open & 2 /* End */))\n                return false;\n            if (!this.widget.compare(source.widget))\n                throw new Error(\"Trying to merge incompatible widgets\");\n        }\n        this.length = from + (source ? source.length : 0) + (this.length - to);\n        return true;\n    }\n    match(other) {\n        if (other.length == this.length && other instanceof WidgetView && other.side == this.side) {\n            if (this.widget.constructor == other.widget.constructor) {\n                if (!this.widget.eq(other.widget.value))\n                    this.markDirty(true);\n                this.widget = other.widget;\n                return true;\n            }\n        }\n        return false;\n    }\n    ignoreMutation() { return true; }\n    ignoreEvent(event) { return this.widget.ignoreEvent(event); }\n    get overrideDOMText() {\n        if (this.length == 0)\n            return [\"\"];\n        let top = this;\n        while (top.parent)\n            top = top.parent;\n        let view = top.editorView, text = view && view.state.doc, start = this.posAtStart;\n        return text ? text.sliceLines(start, start + this.length) : [\"\"];\n    }\n    domAtPos(pos) {\n        return pos == 0 ? DOMPos.before(this.dom) : DOMPos.after(this.dom, pos == this.length);\n    }\n    domBoundsAround() { return null; }\n    coordsAt(pos) {\n        let rects = this.dom.getClientRects();\n        for (let i = pos > 0 ? rects.length - 1 : 0;; i += (pos > 0 ? -1 : 1)) {\n            let rect = rects[i];\n            if (pos > 0 ? i == 0 : i == rects.length - 1 || rect.top < rect.bottom)\n                return rects[i];\n        }\n        return null;\n    }\n}\nclass CompositionView extends WidgetView {\n    domAtPos(pos) { return new DOMPos(this.widget.value.text, pos); }\n    sync() { if (!this.dom)\n        this.setDOM(this.widget.toDOM(this.editorView)); }\n    ignoreMutation() { return false; }\n    get overrideDOMText() { return null; }\n    coordsAt(pos) { return textCoords(this.widget.value.text, pos); }\n}\n\n/// Widgets added to the content are described by subclasses of this\n/// class. This makes it possible to delay creating of the DOM\n/// structure for a widget until it is needed, and to avoid redrawing\n/// widgets even when the decorations that define them are recreated.\n/// `T` can be a type of value passed to instances of the widget type.\nclass WidgetType {\n    /// Create an instance of this widget type.\n    constructor(\n    /// @internal\n    value) {\n        this.value = value;\n    }\n    /// Compare this instance to another instance of the same class. By\n    /// default, it'll compare the instances' parameters with `===`.\n    eq(value) { return this.value === value; }\n    /// Update a DOM element created by a widget of the same type but\n    /// with a different value to reflect this widget. May return true\n    /// to indicate that it could update, false to indicate it couldn't\n    /// (in which case the widget will be redrawn). The default\n    /// implementation just returns false.\n    updateDOM(_dom) { return false; }\n    /// @internal\n    compare(other) {\n        return this == other || this.constructor == other.constructor && this.eq(other.value);\n    }\n    /// The estimated height this widget will have, to be used when\n    /// estimating the height of content that hasn't been drawn. May\n    /// return -1 to indicate you don't know. The default implementation\n    /// returns -1.\n    get estimatedHeight() { return -1; }\n    /// Can be used to configure which kinds of events inside the widget\n    /// should be ignored by the editor. The default is to ignore all\n    /// events.\n    ignoreEvent(_event) { return true; }\n    //// @internal\n    get customView() { return null; }\n}\n/// The different types of blocks that can occur in an editor view.\nvar BlockType;\n(function (BlockType) {\n    /// A line of text.\n    BlockType[BlockType[\"Text\"] = 0] = \"Text\";\n    /// A block widget associated with the position after it.\n    BlockType[BlockType[\"WidgetBefore\"] = 1] = \"WidgetBefore\";\n    /// A block widget associated with the position before it.\n    BlockType[BlockType[\"WidgetAfter\"] = 2] = \"WidgetAfter\";\n    /// A block widget [replacing](#view.Decoration^replace) a range of content.\n    BlockType[BlockType[\"WidgetRange\"] = 3] = \"WidgetRange\";\n})(BlockType || (BlockType = {}));\n/// A decoration provides information on how to draw or style a piece\n/// of content. You'll usually use it wrapped in a\n/// [`Range`](#rangeset.Range), which adds a start and\n/// end position.\nclass Decoration extends RangeValue {\n    /// @internal\n    constructor(\n    /// @internal\n    startSide, \n    /// @internal\n    endSide, \n    /// @internal\n    widget, \n    /// The config object used to create this decoration.\n    spec) {\n        super();\n        this.startSide = startSide;\n        this.endSide = endSide;\n        this.widget = widget;\n        this.spec = spec;\n    }\n    /// @internal\n    get point() { return false; }\n    /// @internal\n    get heightRelevant() { return false; }\n    /// Create a mark decoration, which influences the styling of the\n    /// text in its range.\n    static mark(spec) {\n        return new MarkDecoration(spec);\n    }\n    /// Create a widget decoration, which adds an element at the given\n    /// position.\n    static widget(spec) {\n        let side = spec.side || 0;\n        if (spec.block)\n            side += (200000000 /* BigBlock */ + 1) * (side > 0 ? 1 : -1);\n        return new PointDecoration(spec, side, side, !!spec.block, spec.widget || null, false);\n    }\n    /// Create a replace decoration which replaces the given range with\n    /// a widget, or simply hides it.\n    static replace(spec) {\n        let block = !!spec.block;\n        let { start, end } = getInclusive(spec);\n        let startSide = block ? -200000000 /* BigBlock */ * (start ? 2 : 1) : 100000000 /* BigInline */ * (start ? -1 : 1);\n        let endSide = block ? 200000000 /* BigBlock */ * (end ? 2 : 1) : 100000000 /* BigInline */ * (end ? 1 : -1);\n        return new PointDecoration(spec, startSide, endSide, block, spec.widget || null, true);\n    }\n    /// Create a line decoration, which can add DOM attributes to the\n    /// line starting at the given position.\n    static line(spec) {\n        return new LineDecoration(spec);\n    }\n    /// Build a [`DecorationSet`](#view.DecorationSet) from the given\n    /// decorated range or ranges.\n    static set(of, sort = false) {\n        return RangeSet.of(of, sort);\n    }\n    /// @internal\n    hasHeight() { return this.widget ? this.widget.estimatedHeight > -1 : false; }\n}\n/// The empty set of decorations.\nDecoration.none = RangeSet.empty;\nclass MarkDecoration extends Decoration {\n    constructor(spec) {\n        let { start, end } = getInclusive(spec);\n        super(100000000 /* BigInline */ * (start ? -1 : 1), 100000000 /* BigInline */ * (end ? 1 : -1), null, spec);\n    }\n    eq(other) {\n        return this == other ||\n            other instanceof MarkDecoration &&\n                this.spec.tagName == other.spec.tagName &&\n                this.spec.class == other.spec.class &&\n                attrsEq(this.spec.attributes || null, other.spec.attributes || null);\n    }\n    range(from, to = from) {\n        if (from >= to)\n            throw new RangeError(\"Mark decorations may not be empty\");\n        return super.range(from, to);\n    }\n}\nclass LineDecoration extends Decoration {\n    constructor(spec) {\n        super(-100000000 /* BigInline */, -100000000 /* BigInline */, null, spec);\n    }\n    get point() { return true; }\n    eq(other) {\n        return other instanceof LineDecoration && attrsEq(this.spec.attributes, other.spec.attributes);\n    }\n    range(from, to = from) {\n        if (to != from)\n            throw new RangeError(\"Line decoration ranges must be zero-length\");\n        return super.range(from, to);\n    }\n}\nLineDecoration.prototype.startMapMode = LineDecoration.prototype.endMapMode = MapMode.TrackBefore;\nclass PointDecoration extends Decoration {\n    constructor(spec, startSide, endSide, block, widget, isReplace) {\n        super(startSide, endSide, widget, spec);\n        this.block = block;\n        this.isReplace = isReplace;\n        if (block) {\n            this.startMapMode = startSide < 0 ? MapMode.TrackBefore : MapMode.TrackAfter;\n            this.endMapMode = endSide < 0 ? MapMode.TrackBefore : MapMode.TrackAfter;\n        }\n        else {\n            this.startMapMode = this.endMapMode = MapMode.TrackDel;\n        }\n    }\n    get point() { return true; }\n    // Only relevant when this.block == true\n    get type() {\n        return this.startSide < this.endSide ? BlockType.WidgetRange\n            : this.startSide < 0 ? BlockType.WidgetBefore : BlockType.WidgetAfter;\n    }\n    get heightRelevant() { return this.block || !!this.widget && this.widget.estimatedHeight >= 5; }\n    eq(other) {\n        return other instanceof PointDecoration &&\n            widgetsEq(this.widget, other.widget) &&\n            this.block == other.block &&\n            this.startSide == other.startSide && this.endSide == other.endSide;\n    }\n    range(from, to = from) {\n        if (this.isReplace && (from > to || (from == to && this.startSide > 0 && this.endSide < 0)))\n            throw new RangeError(\"Invalid range for replacement decoration\");\n        if (!this.isReplace && to != from)\n            throw new RangeError(\"Widget decorations can only create zero-length ranges\");\n        return super.range(from, to);\n    }\n}\nfunction getInclusive(spec) {\n    let { inclusiveStart: start, inclusiveEnd: end } = spec;\n    if (start == null)\n        start = spec.inclusive;\n    if (end == null)\n        end = spec.inclusive;\n    return { start: start || false, end: end || false };\n}\nfunction widgetsEq(a, b) {\n    return a == b || !!(a && b && a.compare(b));\n}\nconst MinRangeGap = 4;\nfunction addRange(from, to, ranges) {\n    let last = ranges.length - 1;\n    if (last >= 0 && ranges[last] + MinRangeGap > from)\n        ranges[last] = Math.max(ranges[last], to);\n    else\n        ranges.push(from, to);\n}\n\nconst theme = Facet.define();\nconst baseThemeID = StyleModule.newName();\nfunction buildTheme(id, spec) {\n    let styles = Object.create(null);\n    for (let prop in spec) {\n        let parts = prop.split(\".\"), selector = \".\" + id + (parts[0] == \"wrap\" ? \"\" : \" \");\n        for (let i = 1; i <= parts.length; i++)\n            selector += \".cm-\" + parts.slice(0, i).join(\"-\");\n        styles[selector] = spec[prop];\n    }\n    return new StyleModule(styles, { generateClasses: false });\n}\n/// Create a set of CSS class names for the given theme selector,\n/// which can be added to a DOM element within an editor to make\n/// themes able to style it. Theme selectors can be single words or\n/// words separated by dot characters. In the latter case, the\n/// returned classes combine those that match the full name and those\n/// that match some prefixfor example `\"panel.search\"` will match\n/// both the theme styles specified as `\"panel.search\"` and those with\n/// just `\"panel\"`. More specific theme styles (with more dots) take\n/// precedence.\nfunction themeClass(selector) {\n    let parts = selector.split(\".\"), result = \"\";\n    for (let i = 1; i <= parts.length; i++)\n        result += (result ? \" \" : \"\") + \"cm-\" + parts.slice(0, i).join(\"-\");\n    return result;\n}\nconst baseTheme = buildTheme(baseThemeID, {\n    wrap: {\n        position: \"relative !important\",\n        boxSizing: \"border-box\",\n        \"&.cm-focused\": {\n            // FIXME it would be great if we could directly use the browser's\n            // default focus outline, but it appears we can't, so this tries to\n            // approximate that\n            outline_fallback: \"1px dotted #212121\",\n            outline: \"5px auto -webkit-focus-ring-color\"\n        },\n        display: \"flex !important\",\n        flexDirection: \"column\"\n    },\n    scroller: {\n        display: \"flex !important\",\n        alignItems: \"flex-start !important\",\n        fontFamily: \"monospace\",\n        lineHeight: 1.4,\n        height: \"100%\",\n        overflowX: \"auto\"\n    },\n    content: {\n        margin: 0,\n        flexGrow: 2,\n        minHeight: \"100%\",\n        display: \"block\",\n        whiteSpace: \"pre\",\n        boxSizing: \"border-box\",\n        padding: \"4px 0\",\n        outline: \"none\",\n        caretColor: \"black\",\n    },\n    line: {\n        display: \"block\",\n        padding: \"0 2px 0 4px\"\n    }\n});\n\nconst LineClass = themeClass(\"line\");\nclass LineView extends ContentView {\n    constructor() {\n        super(...arguments);\n        this.children = [];\n        this.length = 0;\n        this.prevAttrs = undefined;\n        this.attrs = null;\n        this.breakAfter = 0;\n    }\n    // Consumes source\n    merge(from, to, source, takeDeco) {\n        if (source) {\n            if (!(source instanceof LineView))\n                return false;\n            if (!this.dom)\n                source.transferDOM(this); // Reuse source.dom when appropriate\n        }\n        if (takeDeco)\n            this.setDeco(source ? source.attrs : null);\n        let elts = source ? source.children : [];\n        let cur = this.childCursor();\n        let { i: toI, off: toOff } = cur.findPos(to, 1);\n        let { i: fromI, off: fromOff } = cur.findPos(from, -1);\n        let dLen = from - to;\n        for (let view of elts)\n            dLen += view.length;\n        this.length += dLen;\n        // Both from and to point into the same text view\n        if (fromI == toI && fromOff) {\n            let start = this.children[fromI];\n            // Maybe just update that view and be done\n            if (elts.length == 1 && start.merge(fromOff, toOff, elts[0]))\n                return true;\n            if (elts.length == 0) {\n                start.merge(fromOff, toOff, null);\n                return true;\n            }\n            // Otherwise split it, so that we don't have to worry about aliasing front/end afterwards\n            let after = start.slice(toOff);\n            if (after.merge(0, 0, elts[elts.length - 1]))\n                elts[elts.length - 1] = after;\n            else\n                elts.push(after);\n            toI++;\n            toOff = 0;\n        }\n        // Make sure start and end positions fall on node boundaries\n        // (fromOff/toOff are no longer used after this), and that if the\n        // start or end of the elts can be merged with adjacent nodes,\n        // this is done\n        if (toOff) {\n            let end = this.children[toI];\n            if (elts.length && end.merge(0, toOff, elts[elts.length - 1]))\n                elts.pop();\n            else\n                end.merge(0, toOff, null);\n        }\n        else if (toI < this.children.length && elts.length &&\n            this.children[toI].merge(0, 0, elts[elts.length - 1])) {\n            elts.pop();\n        }\n        if (fromOff) {\n            let start = this.children[fromI];\n            if (elts.length && start.merge(fromOff, undefined, elts[0]))\n                elts.shift();\n            else\n                start.merge(fromOff, undefined, null);\n            fromI++;\n        }\n        else if (fromI && elts.length && this.children[fromI - 1].merge(this.children[fromI - 1].length, undefined, elts[0])) {\n            elts.shift();\n        }\n        // Then try to merge any mergeable nodes at the start and end of\n        // the changed range\n        while (fromI < toI && elts.length && this.children[toI - 1].match(elts[elts.length - 1])) {\n            elts.pop();\n            toI--;\n        }\n        while (fromI < toI && elts.length && this.children[fromI].match(elts[0])) {\n            elts.shift();\n            fromI++;\n        }\n        // And if anything remains, splice the child array to insert the new elts\n        if (elts.length || fromI != toI)\n            this.replaceChildren(fromI, toI, elts);\n        return true;\n    }\n    split(at) {\n        let end = new LineView;\n        end.breakAfter = this.breakAfter;\n        if (this.length == 0)\n            return end;\n        let { i, off } = this.childPos(at);\n        if (off) {\n            end.append(this.children[i].slice(off));\n            this.children[i].merge(off, undefined, null);\n            i++;\n        }\n        for (let j = i; j < this.children.length; j++)\n            end.append(this.children[j]);\n        while (i > 0 && this.children[i - 1].length == 0) {\n            this.children[i - 1].parent = null;\n            i--;\n        }\n        this.children.length = i;\n        this.markDirty();\n        this.length = at;\n        return end;\n    }\n    transferDOM(other) {\n        if (!this.dom)\n            return;\n        other.setDOM(this.dom);\n        other.prevAttrs = this.prevAttrs === undefined ? this.attrs : this.prevAttrs;\n        this.prevAttrs = undefined;\n        this.dom = null;\n    }\n    setDeco(attrs) {\n        if (!attrsEq(this.attrs, attrs)) {\n            if (this.dom) {\n                this.prevAttrs = this.attrs;\n                this.markDirty();\n            }\n            this.attrs = attrs;\n        }\n    }\n    // Only called when building a line view in ContentBuilder\n    append(child) {\n        this.children.push(child);\n        child.setParent(this);\n        this.length += child.length;\n    }\n    // Only called when building a line view in ContentBuilder\n    addLineDeco(deco) {\n        let attrs = deco.spec.attributes;\n        if (attrs)\n            this.attrs = combineAttrs(attrs, this.attrs || {});\n    }\n    domAtPos(pos) {\n        let i = 0;\n        for (let off = 0; i < this.children.length; i++) {\n            let child = this.children[i], end = off + child.length;\n            if (end == off && child.getSide() <= 0)\n                continue;\n            if (pos > off && pos < end && child.dom.parentNode == this.dom)\n                return child.domAtPos(pos - off);\n            if (pos <= off)\n                break;\n            off = end;\n        }\n        for (; i > 0; i--) {\n            let before = this.children[i - 1].dom;\n            if (before.parentNode == this.dom)\n                return DOMPos.after(before);\n        }\n        return new DOMPos(this.dom, 0);\n    }\n    // FIXME might need another hack to work around Firefox's behavior\n    // of not actually displaying the cursor even though it's there in\n    // the DOM\n    sync() {\n        if (!this.dom) {\n            this.setDOM(document.createElement(\"div\"));\n            this.dom.className = LineClass;\n            this.prevAttrs = this.attrs ? null : undefined;\n        }\n        if (this.prevAttrs !== undefined) {\n            updateAttrs(this.dom, this.prevAttrs, this.attrs);\n            this.dom.classList.add(LineClass);\n            this.prevAttrs = undefined;\n        }\n        super.sync();\n        let last = this.dom.lastChild;\n        if (!last || (last.nodeName != \"BR\" && !(ContentView.get(last) instanceof TextView))) {\n            let hack = document.createElement(\"BR\");\n            hack.cmIgnore = true;\n            this.dom.appendChild(hack);\n        }\n    }\n    measureTextSize() {\n        if (this.children.length == 0 || this.length > 20)\n            return null;\n        let totalWidth = 0;\n        for (let child of this.children) {\n            if (!(child instanceof TextView))\n                return null;\n            let rects = clientRectsFor(child.dom);\n            if (rects.length != 1)\n                return null;\n            totalWidth += rects[0].width;\n        }\n        return { lineHeight: this.dom.getBoundingClientRect().height,\n            charWidth: totalWidth / this.length };\n    }\n    coordsAt(pos) {\n        for (let off = 0, i = 0; i < this.children.length; i++) {\n            let child = this.children[i], end = off + child.length;\n            if (end >= pos)\n                return child.coordsAt(pos - off);\n            off = end;\n        }\n        return this.dom.lastChild.getBoundingClientRect();\n    }\n    match(other) { return false; }\n    get type() { return BlockType.Text; }\n}\nconst none$2 = [];\nclass BlockWidgetView extends ContentView {\n    constructor(widget, length, type, \n    // This is set by the builder and used to distinguish between\n    // adjacent widgets and parts of the same widget when calling\n    // `merge`. It's kind of silly that it's an instance variable, but\n    // it's hard to route there otherwise.\n    open = 0) {\n        super();\n        this.widget = widget;\n        this.length = length;\n        this.type = type;\n        this.open = open;\n        this.breakAfter = 0;\n    }\n    merge(from, to, source) {\n        if (!(source instanceof BlockWidgetView) || !source.open ||\n            from > 0 && !(source.open & 1 /* Start */) ||\n            to < this.length && !(source.open & 2 /* End */))\n            return false;\n        if (!this.widget.compare(source.widget))\n            throw new Error(\"Trying to merge an open widget with an incompatible node\");\n        this.length = from + source.length + (this.length - to);\n        return true;\n    }\n    domAtPos(pos) {\n        return pos == 0 ? DOMPos.before(this.dom) : DOMPos.after(this.dom, pos == this.length);\n    }\n    split(at) {\n        let len = this.length - at;\n        this.length = at;\n        return new BlockWidgetView(this.widget, len, this.type);\n    }\n    get children() { return none$2; }\n    sync() {\n        if (!this.dom || !this.widget.updateDOM(this.dom)) {\n            this.setDOM(this.widget.toDOM(this.editorView));\n            this.dom.contentEditable = \"false\";\n        }\n    }\n    get overrideDOMText() {\n        return this.parent ? this.parent.view.state.doc.sliceLines(this.posAtStart, this.posAtEnd) : [\"\"];\n    }\n    domBoundsAround() { return null; }\n    match(other) {\n        if (other instanceof BlockWidgetView && other.type == this.type &&\n            other.widget.constructor == this.widget.constructor) {\n            if (!other.widget.eq(this.widget.value))\n                this.markDirty(true);\n            this.widget = other.widget;\n            this.length = other.length;\n            this.breakAfter = other.breakAfter;\n            return true;\n        }\n        return false;\n    }\n}\n\nclass ContentBuilder {\n    constructor(doc, pos, end) {\n        this.doc = doc;\n        this.pos = pos;\n        this.end = end;\n        this.content = [];\n        this.curLine = null;\n        this.breakAtStart = 0;\n        this.text = \"\";\n        this.textOff = 0;\n        this.cursor = doc.iter();\n        this.skip = pos;\n    }\n    posCovered() {\n        if (this.content.length == 0)\n            return !this.breakAtStart && this.doc.lineAt(this.pos).start != this.pos;\n        let last = this.content[this.content.length - 1];\n        return !last.breakAfter && !(last instanceof BlockWidgetView && last.type == BlockType.WidgetBefore);\n    }\n    getLine() {\n        if (!this.curLine)\n            this.content.push(this.curLine = new LineView);\n        return this.curLine;\n    }\n    addWidget(view) {\n        this.curLine = null;\n        this.content.push(view);\n    }\n    finish() {\n        if (!this.posCovered())\n            this.getLine();\n    }\n    buildText(length, tagName, clss, attrs, _ranges) {\n        while (length > 0) {\n            if (this.textOff == this.text.length) {\n                let { value, lineBreak, done } = this.cursor.next(this.skip);\n                this.skip = 0;\n                if (done)\n                    throw new Error(\"Ran out of text content when drawing inline views\");\n                if (lineBreak) {\n                    if (!this.posCovered())\n                        this.getLine();\n                    if (this.content.length)\n                        this.content[this.content.length - 1].breakAfter = 1;\n                    else\n                        this.breakAtStart = 1;\n                    this.curLine = null;\n                    length--;\n                    continue;\n                }\n                else {\n                    this.text = value;\n                    this.textOff = 0;\n                }\n            }\n            let take = Math.min(this.text.length - this.textOff, length);\n            this.getLine().append(new TextView(this.text.slice(this.textOff, this.textOff + take), tagName, clss, attrs));\n            length -= take;\n            this.textOff += take;\n        }\n    }\n    span(from, to, active) {\n        let tagName = null, clss = null;\n        let attrs = null;\n        for (let { spec } of active) {\n            if (spec.tagName)\n                tagName = spec.tagName;\n            if (spec.class)\n                clss = clss ? clss + \" \" + spec.class : spec.class;\n            if (spec.attributes)\n                for (let name in spec.attributes) {\n                    let value = spec.attributes[name];\n                    if (value == null)\n                        continue;\n                    if (name == \"class\") {\n                        clss = clss ? clss + \" \" + value : value;\n                    }\n                    else {\n                        if (!attrs)\n                            attrs = {};\n                        if (name == \"style\" && attrs.style)\n                            value = attrs.style + \";\" + value;\n                        attrs[name] = value;\n                    }\n                }\n        }\n        this.buildText(to - from, tagName, clss, attrs, active);\n        this.pos = to;\n    }\n    point(from, to, deco, openStart, openEnd) {\n        let open = (openStart ? 1 /* Start */ : 0) | (openEnd ? 2 /* End */ : 0);\n        let len = to - from;\n        if (deco instanceof PointDecoration) {\n            if (deco.block) {\n                let { type } = deco;\n                if (type == BlockType.WidgetAfter && !this.posCovered())\n                    this.getLine();\n                this.addWidget(new BlockWidgetView(deco.widget || new NullWidget(\"div\"), len, type, open));\n            }\n            else {\n                this.getLine().append(WidgetView.create(deco.widget || new NullWidget(\"span\"), len, deco.startSide, open));\n            }\n        }\n        else if (this.doc.lineAt(this.pos).start == this.pos) { // Line decoration\n            this.getLine().addLineDeco(deco);\n        }\n        if (len) {\n            // Advance the iterator past the replaced content\n            if (this.textOff + len <= this.text.length) {\n                this.textOff += len;\n            }\n            else {\n                this.skip += len - (this.text.length - this.textOff);\n                this.text = \"\";\n                this.textOff = 0;\n            }\n            this.pos = to;\n        }\n    }\n    static build(text, from, to, decorations) {\n        let builder = new ContentBuilder(text, from, to);\n        RangeSet.spans(decorations, from, to, builder);\n        builder.finish();\n        return builder;\n    }\n}\nclass NullWidget extends WidgetType {\n    toDOM() { return document.createElement(this.value); }\n    updateDOM(elt) { return elt.nodeName.toLowerCase() == this.value; }\n}\n\nconst wrappingWhiteSpace = [\"pre-wrap\", \"normal\", \"pre-line\"];\nclass HeightOracle {\n    constructor() {\n        this.doc = Text.empty;\n        this.lineWrapping = false;\n        this.direction = \"ltr\";\n        this.heightSamples = {};\n        this.lineHeight = 14;\n        this.charWidth = 7;\n        this.lineLength = 30;\n        // Used to track, during updateHeight, if any actual heights changed\n        this.heightChanged = false;\n    }\n    heightForGap(from, to) {\n        let lines = this.doc.lineAt(to).number - this.doc.lineAt(from).number + 1;\n        if (this.lineWrapping)\n            lines += Math.ceil(((to - from) - (lines * this.lineLength * 0.5)) / this.lineLength);\n        return this.lineHeight * lines;\n    }\n    heightForLine(length) {\n        if (!this.lineWrapping)\n            return this.lineHeight;\n        let lines = 1 + Math.max(0, Math.ceil((length - this.lineLength) / (this.lineLength - 5)));\n        return lines * this.lineHeight;\n    }\n    setDoc(doc) { this.doc = doc; return this; }\n    mustRefresh(lineHeights, whiteSpace, direction) {\n        let newHeight = false;\n        for (let i = 0; i < lineHeights.length; i++) {\n            let h = lineHeights[i];\n            if (h < 0) {\n                i++;\n            }\n            else if (!this.heightSamples[Math.floor(h * 10)]) { // Round to .1 pixels\n                newHeight = true;\n                this.heightSamples[Math.floor(h * 10)] = true;\n            }\n        }\n        return newHeight || (wrappingWhiteSpace.indexOf(whiteSpace) > -1) != this.lineWrapping || this.direction != direction;\n    }\n    refresh(whiteSpace, direction, lineHeight, charWidth, lineLength, knownHeights) {\n        let lineWrapping = wrappingWhiteSpace.indexOf(whiteSpace) > -1;\n        let changed = Math.round(lineHeight) != Math.round(this.lineHeight) ||\n            this.lineWrapping != lineWrapping ||\n            this.direction != direction;\n        this.lineWrapping = lineWrapping;\n        this.direction = direction;\n        this.lineHeight = lineHeight;\n        this.charWidth = charWidth;\n        this.lineLength = lineLength;\n        if (changed) {\n            this.heightSamples = {};\n            for (let i = 0; i < knownHeights.length; i++) {\n                let h = knownHeights[i];\n                if (h < 0)\n                    i++;\n                else\n                    this.heightSamples[Math.floor(h * 10)] = true;\n            }\n        }\n        return changed;\n    }\n}\n// This object is used by `updateHeight` to make DOM measurements\n// arrive at the right nides. The `heights` array is a sequence of\n// block heights, starting from position `from`.\nclass MeasuredHeights {\n    constructor(from, heights) {\n        this.from = from;\n        this.heights = heights;\n        this.index = 0;\n    }\n    get more() { return this.index < this.heights.length; }\n}\n/// Record used to represent information about a block-level element\n/// in the editor view.\nclass BlockInfo {\n    /// @internal\n    constructor(\n    /// The start of the element in the document.\n    from, \n    /// The length of the element.\n    length, \n    /// The top position of the element.\n    top, \n    /// Its height.\n    height, \n    /// The type of element this is. When querying lines, this may be\n    /// an array of all the blocks that make up the line.\n    type) {\n        this.from = from;\n        this.length = length;\n        this.top = top;\n        this.height = height;\n        this.type = type;\n    }\n    /// The end of the element as a document position.\n    get to() { return this.from + this.length; }\n    /// The bottom position of the element.\n    get bottom() { return this.top + this.height; }\n    /// @internal\n    join(other) {\n        let detail = (Array.isArray(this.type) ? this.type : [this])\n            .concat(Array.isArray(other.type) ? other.type : [other]);\n        return new BlockInfo(this.from, this.length + other.length, this.top, this.height + other.height, detail);\n    }\n}\nvar QueryType;\n(function (QueryType) {\n    QueryType[QueryType[\"ByPos\"] = 0] = \"ByPos\";\n    QueryType[QueryType[\"ByHeight\"] = 1] = \"ByHeight\";\n    QueryType[QueryType[\"ByPosNoHeight\"] = 2] = \"ByPosNoHeight\";\n})(QueryType || (QueryType = {}));\nclass HeightMap {\n    constructor(length, // The number of characters covered\n    height, // Height of this part of the document\n    flags = 2 /* Outdated */) {\n        this.length = length;\n        this.height = height;\n        this.flags = flags;\n    }\n    get outdated() { return (this.flags & 2 /* Outdated */) > 0; }\n    set outdated(value) { this.flags = (value ? 2 /* Outdated */ : 0) | (this.flags & ~2 /* Outdated */); }\n    setHeight(oracle, height) {\n        if (this.height != height) {\n            this.height = height;\n            oracle.heightChanged = true;\n        }\n    }\n    // Base case is to replace a leaf node, which simply builds a tree\n    // from the new nodes and returns that (HeightMapBranch and\n    // HeightMapGap override this to actually use from/to)\n    replace(_from, _to, nodes) {\n        return HeightMap.of(nodes);\n    }\n    // Again, these are base cases, and are overridden for branch and gap nodes.\n    decomposeLeft(_to, result) { result.push(this); }\n    decomposeRight(_from, result) { result.push(this); }\n    applyChanges(decorations, oldDoc, oracle, changes) {\n        let me = this;\n        for (let i = changes.length - 1; i >= 0; i--) {\n            let { fromA, toA, fromB, toB } = changes[i];\n            let start = me.lineAt(fromA, QueryType.ByPosNoHeight, oldDoc, 0, 0);\n            let end = start.to >= toA ? start : me.lineAt(toA, QueryType.ByPosNoHeight, oldDoc, 0, 0);\n            toB += end.to - toA;\n            toA = end.to;\n            while (i > 0 && start.from <= changes[i - 1].toA) {\n                fromA = changes[i - 1].fromA;\n                fromB = changes[i - 1].fromB;\n                i--;\n                if (fromA < start.from)\n                    start = me.lineAt(fromA, QueryType.ByPosNoHeight, oldDoc, 0, 0);\n            }\n            fromB += start.from - fromA;\n            fromA = start.from;\n            let nodes = NodeBuilder.build(oracle, decorations, fromB, toB);\n            me = me.replace(fromA, toA, nodes);\n        }\n        return me.updateHeight(oracle, 0);\n    }\n    static empty() { return new HeightMapText(0, 0); }\n    // nodes uses null values to indicate the position of line breaks.\n    // There are never line breaks at the start or end of the array, or\n    // two line breaks next to each other, and the array isn't allowed\n    // to be empty (same restrictions as return value from the builder).\n    static of(nodes) {\n        if (nodes.length == 1)\n            return nodes[0];\n        let i = 0, j = nodes.length, before = 0, after = 0;\n        for (;;) {\n            if (i == j) {\n                if (before > after * 2) {\n                    let split = nodes[i - 1];\n                    if (split.break)\n                        nodes.splice(--i, 1, split.left, null, split.right);\n                    else\n                        nodes.splice(--i, 1, split.left, split.right);\n                    j += 1 + split.break;\n                    before -= split.size;\n                }\n                else if (after > before * 2) {\n                    let split = nodes[j];\n                    if (split.break)\n                        nodes.splice(j, 1, split.left, null, split.right);\n                    else\n                        nodes.splice(j, 1, split.left, split.right);\n                    j += 2 + split.break;\n                    after -= split.size;\n                }\n                else {\n                    break;\n                }\n            }\n            else if (before < after) {\n                let next = nodes[i++];\n                if (next)\n                    before += next.size;\n            }\n            else {\n                let next = nodes[--j];\n                if (next)\n                    after += next.size;\n            }\n        }\n        let brk = 0;\n        if (nodes[i - 1] == null) {\n            brk = 1;\n            i--;\n        }\n        else if (nodes[i] == null) {\n            brk = 1;\n            j++;\n        }\n        return new HeightMapBranch(HeightMap.of(nodes.slice(0, i)), brk, HeightMap.of(nodes.slice(j)));\n    }\n}\nHeightMap.prototype.size = 1;\nclass HeightMapBlock extends HeightMap {\n    constructor(length, height, type) {\n        super(length, height);\n        this.type = type;\n    }\n    blockAt(_height, _doc, top, offset) {\n        return new BlockInfo(offset, this.length, top, this.height, this.type);\n    }\n    lineAt(_value, _type, doc, top, offset) {\n        return this.blockAt(0, doc, top, offset);\n    }\n    forEachLine(_from, _to, doc, top, offset, f) {\n        f(this.blockAt(0, doc, top, offset));\n    }\n    updateHeight(oracle, offset = 0, _force = false, measured) {\n        if (measured && measured.from <= offset && measured.more)\n            this.setHeight(oracle, measured.heights[measured.index++]);\n        this.outdated = false;\n        return this;\n    }\n    toString() { return `block(${this.length})`; }\n}\nclass HeightMapText extends HeightMapBlock {\n    constructor(length, height) {\n        super(length, height, BlockType.Text);\n        this.collapsed = 0; // Amount of collapsed content in the line\n        this.widgetHeight = 0; // Maximum inline widget height\n    }\n    replace(_from, _to, nodes) {\n        if (nodes.length == 1 && nodes[0] instanceof HeightMapText && Math.abs(this.length - nodes[0].length) < 10) {\n            nodes[0].height = this.height;\n            return nodes[0];\n        }\n        else {\n            return HeightMap.of(nodes);\n        }\n    }\n    updateHeight(oracle, offset = 0, force = false, measured) {\n        if (measured && measured.from <= offset && measured.more)\n            this.setHeight(oracle, measured.heights[measured.index++]);\n        else if (force || this.outdated)\n            this.setHeight(oracle, Math.max(this.widgetHeight, oracle.heightForLine(this.length - this.collapsed)));\n        this.outdated = false;\n        return this;\n    }\n    toString() {\n        return `line(${this.length}${this.collapsed ? -this.collapsed : \"\"}${this.widgetHeight ? \":\" + this.widgetHeight : \"\"})`;\n    }\n}\nclass HeightMapGap extends HeightMap {\n    constructor(length) { super(length, 0); }\n    lines(doc, offset) {\n        let firstLine = doc.lineAt(offset).number, lastLine = doc.lineAt(offset + this.length).number;\n        return { firstLine, lastLine, lineHeight: this.height / (lastLine - firstLine + 1) };\n    }\n    blockAt(height, doc, top, offset) {\n        let { firstLine, lastLine, lineHeight } = this.lines(doc, offset);\n        let line = Math.max(0, Math.min(lastLine - firstLine, Math.floor((height - top) / lineHeight)));\n        let { start, length } = doc.line(firstLine + line);\n        return new BlockInfo(start, length, top + lineHeight * line, lineHeight, BlockType.Text);\n    }\n    lineAt(value, type, doc, top, offset) {\n        if (type == QueryType.ByHeight)\n            return this.blockAt(value, doc, top, offset);\n        if (type == QueryType.ByPosNoHeight) {\n            let { start, end } = doc.lineAt(value);\n            return new BlockInfo(start, end - start, 0, 0, BlockType.Text);\n        }\n        let { firstLine, lineHeight } = this.lines(doc, offset);\n        let { start, length, number } = doc.lineAt(value);\n        return new BlockInfo(start, length, top + lineHeight * (number - firstLine), lineHeight, BlockType.Text);\n    }\n    forEachLine(from, to, doc, top, offset, f) {\n        let { firstLine, lastLine, lineHeight } = this.lines(doc, offset);\n        for (let line = firstLine; line <= lastLine; line++) {\n            let { start, end } = doc.line(line);\n            if (start > to)\n                break;\n            if (end >= from)\n                f(new BlockInfo(start, end - start, top, top += lineHeight, BlockType.Text));\n        }\n    }\n    replace(from, to, nodes) {\n        let after = this.length - to;\n        if (after > 0) {\n            let last = nodes[nodes.length - 1];\n            if (last instanceof HeightMapGap)\n                nodes[nodes.length - 1] = new HeightMapGap(last.length + after);\n            else\n                nodes.push(null, new HeightMapGap(after - 1));\n        }\n        if (from > 0) {\n            let first = nodes[0];\n            if (first instanceof HeightMapGap)\n                nodes[0] = new HeightMapGap(from + first.length);\n            else\n                nodes.unshift(new HeightMapGap(from - 1), null);\n        }\n        return HeightMap.of(nodes);\n    }\n    decomposeLeft(to, result) {\n        result.push(to == this.length ? this : new HeightMapGap(to));\n    }\n    decomposeRight(from, result) {\n        result.push(from == 0 ? this : new HeightMapGap(this.length - from));\n    }\n    updateHeight(oracle, offset = 0, force = false, measured) {\n        let end = offset + this.length;\n        if (measured && measured.from <= offset + this.length && measured.more) {\n            // Fill in part of this gap with measured lines. We know there\n            // can't be widgets or collapsed ranges in those lines, because\n            // they would already have been added to the heightmap (gaps\n            // only contain plain text).\n            let nodes = [], pos = Math.max(offset, measured.from);\n            if (measured.from > offset)\n                nodes.push(new HeightMapGap(measured.from - offset - 1).updateHeight(oracle, offset));\n            while (pos <= end && measured.more) {\n                let len = oracle.doc.lineAt(pos).length;\n                if (nodes.length)\n                    nodes.push(null);\n                let line = new HeightMapText(len, measured.heights[measured.index++]);\n                line.outdated = false;\n                nodes.push(line);\n                pos += len + 1;\n            }\n            if (pos <= end)\n                nodes.push(null, new HeightMapGap(end - pos).updateHeight(oracle, pos));\n            oracle.heightChanged = true;\n            return HeightMap.of(nodes);\n        }\n        else if (force || this.outdated) {\n            this.setHeight(oracle, oracle.heightForGap(offset, offset + this.length));\n            this.outdated = false;\n        }\n        return this;\n    }\n    toString() { return `gap(${this.length})`; }\n}\nclass HeightMapBranch extends HeightMap {\n    constructor(left, brk, right) {\n        super(left.length + brk + right.length, left.height + right.height, brk | (left.outdated || right.outdated ? 2 /* Outdated */ : 0));\n        this.left = left;\n        this.right = right;\n        this.size = left.size + right.size;\n    }\n    get break() { return this.flags & 1 /* Break */; }\n    blockAt(height, doc, top, offset) {\n        let mid = top + this.left.height;\n        return height < mid || this.right.height == 0 ? this.left.blockAt(height, doc, top, offset)\n            : this.right.blockAt(height, doc, mid, offset + this.left.length + this.break);\n    }\n    lineAt(value, type, doc, top, offset) {\n        let rightTop = top + this.left.height, rightOffset = offset + this.left.length + this.break;\n        let left = type == QueryType.ByHeight ? value < rightTop || this.right.height == 0 : value < rightOffset;\n        let base = left ? this.left.lineAt(value, type, doc, top, offset)\n            : this.right.lineAt(value, type, doc, rightTop, rightOffset);\n        if (this.break || (left ? base.to < rightOffset : base.from > rightOffset))\n            return base;\n        let subQuery = type == QueryType.ByPosNoHeight ? QueryType.ByPosNoHeight : QueryType.ByPos;\n        if (left)\n            return base.join(this.right.lineAt(rightOffset, subQuery, doc, rightTop, rightOffset));\n        else\n            return this.left.lineAt(rightOffset, subQuery, doc, top, offset).join(base);\n    }\n    forEachLine(from, to, doc, top, offset, f) {\n        let rightTop = top + this.left.height, rightOffset = offset + this.left.length + this.break;\n        if (this.break) {\n            if (from < rightOffset)\n                this.left.forEachLine(from, to, doc, top, offset, f);\n            if (to >= rightOffset)\n                this.right.forEachLine(from, to, doc, rightTop, rightOffset, f);\n        }\n        else {\n            let mid = this.lineAt(rightOffset, QueryType.ByPos, doc, top, offset);\n            if (from < mid.from)\n                this.left.forEachLine(from, mid.from - 1, doc, top, offset, f);\n            if (mid.to >= from && mid.from <= to)\n                f(mid);\n            if (to > mid.to)\n                this.right.forEachLine(mid.to + 1, to, doc, rightTop, rightOffset, f);\n        }\n    }\n    replace(from, to, nodes) {\n        let rightStart = this.left.length + this.break;\n        if (to < rightStart)\n            return this.balanced(this.left.replace(from, to, nodes), this.right);\n        if (from > this.left.length)\n            return this.balanced(this.left, this.right.replace(from - rightStart, to - rightStart, nodes));\n        let result = [];\n        if (from > 0)\n            this.decomposeLeft(from, result);\n        let left = result.length;\n        for (let node of nodes)\n            result.push(node);\n        if (from > 0)\n            mergeGaps(result, left - 1);\n        if (to < this.length) {\n            let right = result.length;\n            this.decomposeRight(to, result);\n            mergeGaps(result, right);\n        }\n        return HeightMap.of(result);\n    }\n    decomposeLeft(to, result) {\n        let left = this.left.length;\n        if (to <= left)\n            return this.left.decomposeLeft(to, result);\n        result.push(this.left);\n        if (this.break) {\n            left++;\n            if (to >= left)\n                result.push(null);\n        }\n        if (to > left)\n            this.right.decomposeLeft(to - left, result);\n    }\n    decomposeRight(from, result) {\n        let left = this.left.length, right = left + this.break;\n        if (from >= right)\n            return this.right.decomposeRight(from - right, result);\n        if (from < left)\n            this.left.decomposeRight(from, result);\n        if (this.break && from < right)\n            result.push(null);\n        result.push(this.right);\n    }\n    balanced(left, right) {\n        if (left.size > 2 * right.size || right.size > 2 * left.size)\n            return HeightMap.of(this.break ? [left, null, right] : [left, right]);\n        this.left = left;\n        this.right = right;\n        this.height = left.height + right.height;\n        this.outdated = left.outdated || right.outdated;\n        this.size = left.size + right.size;\n        this.length = left.length + this.break + right.length;\n        return this;\n    }\n    updateHeight(oracle, offset = 0, force = false, measured) {\n        let { left, right } = this, rightStart = offset + left.length + this.break, rebalance = null;\n        if (measured && measured.from <= offset + left.length && measured.more)\n            rebalance = left = left.updateHeight(oracle, offset, force, measured);\n        else\n            left.updateHeight(oracle, offset, force);\n        if (measured && measured.from <= rightStart + right.length && measured.more)\n            rebalance = right = right.updateHeight(oracle, rightStart, force, measured);\n        else\n            right.updateHeight(oracle, rightStart, force);\n        if (rebalance)\n            return this.balanced(left, right);\n        this.height = this.left.height + this.right.height;\n        this.outdated = false;\n        return this;\n    }\n    toString() { return this.left + (this.break ? \" \" : \"-\") + this.right; }\n}\nfunction mergeGaps(nodes, around) {\n    let before, after;\n    if (nodes[around] == null &&\n        (before = nodes[around - 1]) instanceof HeightMapGap &&\n        (after = nodes[around + 1]) instanceof HeightMapGap)\n        nodes.splice(around - 1, 3, new HeightMapGap(before.length + 1 + after.length));\n}\nconst relevantWidgetHeight = 5;\nclass NodeBuilder {\n    constructor(pos, oracle) {\n        this.pos = pos;\n        this.oracle = oracle;\n        this.nodes = [];\n        this.lineStart = -1;\n        this.lineEnd = -1;\n        this.covering = null;\n        this.writtenTo = pos;\n    }\n    get isCovered() {\n        return this.covering && this.nodes[this.nodes.length - 1] == this.covering;\n    }\n    span(_from, to) {\n        if (this.lineStart > -1) {\n            let end = Math.min(to, this.lineEnd), last = this.nodes[this.nodes.length - 1];\n            if (last instanceof HeightMapText)\n                last.length += end - this.pos;\n            else if (end > this.pos || !this.isCovered)\n                this.nodes.push(new HeightMapText(end - this.pos, -1));\n            this.writtenTo = end;\n            if (to > end) {\n                this.nodes.push(null);\n                this.writtenTo++;\n                this.lineStart = -1;\n            }\n        }\n        this.pos = to;\n    }\n    point(from, to, deco) {\n        if (from < to || deco.heightRelevant) {\n            let height = deco.widget ? Math.max(0, deco.widget.estimatedHeight) : 0;\n            let len = to - from;\n            if (deco.block) {\n                this.addBlock(new HeightMapBlock(len, height, deco.type));\n            }\n            else if (len || height >= relevantWidgetHeight) {\n                this.addLineDeco(height, len);\n            }\n        }\n        else if (to > from) {\n            this.span(from, to);\n        }\n        if (this.lineEnd > -1 && this.lineEnd < this.pos)\n            this.lineEnd = this.oracle.doc.lineAt(this.pos).end;\n    }\n    enterLine() {\n        if (this.lineStart > -1)\n            return;\n        let { start, end } = this.oracle.doc.lineAt(this.pos);\n        this.lineStart = start;\n        this.lineEnd = end;\n        if (this.writtenTo < start) {\n            if (this.writtenTo < start - 1 || this.nodes[this.nodes.length - 1] == null)\n                this.nodes.push(new HeightMapGap(start - this.writtenTo - 1));\n            this.nodes.push(null);\n        }\n        if (this.pos > start)\n            this.nodes.push(new HeightMapText(this.pos - start, -1));\n        this.writtenTo = this.pos;\n    }\n    ensureLine() {\n        this.enterLine();\n        let last = this.nodes.length ? this.nodes[this.nodes.length - 1] : null;\n        if (last instanceof HeightMapText)\n            return last;\n        let line = new HeightMapText(0, -1);\n        this.nodes.push(line);\n        return line;\n    }\n    addBlock(block) {\n        this.enterLine();\n        if (block.type == BlockType.WidgetAfter && !this.isCovered)\n            this.ensureLine();\n        this.nodes.push(block);\n        this.writtenTo = this.pos = this.pos + block.length;\n        if (block.type != BlockType.WidgetBefore)\n            this.covering = block;\n    }\n    addLineDeco(height, length) {\n        let line = this.ensureLine();\n        line.length += length;\n        line.collapsed += length;\n        line.widgetHeight = Math.max(line.widgetHeight, height);\n        this.writtenTo = this.pos = this.pos + length;\n    }\n    finish(from) {\n        let last = this.nodes.length == 0 ? null : this.nodes[this.nodes.length - 1];\n        if (this.lineStart > -1 && !(last instanceof HeightMapText) && !this.isCovered)\n            this.nodes.push(new HeightMapText(0, -1));\n        else if (this.writtenTo < this.pos || last == null)\n            this.nodes.push(new HeightMapGap(this.pos - this.writtenTo));\n        let pos = from;\n        for (let node of this.nodes) {\n            if (node instanceof HeightMapText)\n                node.updateHeight(this.oracle, pos);\n            pos += node ? node.length : 1;\n        }\n        return this.nodes;\n    }\n    // Always called with a region that on both sides either stretches\n    // to a line break or the end of the document.\n    // The returned array uses null to indicate line breaks, but never\n    // starts or ends in a line break, or has multiple line breaks next\n    // to each other.\n    static build(oracle, decorations, from, to) {\n        let builder = new NodeBuilder(from, oracle);\n        RangeSet.spans(decorations, from, to, builder);\n        return builder.finish(from);\n    }\n    get minPointSize() { return 0; }\n}\nfunction heightRelevantDecoChanges(a, b, diff, length) {\n    let comp = new DecorationComparator();\n    RangeSet.compare(a, b, diff, length, comp);\n    return comp.changes;\n}\nclass DecorationComparator {\n    constructor() {\n        this.changes = [];\n    }\n    compareRange() { }\n    comparePoint(from, to, a, b) {\n        if (from < to || a && a.heightRelevant || b && b.heightRelevant)\n            addRange(from, to, this.changes);\n    }\n    get minPointSize() { return 0; }\n}\n\nconst none$3 = [];\nconst domEventHandlers = Facet.define();\nconst clickAddsSelectionRange = Facet.define();\nconst dragMovesSelection = Facet.define();\n/// Plugin fields are a mechanism for allowing plugins to provide\n/// values that can be retrieved through the\n/// [`pluginValues`](#view.EditorView.pluginValues) view method.\nclass PluginField {\n    static define() { return new PluginField(); }\n}\n/// Plugins can provide additional scroll margins (space around the\n/// sides of the scrolling element that should be considered\n/// invisible) through this field. This can be useful when the\n/// plugin introduces elements that cover part of that element (for\n/// example a horizontally fixed gutter).\nPluginField.scrollMargins = PluginField.define();\nlet nextPluginID = 0;\nconst viewPlugin = Facet.define();\n/// View plugins associate stateful values with a view. They can\n/// influence the way the content is drawn, and are notified of things\n/// that happen in the view.\nclass ViewPlugin {\n    constructor(\n    /// @internal\n    id, \n    /// @internal\n    create, \n    /// @internal\n    fields) {\n        this.id = id;\n        this.create = create;\n        this.fields = fields;\n        this.extension = viewPlugin.of(this);\n    }\n    /// Define a plugin from a constructor function that creates the\n    /// plugin's value, given an editor view.\n    static define(create) {\n        return new ViewPlugin(nextPluginID++, create, []);\n    }\n    /// Create a plugin for a class whose constructor takes a single\n    /// editor view as argument.\n    static fromClass(cls) {\n        return ViewPlugin.define(view => new cls(view));\n    }\n    /// Create a new version of this plugin that provides a given\n    /// [plugin field](#view.PluginField).\n    provide(field, get) {\n        return new ViewPlugin(this.id, this.create, this.fields.concat({ field, get }));\n    }\n    decorations(get) {\n        return this.provide(pluginDecorations, get || ((value) => value.decorations));\n    }\n}\n// FIXME somehow ensure that no replacing decorations end up in here\nconst pluginDecorations = PluginField.define();\nclass PluginInstance {\n    constructor(value, spec) {\n        this.value = value;\n        this.spec = spec;\n        this.updateFunc = this.value.update ? this.value.update.bind(this.value) : () => undefined;\n    }\n    static create(spec, view) {\n        let value;\n        try {\n            value = spec.create(view);\n        }\n        catch (e) {\n            console.error(\"CodeMirror plugin crashed:\", e);\n            return PluginInstance.dummy;\n        }\n        return new PluginInstance(value, spec);\n    }\n    takeField(type, target) {\n        for (let { field, get } of this.spec.fields)\n            if (field == type)\n                target.push(get(this.value));\n    }\n    update(update) {\n        try {\n            this.updateFunc(update);\n            return this;\n        }\n        catch (e) {\n            console.error(\"CodeMirror plugin crashed:\", e);\n            if (this.value.destroy)\n                try {\n                    this.value.destroy();\n                }\n                catch (_) { }\n            return PluginInstance.dummy;\n        }\n    }\n    destroy() {\n        try {\n            if (this.value.destroy)\n                this.value.destroy();\n        }\n        catch (e) {\n            console.error(\"CodeMirror plugin crashed:\", e);\n        }\n    }\n}\nPluginInstance.dummy = new PluginInstance({}, ViewPlugin.define(() => ({})));\nconst editorAttributes = Facet.define({\n    combine: values => values.reduce((a, b) => combineAttrs(b, a), {})\n});\nconst contentAttributes = Facet.define({\n    combine: values => values.reduce((a, b) => combineAttrs(b, a), {})\n});\n// Provide decorations\nconst decorations = Facet.define();\nconst styleModule = Facet.define();\nconst phrases = Facet.define();\n/// View [plugins](#view.ViewPlugin) are given instances of this\n/// class, which describe what happened, whenever the view is updated.\nclass ViewUpdate {\n    /// @internal\n    constructor(\n    /// The editor view that the update is associated with.\n    view, \n    /// The new editor state.\n    state, \n    /// The transactions involved in the update. May be empty.\n    transactions = none$3) {\n        this.view = view;\n        this.state = state;\n        this.transactions = transactions;\n        /// @internal\n        this.flags = 0;\n        this.changes = transactions.reduce((chs, tr) => chs.appendSet(tr.changes), ChangeSet.empty);\n        this.prevState = view.state;\n        let focus = view.hasFocus;\n        if (focus != view.inputState.notifiedFocused) {\n            view.inputState.notifiedFocused = focus;\n            this.flags != 1 /* Focus */;\n        }\n        if (this.docChanged)\n            this.flags |= 2 /* Height */;\n    }\n    /// Tells you whether the viewport changed in this update.\n    get viewportChanged() {\n        return (this.flags & 4 /* Viewport */) > 0;\n    }\n    /// Indicates whether the line height in the editor changed in this update.\n    get heightChanged() {\n        return (this.flags & 2 /* Height */) > 0;\n    }\n    /// True when this update indicates a focus change.\n    get focusChanged() {\n        return (this.flags & 1 /* Focus */) > 0;\n    }\n    /// Whether the document changed in this update.\n    get docChanged() {\n        return this.transactions.some(tr => tr.docChanged);\n    }\n    /// Whether the selection was explicitly set in this update.\n    get selectionSet() {\n        return this.transactions.some(tr => tr.selectionSet);\n    }\n    /// @internal\n    get empty() { return this.flags == 0 && this.transactions.length == 0; }\n}\n\nfunction visiblePixelRange(dom, paddingTop) {\n    let rect = dom.getBoundingClientRect();\n    let left = Math.max(0, rect.left), right = Math.min(innerWidth, rect.right);\n    let top = Math.max(0, rect.top), bottom = Math.min(innerHeight, rect.bottom);\n    for (let parent = dom.parentNode; parent;) { // (Cast to any because TypeScript is useless with Node types)\n        if (parent.nodeType == 1) {\n            if (parent.scrollHeight > parent.clientHeight || parent.scrollWidth > parent.clientWidth) {\n                let parentRect = parent.getBoundingClientRect();\n                left = Math.max(left, parentRect.left);\n                right = Math.min(right, parentRect.right);\n                top = Math.max(top, parentRect.top);\n                bottom = Math.min(bottom, parentRect.bottom);\n            }\n            parent = parent.parentNode;\n        }\n        else if (parent.nodeType == 11) { // Shadow root\n            parent = parent.host;\n        }\n        else {\n            break;\n        }\n    }\n    return { left: left - rect.left, right: right - rect.left,\n        top: top - (rect.top + paddingTop), bottom: bottom - (rect.top + paddingTop) };\n}\n// Line gaps are placeholder widgets used to hide pieces of overlong\n// lines within the viewport, as a kludge to keep the editor\n// responsive when a ridiculously long line is loaded into it.\nclass LineGap {\n    constructor(from, to, size) {\n        this.from = from;\n        this.to = to;\n        this.size = size;\n    }\n    static same(a, b) {\n        if (a.length != b.length)\n            return false;\n        for (let i = 0; i < a.length; i++) {\n            let gA = a[i], gB = b[i];\n            if (gA.from != gB.from || gA.to != gB.to || gA.size != gB.size)\n                return false;\n        }\n        return true;\n    }\n    draw(wrapping) {\n        return Decoration.replace({ widget: new LineGapWidget({ size: this.size, vertical: wrapping }) }).range(this.from, this.to);\n    }\n}\nclass LineGapWidget extends WidgetType {\n    toDOM() {\n        let elt = document.createElement(\"div\");\n        if (this.value.vertical) {\n            elt.style.height = this.value.size + \"px\";\n        }\n        else {\n            elt.style.width = this.value.size + \"px\";\n            elt.style.height = \"2px\";\n            elt.style.display = \"inline-block\";\n        }\n        return elt;\n    }\n    eq(other) { return this.value.size == other.size && this.value.vertical == other.vertical; }\n    get estimatedHeight() { return this.value.vertical ? this.value.size : -1; }\n}\nclass ViewState {\n    constructor(state) {\n        this.state = state;\n        // These are contentDOM-local coordinates\n        this.pixelViewport = { left: 0, right: window.innerWidth, top: 0, bottom: 0 };\n        this.paddingTop = 0;\n        this.paddingBottom = 0;\n        this.heightOracle = new HeightOracle;\n        this.heightMap = HeightMap.empty();\n        this.scrollTo = -1;\n        // Briefly set to true when printing, to disable viewport limiting\n        this.printing = false;\n        this.visibleRanges = [];\n        this.heightMap = this.heightMap.applyChanges(state.facet(decorations), Text.empty, this.heightOracle.setDoc(state.doc), [new ChangedRange(0, 0, 0, state.doc.length)]);\n        this.viewport = this.getViewport(0, -1);\n        this.lineGaps = this.ensureLineGaps([]);\n        this.lineGapDeco = Decoration.set(this.lineGaps.map(gap => gap.draw(false)));\n        this.computeVisibleRanges();\n    }\n    update(update, scrollTo = -1) {\n        let prev = this.state;\n        this.state = update.state;\n        let newDeco = this.state.facet(decorations);\n        let contentChanges = update.changes.changedRanges();\n        let heightChanges = extendWithRanges(contentChanges, heightRelevantDecoChanges(update.prevState.facet(decorations), newDeco, update ? contentChanges : [], this.state.doc.length));\n        let prevHeight = this.heightMap.height;\n        this.heightMap = this.heightMap.applyChanges(newDeco, prev.doc, this.heightOracle.setDoc(this.state.doc), heightChanges);\n        if (this.heightMap.height != prevHeight)\n            update.flags |= 2 /* Height */;\n        let viewport = heightChanges.length ? this.mapViewport(this.viewport, update.changes) : this.viewport;\n        if (!viewport || scrollTo > -1 && (scrollTo < viewport.from || scrollTo > viewport.to) ||\n            !this.viewportIsCovering(viewport))\n            viewport = this.getViewport(0, scrollTo);\n        if (!viewport.eq(this.viewport)) {\n            this.viewport = viewport;\n            update.flags |= 4 /* Viewport */;\n        }\n        if (this.lineGaps.length || this.viewport.to - this.viewport.from > 15000 /* MinViewPort */)\n            update.flags |= this.updateLineGaps(this.ensureLineGaps(this.mapLineGaps(this.lineGaps, update.changes)));\n        this.computeVisibleRanges();\n        if (scrollTo > -1)\n            this.scrollTo = scrollTo;\n    }\n    measure(docView, repeated) {\n        let dom = docView.dom, whiteSpace = \"\", direction = \"ltr\";\n        if (!repeated) {\n            // Vertical padding\n            let style = window.getComputedStyle(dom);\n            whiteSpace = style.whiteSpace, direction = (style.direction || \"ltr\");\n            this.paddingTop = parseInt(style.paddingTop) || 0;\n            this.paddingBottom = parseInt(style.paddingBottom) || 0;\n        }\n        // Pixel viewport\n        let pixelViewport = this.printing ? { top: -1e8, bottom: 1e8, left: -1e8, right: 1e8 } : visiblePixelRange(dom, this.paddingTop);\n        let dTop = pixelViewport.top - this.pixelViewport.top, dBottom = pixelViewport.bottom - this.pixelViewport.bottom;\n        this.pixelViewport = pixelViewport;\n        if (this.pixelViewport.bottom <= this.pixelViewport.top ||\n            this.pixelViewport.right <= this.pixelViewport.left)\n            return 0;\n        let lineHeights = docView.measureVisibleLineHeights();\n        let refresh = false, bias = 0;\n        if (!repeated) {\n            if (this.heightOracle.mustRefresh(lineHeights, whiteSpace, direction)) {\n                let { lineHeight, charWidth } = docView.measureTextSize();\n                refresh = this.heightOracle.refresh(whiteSpace, direction, lineHeight, charWidth, (docView.dom).clientWidth / charWidth, lineHeights);\n                if (refresh)\n                    docView.minWidth = 0;\n            }\n            if (dTop > 0 && dBottom > 0)\n                bias = Math.max(dTop, dBottom);\n            else if (dTop < 0 && dBottom < 0)\n                bias = Math.min(dTop, dBottom);\n        }\n        this.heightOracle.heightChanged = false;\n        this.heightMap = this.heightMap.updateHeight(this.heightOracle, 0, refresh, new MeasuredHeights(this.viewport.from, lineHeights));\n        let result = this.heightOracle.heightChanged ? 2 /* Height */ : 0;\n        let scrollTo = this.scrollTo;\n        this.scrollTo = -1;\n        if (!this.viewportIsCovering(this.viewport, bias) ||\n            scrollTo > -1 && (scrollTo < this.viewport.from || scrollTo > this.viewport.to)) {\n            this.viewport = this.getViewport(bias, scrollTo);\n            result |= 4 /* Viewport */;\n        }\n        if (this.lineGaps.length || this.viewport.to - this.viewport.from > 15000 /* MinViewPort */)\n            result |= this.updateLineGaps(this.ensureLineGaps(refresh ? [] : this.lineGaps));\n        this.computeVisibleRanges();\n        if (scrollTo > -1)\n            docView.scrollPosIntoView(scrollTo); // FIXME return instead?\n        return result;\n    }\n    getViewport(bias, scrollTo) {\n        // This will divide VP.Margin between the top and the\n        // bottom, depending on the bias (the change in viewport position\n        // since the last update). It'll hold a number between 0 and 1\n        let marginTop = 0.5 - Math.max(-0.5, Math.min(0.5, bias / 1000 /* Margin */ / 2));\n        let map = this.heightMap, doc = this.state.doc, { top, bottom } = this.pixelViewport;\n        let viewport = new Viewport(map.lineAt(top - marginTop * 1000 /* Margin */, QueryType.ByHeight, doc, 0, 0).from, map.lineAt(bottom + (1 - marginTop) * 1000 /* Margin */, QueryType.ByHeight, doc, 0, 0).to);\n        // If scrollTo is > -1, make sure the viewport includes that position\n        if (scrollTo > -1) {\n            if (scrollTo < viewport.from) {\n                let { top: newTop } = map.lineAt(scrollTo, QueryType.ByPos, doc, 0, 0);\n                viewport = new Viewport(map.lineAt(newTop - 1000 /* Margin */ / 2, QueryType.ByHeight, doc, 0, 0).from, map.lineAt(newTop + (bottom - top) + 1000 /* Margin */ / 2, QueryType.ByHeight, doc, 0, 0).to);\n            }\n            else if (scrollTo > viewport.to) {\n                let { bottom: newBottom } = map.lineAt(scrollTo, QueryType.ByPos, doc, 0, 0);\n                viewport = new Viewport(map.lineAt(newBottom - (bottom - top) - 1000 /* Margin */ / 2, QueryType.ByHeight, doc, 0, 0).from, map.lineAt(newBottom + 1000 /* Margin */ / 2, QueryType.ByHeight, doc, 0, 0).to);\n            }\n        }\n        return viewport;\n    }\n    mapViewport(viewport, changes) {\n        let from = changes.mapPos(viewport.from, -1), to = changes.mapPos(viewport.to, 1);\n        if ((to - from) - (viewport.to - viewport.from) > 100)\n            return null; // Grew too much, recompute\n        return new Viewport(this.heightMap.lineAt(from, QueryType.ByPos, this.state.doc, 0, 0).from, this.heightMap.lineAt(to, QueryType.ByPos, this.state.doc, 0, 0).to);\n    }\n    viewportIsCovering({ from, to }, bias = 0) {\n        let { top } = this.heightMap.lineAt(from, QueryType.ByPos, this.state.doc, 0, 0);\n        let { bottom } = this.heightMap.lineAt(to, QueryType.ByPos, this.state.doc, 0, 0);\n        return (from == 0 || top <= this.pixelViewport.top - Math.max(10 /* MinCoverMargin */, Math.min(-bias, 250 /* MaxCoverMargin */))) &&\n            (to == this.state.doc.length ||\n                bottom >= this.pixelViewport.bottom + Math.max(10 /* MinCoverMargin */, Math.min(bias, 250 /* MaxCoverMargin */)));\n    }\n    mapLineGaps(gaps, changes) {\n        if (!gaps.length || !changes.changes.length)\n            return gaps;\n        let mapped = [];\n        for (let gap of gaps)\n            if (!changes.touchesRange(gap.from, gap.to))\n                mapped.push(new LineGap(changes.mapPos(gap.from), changes.mapPos(gap.to), gap.size));\n        return mapped;\n    }\n    // Computes positions in the viewport where the start or end of a\n    // line should be hidden, trying to reuse existing line gaps when\n    // appropriate to avoid unneccesary redraws.\n    // Uses crude character-counting for the positioning and sizing,\n    // since actual DOM coordinates aren't always available and\n    // predictable. Relies on generous margins (see LG.Margin) to hide\n    // the artifacts this might produce from the user.\n    ensureLineGaps(current) {\n        let gaps = [];\n        // This won't work at all in predominantly right-to-left text.\n        if (this.heightOracle.direction != \"ltr\")\n            return gaps;\n        this.heightMap.forEachLine(this.viewport.from, this.viewport.to, this.state.doc, 0, 0, line => {\n            if (line.length < 10000 /* Margin */)\n                return;\n            let structure = lineStructure(line.from, line.to, this.state);\n            if (structure.total < 10000 /* Margin */)\n                return;\n            let viewFrom, viewTo;\n            if (this.heightOracle.lineWrapping) {\n                if (line.from != this.viewport.from)\n                    viewFrom = line.from;\n                else\n                    viewFrom = findPosition(structure, (this.pixelViewport.top - line.top) / line.height);\n                if (line.to != this.viewport.to)\n                    viewTo = line.to;\n                else\n                    viewTo = findPosition(structure, (this.pixelViewport.bottom - line.top) / line.height);\n            }\n            else {\n                let totalWidth = structure.total * this.heightOracle.charWidth;\n                viewFrom = findPosition(structure, this.pixelViewport.left / totalWidth);\n                viewTo = findPosition(structure, this.pixelViewport.right / totalWidth);\n            }\n            let sel = this.state.selection.primary;\n            // Make sure the gap doesn't cover a selection end\n            if (sel.from <= viewFrom && sel.to >= line.from)\n                viewFrom = sel.from;\n            if (sel.from <= line.to && sel.to >= viewTo)\n                viewTo = sel.to;\n            let gapTo = viewFrom - 10000 /* Margin */, gapFrom = viewTo + 10000 /* Margin */;\n            if (gapTo > line.from + 5000 /* HalfMargin */)\n                gaps.push(find(current, gap => gap.from == line.from && gap.to > gapTo - 5000 /* HalfMargin */ && gap.to < gapTo + 5000 /* HalfMargin */) ||\n                    new LineGap(line.from, gapTo, this.gapSize(line, gapTo, true, structure)));\n            if (gapFrom < line.to - 5000 /* HalfMargin */)\n                gaps.push(find(current, gap => gap.to == line.to && gap.from > gapFrom - 5000 /* HalfMargin */ &&\n                    gap.from < gapFrom + 5000 /* HalfMargin */) ||\n                    new LineGap(gapFrom, line.to, this.gapSize(line, gapFrom, false, structure)));\n        });\n        return gaps;\n    }\n    gapSize(line, pos, start, structure) {\n        if (this.heightOracle.lineWrapping) {\n            let height = line.height * findFraction(structure, pos);\n            return start ? height : line.height - height;\n        }\n        else {\n            let ratio = findFraction(structure, pos);\n            return structure.total * this.heightOracle.charWidth * (start ? ratio : 1 - ratio);\n        }\n    }\n    updateLineGaps(gaps) {\n        if (!LineGap.same(gaps, this.lineGaps)) {\n            this.lineGaps = gaps;\n            this.lineGapDeco = Decoration.set(gaps.map(gap => gap.draw(this.heightOracle.lineWrapping)));\n            return 16 /* LineGaps */;\n        }\n        return 0;\n    }\n    computeVisibleRanges() {\n        let deco = this.state.facet(decorations);\n        if (this.lineGaps.length)\n            deco = deco.concat(this.lineGapDeco);\n        let ranges = [];\n        RangeSet.spans(deco, this.viewport.from, this.viewport.to, {\n            span(from, to) { ranges.push({ from, to }); },\n            point() { },\n            minPointSize: 20\n        });\n        this.visibleRanges = ranges;\n    }\n    lineAt(pos, editorTop) {\n        return this.heightMap.lineAt(pos, QueryType.ByPos, this.state.doc, editorTop + this.paddingTop, 0);\n    }\n    lineAtHeight(height, editorTop) {\n        return this.heightMap.lineAt(height, QueryType.ByHeight, this.state.doc, editorTop + this.paddingTop, 0);\n    }\n    blockAtHeight(height, editorTop) {\n        return this.heightMap.blockAt(height, this.state.doc, editorTop + this.paddingTop, 0);\n    }\n    forEachLine(from, to, f, editorTop) {\n        return this.heightMap.forEachLine(from, to, this.state.doc, editorTop + this.paddingTop, 0, f);\n    }\n}\n/// Indicates the range of the document that is in the visible\n/// viewport.\nclass Viewport {\n    constructor(from, to) {\n        this.from = from;\n        this.to = to;\n    }\n    eq(b) { return this.from == b.from && this.to == b.to; }\n}\nfunction extendWithRanges(diff, ranges) {\n    if (ranges.length == 0)\n        return diff;\n    let result = [];\n    for (let dI = 0, rI = 0, posA = 0, posB = 0;; dI++) {\n        let next = dI == diff.length ? null : diff[dI], off = posA - posB;\n        let end = next ? next.fromB : 1e9;\n        while (rI < ranges.length && ranges[rI] < end) {\n            let from = ranges[rI], to = ranges[rI + 1];\n            let fromB = Math.max(posB, from), toB = Math.min(end, to);\n            if (fromB <= toB)\n                new ChangedRange(fromB + off, toB + off, fromB, toB).addToSet(result);\n            if (to > end)\n                break;\n            else\n                rI += 2;\n        }\n        if (!next)\n            return result;\n        new ChangedRange(next.fromA, next.toA, next.fromB, next.toB).addToSet(result);\n        posA = next.toA;\n        posB = next.toB;\n    }\n}\nfunction lineStructure(from, to, state) {\n    let ranges = [], pos = 0, total = 0;\n    RangeSet.spans(state.facet(decorations), from, to, {\n        span() { },\n        point(from, to) {\n            if (from > pos) {\n                ranges.push({ from: pos, to: from });\n                total += to - pos;\n            }\n            pos = to;\n        },\n        minPointSize: 20 // We're only interested in collapsed ranges of a significant size\n    });\n    if (pos < to) {\n        ranges.push({ from: pos, to });\n        total += to - pos;\n    }\n    return { total, ranges };\n}\nfunction findPosition({ total, ranges }, ratio) {\n    if (ratio <= 0)\n        return ranges[0].from;\n    if (ratio >= 1)\n        return ranges[ranges.length - 1].to;\n    let dist = Math.floor(total * ratio);\n    for (let i = 0;; i++) {\n        let { from, to } = ranges[i], size = to - from;\n        if (dist <= size)\n            return from + dist;\n        dist -= size;\n    }\n}\nfunction findFraction(structure, pos) {\n    let counted = 0;\n    for (let { from, to } of structure.ranges) {\n        if (pos <= to) {\n            counted += pos - from;\n            break;\n        }\n        counted += to - from;\n    }\n    return counted / structure.total;\n}\nfunction find(array, f) {\n    for (let val of array)\n        if (f(val))\n            return val;\n    return undefined;\n}\n\nconst none$4 = [];\nclass DocView extends ContentView {\n    constructor(view) {\n        super();\n        this.view = view;\n        this.viewports = none$4;\n        this.compositionDeco = Decoration.none;\n        this.decorations = [];\n        this.selectionDirty = null;\n        // Track a minimum width for the editor. When measuring sizes in\n        // checkLayout, this is updated to point at the width of a given\n        // element and its extent in the document. When a change happens in\n        // that range, these are reset. That way, once we've seen a\n        // line/element of a given length, we keep the editor wide enough to\n        // fit at least that element, until it is changed, at which point we\n        // forget it again.\n        this.minWidth = 0;\n        this.minWidthFrom = 0;\n        this.minWidthTo = 0;\n        // Track whether the DOM selection was set in a lossy way, so that\n        // we don't mess it up when reading it back it\n        this.impreciseAnchor = null;\n        this.impreciseHead = null;\n        this.setDOM(view.contentDOM);\n        this.children = [new LineView];\n        this.children[0].setParent(this);\n        this.updateInner([new ChangedRange(0, 0, 0, view.state.doc.length)], this.updateDeco(), 0);\n    }\n    get root() { return this.view.root; }\n    get editorView() { return this.view; }\n    get length() { return this.view.state.doc.length; }\n    // Update the document view to a given state. scrollIntoView can be\n    // used as a hint to compute a new viewport that includes that\n    // position, if we know the editor is going to scroll that position\n    // into view.\n    update(update) {\n        var _a;\n        let changedRanges = update.changes.changedRanges();\n        if (this.minWidth > 0 && changedRanges.length) {\n            if (!changedRanges.every(({ fromA, toA }) => toA < this.minWidthFrom || fromA > this.minWidthTo)) {\n                this.minWidth = 0;\n            }\n            else {\n                this.minWidthFrom = ChangedRange.mapPos(this.minWidthFrom, 1, changedRanges);\n                this.minWidthTo = ChangedRange.mapPos(this.minWidthTo, 1, changedRanges);\n            }\n        }\n        // When the DOM nodes around the selection are moved to another\n        // parent, Chrome sometimes reports a different selection through\n        // getSelection than the one that it actually shows to the user.\n        // This forces a selection update when lines are joined to work\n        // around that. Issue #54\n        let forceSelection = browser.chrome && !this.compositionDeco.size && update &&\n            update.changes.changes.some(ch => ch.text.length > 1);\n        if (!((_a = this.view.inputState) === null || _a === void 0 ? void 0 : _a.composing))\n            this.compositionDeco = Decoration.none;\n        else if (update.transactions.length)\n            this.compositionDeco = computeCompositionDeco(this.view, changedRanges);\n        let prevDeco = this.decorations, deco = this.updateDeco();\n        let decoDiff = findChangedDeco(prevDeco, deco, changedRanges, update.state.doc.length);\n        changedRanges = extendWithRanges(changedRanges, decoDiff);\n        if (this.dirty == 0 /* Not */ && changedRanges.length == 0 &&\n            !(update.flags & (4 /* Viewport */ | 16 /* LineGaps */)) &&\n            update.state.selection.primary.from >= this.view.viewport.from &&\n            update.state.selection.primary.to <= this.view.viewport.to) {\n            this.updateSelection(forceSelection);\n            return false;\n        }\n        else {\n            this.updateInner(changedRanges, deco, update.prevState.doc.length, forceSelection);\n            return true;\n        }\n    }\n    // Used both by update and checkLayout do perform the actual DOM\n    // update\n    updateInner(changes, deco, oldLength, forceSelection = false) {\n        this.updateChildren(changes, deco, oldLength);\n        this.view.observer.ignore(() => {\n            // Lock the height during redrawing, since Chrome sometimes\n            // messes with the scroll position during DOM mutation (though\n            // no relayout is triggered and I cannot imagine how it can\n            // recompute the scroll position without a layout)\n            this.dom.style.height = this.view.viewState.heightMap.height + \"px\";\n            this.dom.style.minWidth = this.minWidth ? this.minWidth + \"px\" : \"\";\n            this.sync();\n            this.dirty = 0 /* Not */;\n            this.updateSelection(forceSelection);\n            this.dom.style.height = \"\";\n        });\n    }\n    updateChildren(changes, deco, oldLength) {\n        let cursor = this.childCursor(oldLength);\n        for (let i = changes.length - 1;; i--) {\n            let next = i >= 0 ? changes[i] : null;\n            if (!next)\n                break;\n            let { fromA, toA, fromB, toB } = next;\n            let { content, breakAtStart } = ContentBuilder.build(this.view.state.doc, fromB, toB, deco);\n            let { i: toI, off: toOff } = cursor.findPos(toA, 1);\n            let { i: fromI, off: fromOff } = cursor.findPos(fromA, -1);\n            this.replaceRange(fromI, fromOff, toI, toOff, content, breakAtStart);\n        }\n    }\n    replaceRange(fromI, fromOff, toI, toOff, content, breakAtStart) {\n        let before = this.children[fromI], last = content.length ? content[content.length - 1] : null;\n        let breakAtEnd = last ? last.breakAfter : breakAtStart;\n        // Change within a single line\n        if (fromI == toI && !breakAtStart && !breakAtEnd && content.length < 2 &&\n            before.merge(fromOff, toOff, content.length ? last : null, fromOff == 0))\n            return;\n        let after = this.children[toI];\n        // Make sure the end of the line after the update is preserved in `after`\n        if (toOff < after.length || after.children.length && after.children[after.children.length - 1].length == 0) {\n            // If we're splitting a line, separate part of the start line to\n            // avoid that being mangled when updating the start line.\n            if (fromI == toI) {\n                after = after.split(toOff);\n                toOff = 0;\n            }\n            // If the element after the replacement should be merged with\n            // the last replacing element, update `content`\n            if (!breakAtEnd && last && after.merge(0, toOff, last, true)) {\n                content[content.length - 1] = after;\n            }\n            else {\n                // Remove the start of the after element, if necessary, and\n                // add it to `content`.\n                if (toOff || after.children.length && after.children[0].length == 0)\n                    after.merge(0, toOff, null, false);\n                content.push(after);\n            }\n        }\n        else if (after.breakAfter) {\n            // The element at `toI` is entirely covered by this range.\n            // Preserve its line break, if any.\n            if (last)\n                last.breakAfter = 1;\n            else\n                breakAtStart = 1;\n        }\n        // Since we've handled the next element from the current elements\n        // now, make sure `toI` points after that.\n        toI++;\n        before.breakAfter = breakAtStart;\n        if (fromOff > 0) {\n            if (!breakAtStart && content.length && before.merge(fromOff, before.length, content[0], false)) {\n                before.breakAfter = content.shift().breakAfter;\n            }\n            else if (fromOff < before.length || before.children.length && before.children[before.children.length - 1].length == 0) {\n                before.merge(fromOff, before.length, null, false);\n            }\n            fromI++;\n        }\n        // Try to merge widgets on the boundaries of the replacement\n        while (fromI < toI && content.length) {\n            if (this.children[toI - 1].match(content[content.length - 1]))\n                toI--, content.pop();\n            else if (this.children[fromI].match(content[0]))\n                fromI++, content.shift();\n            else\n                break;\n        }\n        if (fromI < toI || content.length)\n            this.replaceChildren(fromI, toI, content);\n    }\n    // Sync the DOM selection to this.state.selection\n    updateSelection(force = false) {\n        this.clearSelectionDirty();\n        if (this.root.activeElement != this.dom)\n            return;\n        let primary = this.view.state.selection.primary;\n        // FIXME need to handle the case where the selection falls inside a block range\n        let anchor = this.domAtPos(primary.anchor);\n        let head = this.domAtPos(primary.head);\n        let domSel = getSelection(this.root);\n        // If the selection is already here, or in an equivalent position, don't touch it\n        if (force ||\n            !isEquivalentPosition(anchor.node, anchor.offset, domSel.anchorNode, domSel.anchorOffset) ||\n            !isEquivalentPosition(head.node, head.offset, domSel.focusNode, domSel.focusOffset)) {\n            this.view.observer.ignore(() => {\n                // Selection.extend can be used to create an 'inverted' selection\n                // (one where the focus is before the anchor), but not all\n                // browsers support it yet.\n                if (domSel.extend) {\n                    domSel.collapse(anchor.node, anchor.offset);\n                    if (!primary.empty)\n                        domSel.extend(head.node, head.offset);\n                }\n                else {\n                    let range = document.createRange();\n                    if (primary.anchor > primary.head)\n                        [anchor, head] = [head, anchor];\n                    range.setEnd(head.node, head.offset);\n                    range.setStart(anchor.node, anchor.offset);\n                    domSel.removeAllRanges();\n                    domSel.addRange(range);\n                }\n            });\n        }\n        this.impreciseAnchor = anchor.precise ? null : new DOMPos(domSel.anchorNode, domSel.anchorOffset);\n        this.impreciseHead = head.precise ? null : new DOMPos(domSel.focusNode, domSel.focusOffset);\n    }\n    nearest(dom) {\n        for (let cur = dom; cur;) {\n            let domView = ContentView.get(cur);\n            if (domView && domView.rootView == this)\n                return domView;\n            cur = cur.parentNode;\n        }\n        return null;\n    }\n    posFromDOM(node, offset) {\n        let view = this.nearest(node);\n        if (!view)\n            throw new RangeError(\"Trying to find position for a DOM position outside of the document\");\n        return view.localPosFromDOM(node, offset) + view.posAtStart;\n    }\n    domAtPos(pos) {\n        let { i, off } = this.childCursor().findPos(pos, -1);\n        for (; i < this.children.length - 1;) {\n            let child = this.children[i];\n            if (off < child.length || child instanceof LineView)\n                break;\n            i++;\n            off = 0;\n        }\n        return this.children[i].domAtPos(off);\n    }\n    coordsAt(pos) {\n        for (let off = this.length, i = this.children.length - 1;; i--) {\n            let child = this.children[i], start = off - child.breakAfter - child.length;\n            if (pos >= start && child.type != BlockType.WidgetAfter)\n                return child.coordsAt(pos - start);\n            off = start;\n        }\n    }\n    measureVisibleLineHeights() {\n        let result = [], { from, to } = this.view.viewState.viewport;\n        let minWidth = Math.max(this.view.scrollDOM.clientWidth, this.minWidth) + 1;\n        for (let pos = 0, i = 0; i < this.children.length; i++) {\n            let child = this.children[i], end = pos + child.length;\n            if (end > to)\n                break;\n            if (pos >= from) {\n                result.push(child.dom.getBoundingClientRect().height);\n                let width = child.dom.scrollWidth;\n                if (width > minWidth) {\n                    this.minWidth = minWidth = width;\n                    this.minWidthFrom = pos;\n                    this.minWidthTo = end;\n                }\n            }\n            pos = end + child.breakAfter;\n        }\n        return result;\n    }\n    measureTextSize() {\n        for (let child of this.children) {\n            if (child instanceof LineView) {\n                let measure = child.measureTextSize();\n                if (measure)\n                    return measure;\n            }\n        }\n        // If no workable line exists, force a layout of a measurable element\n        let dummy = document.createElement(\"div\"), lineHeight, charWidth;\n        dummy.className = \"cm-line\";\n        dummy.textContent = \"abc def ghi jkl mno pqr stu\";\n        this.view.observer.ignore(() => {\n            this.dom.appendChild(dummy);\n            let rect = clientRectsFor(dummy.firstChild)[0];\n            lineHeight = dummy.getBoundingClientRect().height;\n            charWidth = rect ? rect.width / 27 : 7;\n            dummy.remove();\n        });\n        return { lineHeight, charWidth };\n    }\n    clearSelectionDirty() {\n        if (this.selectionDirty != null) {\n            cancelAnimationFrame(this.selectionDirty);\n            this.selectionDirty = null;\n        }\n    }\n    setSelectionDirty() {\n        this.view.observer.clearSelection();\n        if (this.selectionDirty == null)\n            this.selectionDirty = requestAnimationFrame(() => this.updateSelection());\n    }\n    childCursor(pos = this.length) {\n        // Move back to start of last element when possible, so that\n        // `ChildCursor.findPos` doesn't have to deal with the edge case\n        // of being after the last element.\n        let i = this.children.length;\n        if (i)\n            pos -= this.children[--i].length;\n        return new ChildCursor(this.children, pos, i);\n    }\n    computeBlockGapDeco() {\n        let visible = this.view.viewState.viewport, viewports = [visible];\n        let { head, anchor } = this.view.state.selection.primary;\n        if (head < visible.from || head > visible.to) {\n            let { from, to } = this.view.viewState.lineAt(head, 0);\n            viewports.push(new Viewport(from, to));\n        }\n        if (!viewports.some(({ from, to }) => anchor >= from && anchor <= to)) {\n            let { from, to } = this.view.viewState.lineAt(anchor, 0);\n            viewports.push(new Viewport(from, to));\n        }\n        this.viewports = viewports.sort((a, b) => a.from - b.from);\n        let deco = [];\n        for (let pos = 0, i = 0;; i++) {\n            let next = i == viewports.length ? null : viewports[i];\n            let end = next ? next.from - 1 : this.length;\n            if (end > pos) {\n                let height = this.view.viewState.lineAt(end, 0).bottom - this.view.viewState.lineAt(pos, 0).top;\n                deco.push(Decoration.replace({ widget: new BlockGapWidget(height), block: true, inclusive: true }).range(pos, end));\n            }\n            if (!next)\n                break;\n            pos = next.to + 1;\n        }\n        return Decoration.set(deco);\n    }\n    updateDeco() {\n        return this.decorations = [\n            ...this.view.state.facet(decorations),\n            this.computeBlockGapDeco(),\n            this.view.viewState.lineGapDeco,\n            this.compositionDeco,\n            ...this.view.pluginField(pluginDecorations)\n        ];\n    }\n    scrollPosIntoView(pos) {\n        let rect = this.coordsAt(pos);\n        if (!rect)\n            return;\n        let mLeft = 0, mRight = 0, mTop = 0, mBottom = 0;\n        for (let margins of this.view.pluginField(PluginField.scrollMargins))\n            if (margins) {\n                let { left, right, top, bottom } = margins;\n                if (left != null)\n                    mLeft = Math.max(mLeft, left);\n                if (right != null)\n                    mRight = Math.max(mRight, right);\n                if (top != null)\n                    mTop = Math.max(mTop, top);\n                if (bottom != null)\n                    mBottom = Math.max(mBottom, bottom);\n            }\n        scrollRectIntoView(this.dom, {\n            left: rect.left - mLeft, top: rect.top - mTop,\n            right: rect.right + mRight, bottom: rect.bottom + mBottom\n        });\n    }\n}\n// Browsers appear to reserve a fixed amount of bits for height\n// styles, and ignore or clip heights above that. For Chrome and\n// Firefox, this is in the 20 million range, so we try to stay below\n// that.\nconst MaxNodeHeight = 1e7;\nclass BlockGapWidget extends WidgetType {\n    toDOM() {\n        let elt = document.createElement(\"div\");\n        this.updateDOM(elt);\n        return elt;\n    }\n    updateDOM(elt) {\n        if (this.value < MaxNodeHeight) {\n            while (elt.lastChild)\n                elt.lastChild.remove();\n            elt.style.height = this.value + \"px\";\n        }\n        else {\n            elt.style.height = \"\";\n            for (let remaining = this.value; remaining > 0; remaining -= MaxNodeHeight) {\n                let fill = elt.appendChild(document.createElement(\"div\"));\n                fill.style.height = Math.min(remaining, MaxNodeHeight) + \"px\";\n            }\n        }\n        return true;\n    }\n    get estimatedHeight() { return this.value; }\n}\nfunction computeCompositionDeco(view, changes) {\n    let sel = getSelection(view.root);\n    let textNode = sel.focusNode && nearbyTextNode(sel.focusNode, sel.focusOffset);\n    if (!textNode)\n        return Decoration.none;\n    let cView = view.docView.nearest(textNode);\n    let from, to, topNode = textNode;\n    if (cView instanceof InlineView) {\n        from = cView.posAtStart;\n        to = from + cView.length;\n        topNode = cView.dom;\n    }\n    else if (cView instanceof LineView) {\n        while (topNode.parentNode != cView.dom)\n            topNode = topNode.parentNode;\n        let prev = topNode.previousSibling;\n        while (prev && !ContentView.get(prev))\n            prev = prev.previousSibling;\n        from = to = prev ? ContentView.get(prev).posAtEnd : cView.posAtStart;\n    }\n    else {\n        return Decoration.none;\n    }\n    let newFrom = ChangedRange.mapPos(from, 1, changes), newTo = Math.max(newFrom, ChangedRange.mapPos(to, -1, changes));\n    let text = textNode.nodeValue, doc = view.state.doc;\n    if (newTo - newFrom < text.length) {\n        if (doc.slice(newFrom, Math.min(doc.length, newFrom + text.length)) == text)\n            newTo = newFrom + text.length;\n        else if (doc.slice(Math.max(0, newTo - text.length), newTo) == text)\n            newFrom = newTo - text.length;\n        else\n            return Decoration.none;\n    }\n    else if (doc.slice(newFrom, newTo) != text) {\n        return Decoration.none;\n    }\n    return Decoration.set(Decoration.replace({ widget: new CompositionWidget({ top: topNode, text: textNode }) }).range(newFrom, newTo));\n}\nclass CompositionWidget extends WidgetType {\n    eq(value) { return this.value.top == value.top && this.value.text == value.text; }\n    toDOM() { return this.value.top; }\n    ignoreEvent() { return false; }\n    get customView() { return CompositionView; }\n}\nfunction nearbyTextNode(node, offset) {\n    for (;;) {\n        if (node.nodeType == 3)\n            return node;\n        if (node.nodeType == 1 && offset > 0) {\n            node = node.childNodes[offset - 1];\n            offset = maxOffset(node);\n        }\n        else if (node.nodeType == 1 && offset < node.childNodes.length) {\n            node = node.childNodes[offset];\n            offset = 0;\n        }\n        else {\n            return null;\n        }\n    }\n}\nclass DecorationComparator$1 {\n    constructor() {\n        this.changes = [];\n    }\n    compareRange(from, to) { addRange(from, to, this.changes); }\n    comparePoint(from, to) { addRange(from, to, this.changes); }\n}\nfunction findChangedDeco(a, b, diff, length) {\n    let comp = new DecorationComparator$1;\n    RangeSet.compare(a, b, diff, length, comp);\n    return comp.changes;\n}\n\n// FIXME rename \"word\" to something more descriptive of what it actually does?\nfunction movePos(view, start, direction, granularity = \"character\", action) {\n    let sel = getSelection(view.root);\n    let context = LineContext.get(view, start);\n    let dir = direction == \"forward\" || direction == \"right\" ? 1 : -1;\n    // Can only query native behavior when Selection.modify is\n    // supported, the cursor is well inside the rendered viewport, and\n    // we're not doing by-line motion on Gecko (which will mess up goal\n    // column motion)\n    if (sel.modify && context && !context.nearViewportEnd(view) && view.hasFocus &&\n        granularity != \"word\" &&\n        !(granularity == \"line\" && (browser.gecko || view.state.selection.ranges.length > 1))) {\n        return view.observer.ignore(() => {\n            let prepared = context.prepareForQuery(view, start);\n            let startDOM = view.docView.domAtPos(start);\n            let equiv = (!browser.chrome || prepared.lines.length == 0) &&\n                isEquivalentPosition(startDOM.node, startDOM.offset, sel.focusNode, sel.focusOffset) && false;\n            // Firefox skips an extra character ahead when extending across\n            // an uneditable element (but not when moving)\n            if (prepared.atWidget && browser.gecko && action == \"extend\")\n                action = \"move\";\n            if (action == \"move\" && !(equiv && sel.isCollapsed))\n                sel.collapse(startDOM.node, startDOM.offset);\n            else if (action == \"extend\" && !equiv)\n                sel.extend(startDOM.node, startDOM.offset);\n            sel.modify(action, direction, granularity);\n            view.docView.setSelectionDirty();\n            let result = view.docView.posFromDOM(sel.focusNode, sel.focusOffset);\n            context.undoQueryPreparation(view, prepared);\n            return result;\n        });\n    }\n    else if (granularity == \"character\") {\n        return moveCharacterSimple(start, dir, context, view.state.doc);\n    }\n    else if (granularity == \"lineboundary\") {\n        if (context)\n            return context.start + (dir < 0 ? 0 : context.line.length);\n        let line = view.state.doc.lineAt(start);\n        return dir < 0 ? line.start : line.end;\n    }\n    else if (granularity == \"line\") {\n        if (context && !context.nearViewportEnd(view, dir)) {\n            let startCoords = view.coordsAtPos(start);\n            let goal = getGoalColumn(view, start, startCoords.left);\n            for (let startY = dir < 0 ? startCoords.top : startCoords.bottom, dist = 5; dist < 50; dist += 10) {\n                let pos = posAtCoords(view, { x: goal.column, y: startY + dist * dir }, dir);\n                if (pos < 0)\n                    break;\n                if (pos != start) {\n                    goal.pos = pos;\n                    return pos;\n                }\n            }\n        }\n        // Can't do a precise one based on DOM positions, fall back to per-column\n        return moveLineByColumn(view.state.doc, view.state.tabSize, start, dir);\n    }\n    else if (granularity == \"word\") {\n        return moveWord(view, start, direction);\n    }\n    else {\n        throw new RangeError(\"Invalid move granularity: \" + granularity);\n    }\n}\nfunction moveLineByColumn(doc, tabSize, pos, dir) {\n    let line = doc.lineAt(pos);\n    // FIXME also needs goal column?\n    let col = 0;\n    for (const iter = doc.iterRange(line.start, pos); !iter.next().done;)\n        col = countColumn(iter.value, col, tabSize);\n    if (dir < 0 && line.start == 0)\n        return 0;\n    else if (dir > 0 && line.end == doc.length)\n        return line.end;\n    let otherLine = doc.line(line.number + dir);\n    let result = otherLine.start;\n    let seen = 0;\n    for (const iter = doc.iterRange(otherLine.start, otherLine.end); seen >= col && !iter.next().done;) {\n        const { offset, leftOver } = findColumn(iter.value, seen, col, tabSize);\n        seen = col - leftOver;\n        result += offset;\n    }\n    return result;\n}\nfunction moveCharacterSimple(start, dir, context, doc) {\n    if (context == null) {\n        for (let pos = start;; pos += dir) {\n            if (dir < 0 && pos == 0 || dir > 0 && pos == doc.length)\n                return pos;\n            if (!isExtendingChar((dir < 0 ? doc.slice(pos - 1, pos) : doc.slice(pos, pos + 1)).charCodeAt(0))) {\n                if (dir < 0)\n                    return pos - 1;\n                else if (pos != start)\n                    return pos;\n            }\n        }\n    }\n    for (let { i, off } = context.line.childPos(start - context.start), { children } = context.line, pos = start;;) {\n        if (off == (dir < 0 || i == children.length ? 0 : children[i].length)) {\n            i += dir;\n            if (i < 0 || i >= children.length) // End/start of line\n                return Math.max(0, Math.min(doc.length, pos + (start == pos ? dir : 0)));\n            off = dir < 0 ? children[i].length : 0;\n        }\n        let inline = children[i];\n        if (inline instanceof TextView) {\n            if (!isExtendingChar(inline.text.charCodeAt(off - (dir < 0 ? 1 : 0)))) {\n                if (dir < 0)\n                    return pos - 1;\n                else if (pos != start)\n                    return pos;\n            }\n            off += dir;\n            pos += dir;\n        }\n        else if (inline.length > 0) {\n            return pos - off + (dir < 0 ? 0 : inline.length);\n        }\n    }\n}\nfunction moveWord(view, start, direction) {\n    let { doc } = view.state;\n    for (let pos = start, i = 0;; i++) {\n        let next = movePos(view, pos, direction, \"character\", \"move\");\n        if (next == pos)\n            return pos; // End of document\n        if (doc.sliceLines(Math.min(next, pos), Math.max(next, pos)).length > 1)\n            return next; // Crossed a line boundary\n        let group = SelectionRange.groupAt(view.state, next, next > pos ? -1 : 1);\n        let away = pos < group.from && pos > group.to;\n        // If the group is away from its start position, we jumped over a\n        // bidi boundary, and should take the side closest (in index\n        // coordinates) to the start position\n        let start = away ? pos < group.head : group.from == pos ? false : group.to == pos ? true : next < pos;\n        pos = start ? group.from : group.to;\n        if (i > 0 || /\\S/.test(doc.slice(group.from, group.to)))\n            return pos;\n        next = Math.max(0, Math.min(doc.length, pos + (start ? -1 : 1)));\n    }\n}\nfunction getGoalColumn(view, pos, column) {\n    for (let goal of view.inputState.goalColumns)\n        if (goal.pos == pos)\n            return goal;\n    let goal = { pos: 0, column };\n    view.inputState.goalColumns.push(goal);\n    return goal;\n}\nclass LineContext {\n    constructor(line, start, index) {\n        this.line = line;\n        this.start = start;\n        this.index = index;\n    }\n    static get(view, pos) {\n        for (let i = 0, off = 0;; i++) {\n            let line = view.docView.children[i], end = off + line.length;\n            if (end >= pos) {\n                if (line instanceof LineView)\n                    return new LineContext(line, off, i);\n                if (line.length)\n                    return null;\n            }\n            off = end + 1;\n        }\n    }\n    nearViewportEnd(view, side = 0) {\n        for (let { from, to } of view.docView.viewports)\n            if (from > 0 && from == this.start && side <= 0 ||\n                to < view.state.doc.length && to == this.start + this.line.length && side >= 0)\n                return true;\n        return false;\n    }\n    // FIXME limit the amount of work in character motion in non-bidi\n    // context? or not worth it?\n    prepareForQuery(view, pos) {\n        let linesToSync = [], atWidget = false;\n        function maybeHide(view) {\n            if (!(view instanceof TextView))\n                atWidget = true;\n            if (view.length > 0)\n                return false;\n            view.dom.remove();\n            if (linesToSync.indexOf(view.parent) < 0)\n                linesToSync.push(view.parent);\n            return true;\n        }\n        let { i, off } = this.line.childPos(pos - this.start);\n        if (off == 0) {\n            for (let j = i; j < this.line.children.length; j++)\n                if (!maybeHide(this.line.children[j]))\n                    break;\n            for (let j = i; j > 0; j--)\n                if (!maybeHide(this.line.children[j - 1]))\n                    break;\n        }\n        function addForLine(line, omit = -1) {\n            if (line.children.length == 0)\n                return;\n            for (let i = 0, off = 0; i <= line.children.length; i++) {\n                let next = i == line.children.length ? null : line.children[i];\n                if ((!next || !(next instanceof TextView)) && off != omit &&\n                    (i == 0 || !(line.children[i - 1] instanceof TextView))) {\n                    line.dom.insertBefore(document.createTextNode(\"\\u200b\"), next ? next.dom : null);\n                    if (linesToSync.indexOf(line) < 0)\n                        linesToSync.push(line);\n                }\n                if (next)\n                    off += next.length;\n            }\n        }\n        if (this.index > 0)\n            addForLine(this.line.parent.children[this.index - 1]);\n        addForLine(this.line, pos - this.start);\n        if (this.index < this.line.parent.children.length - 1)\n            addForLine(this.line.parent.children[this.index + 1]);\n        return { lines: linesToSync, atWidget };\n    }\n    undoQueryPreparation(view, toSync) {\n        for (let line of toSync.lines) {\n            line.dirty = 2 /* Node */;\n            line.sync();\n            line.dirty = 0 /* Not */;\n        }\n    }\n}\n// Search the DOM for the {node, offset} position closest to the given\n// coordinates. Very inefficient and crude, but can usually be avoided\n// by calling caret(Position|Range)FromPoint instead.\n// FIXME holding arrow-up/down at the end of the viewport is a rather\n// common use case that will repeatedly trigger this code. Maybe\n// introduce some element of binary search after all?\nfunction getdx(x, rect) {\n    return rect.left > x ? rect.left - x : Math.max(0, x - rect.right);\n}\nfunction getdy(y, rect) {\n    return rect.top > y ? rect.top - y : Math.max(0, y - rect.bottom);\n}\nfunction yOverlap(a, b) {\n    return a.top < b.bottom - 1 && a.bottom > b.top + 1;\n}\nfunction upTop(rect, top) {\n    return top < rect.top ? { top, left: rect.left, right: rect.right, bottom: rect.bottom } : rect;\n}\nfunction upBot(rect, bottom) {\n    return bottom > rect.bottom ? { top: rect.top, left: rect.left, right: rect.right, bottom } : rect;\n}\nfunction domPosAtCoords(parent, x, y) {\n    let closest, closestRect, closestX, closestY;\n    let above, below, aboveRect, belowRect;\n    for (let child = parent.firstChild; child; child = child.nextSibling) {\n        let rects = clientRectsFor(child);\n        for (let i = 0; i < rects.length; i++) {\n            let rect = rects[i];\n            if (closestRect && yOverlap(closestRect, rect))\n                rect = upTop(upBot(rect, closestRect.bottom), closestRect.top);\n            let dx = getdx(x, rect), dy = getdy(y, rect);\n            if (dx == 0 && dy == 0)\n                return child.nodeType == 3 ? domPosInText(child, x, y) : domPosAtCoords(child, x, y);\n            if (!closest || closestY > dy || closestY == dy && closestX > dx) {\n                closest = child;\n                closestRect = rect;\n                closestX = dx;\n                closestY = dy;\n            }\n            if (dx == 0) {\n                if (y > rect.bottom && (!aboveRect || aboveRect.bottom < rect.bottom)) {\n                    above = child;\n                    aboveRect = rect;\n                }\n                else if (y < rect.top && (!belowRect || belowRect.top > rect.top)) {\n                    below = child;\n                    belowRect = rect;\n                }\n            }\n            else if (aboveRect && yOverlap(aboveRect, rect)) {\n                aboveRect = upBot(aboveRect, rect.bottom);\n            }\n            else if (belowRect && yOverlap(belowRect, rect)) {\n                belowRect = upTop(belowRect, rect.top);\n            }\n        }\n    }\n    if (aboveRect && aboveRect.bottom >= y) {\n        closest = above;\n        closestRect = aboveRect;\n    }\n    else if (belowRect && belowRect.top <= y) {\n        closest = below;\n        closestRect = belowRect;\n    }\n    if (!closest)\n        return { node: parent, offset: 0 };\n    let clipX = Math.max(closestRect.left, Math.min(closestRect.right, x));\n    if (closest.nodeType == 3)\n        return domPosInText(closest, clipX, y);\n    if (!closestX && closest.contentEditable == \"true\")\n        domPosAtCoords(closest, clipX, y);\n    let offset = Array.prototype.indexOf.call(parent.childNodes, closest) +\n        (x >= (closestRect.left + closestRect.right) / 2 ? 1 : 0);\n    return { node: parent, offset };\n}\nfunction domPosInText(node, x, y) {\n    let len = node.nodeValue.length, range = document.createRange();\n    for (let i = 0; i < len; i++) {\n        range.setEnd(node, i + 1);\n        range.setStart(node, i);\n        let rects = range.getClientRects();\n        for (let j = 0; j < rects.length; j++) {\n            let rect = rects[j];\n            if (rect.top == rect.bottom)\n                continue;\n            if (rect.left - 1 <= x && rect.right + 1 >= x &&\n                rect.top - 1 <= y && rect.bottom + 1 >= y) {\n                let right = x >= (rect.left + rect.right) / 2, after = right;\n                if (browser.chrome || browser.gecko) {\n                    // Check for RTL on browsers that support getting client\n                    // rects for empty ranges.\n                    range.setEnd(node, i);\n                    let rectBefore = range.getBoundingClientRect();\n                    if (rectBefore.left == rect.right)\n                        after = !right;\n                }\n                return { node, offset: i + (after ? 1 : 0) };\n            }\n        }\n    }\n    return { node, offset: 0 };\n}\nfunction posAtCoords(view, { x, y }, bias = -1) {\n    let content = view.contentDOM.getBoundingClientRect(), block;\n    let halfLine = view.defaultLineHeight / 2;\n    for (let bounced = false;;) {\n        block = view.blockAtHeight(y, content.top);\n        if (block.top > y || block.bottom < y) {\n            bias = block.top > y ? -1 : 1;\n            y = Math.min(block.bottom - halfLine, Math.max(block.top + halfLine, y));\n            if (bounced)\n                return -1;\n            else\n                bounced = true;\n        }\n        if (block.type == BlockType.Text)\n            break;\n        y = bias > 0 ? block.bottom + halfLine : block.top - halfLine;\n    }\n    let lineStart = block.from;\n    // If this is outside of the rendered viewport, we can't determine a position\n    if (lineStart < view.viewport.from)\n        return view.viewport.from == 0 ? 0 : -1;\n    if (lineStart > view.viewport.to)\n        return view.viewport.to == view.state.doc.length ? view.state.doc.length : -1;\n    // Clip x to the viewport sides\n    x = Math.max(content.left + 1, Math.min(content.right - 1, x));\n    let root = view.root, element = root.elementFromPoint(x, y);\n    // There's visible editor content under the point, so we can try\n    // using caret(Position|Range)FromPoint as a shortcut\n    let node, offset = -1;\n    if (element && view.contentDOM.contains(element) && !(view.docView.nearest(element) instanceof WidgetView)) {\n        if (root.caretPositionFromPoint) {\n            let pos = root.caretPositionFromPoint(x, y);\n            if (pos)\n                ({ offsetNode: node, offset } = pos);\n        }\n        else if (root.caretRangeFromPoint) {\n            let range = root.caretRangeFromPoint(x, y);\n            if (range)\n                ({ startContainer: node, startOffset: offset } = range);\n        }\n    }\n    // No luck, do our own (potentially expensive) search\n    if (!node) {\n        let { line } = LineContext.get(view, lineStart);\n        ({ node, offset } = domPosAtCoords(line.dom, x, y));\n    }\n    return view.docView.posFromDOM(node, offset);\n}\n\n// This will also be where dragging info and such goes\nclass InputState {\n    constructor(view) {\n        this.lastKeyCode = 0;\n        this.lastKeyTime = 0;\n        this.lastSelectionOrigin = null;\n        this.lastSelectionTime = 0;\n        this.registeredEvents = [];\n        this.customHandlers = [];\n        this.composing = false;\n        this.goalColumns = [];\n        this.mouseSelection = null;\n        for (let type in handlers) {\n            let handler = handlers[type];\n            view.contentDOM.addEventListener(type, (event) => {\n                if (!eventBelongsToEditor(view, event))\n                    return;\n                if (this.runCustomHandlers(type, view, event))\n                    event.preventDefault();\n                else\n                    handler(view, event);\n            });\n            this.registeredEvents.push(type);\n        }\n        // Must always run, even if a custom handler handled the event\n        view.contentDOM.addEventListener(\"keydown\", (event) => {\n            view.inputState.lastKeyCode = event.keyCode;\n            view.inputState.lastKeyTime = Date.now();\n        });\n        if (view.root.activeElement == view.contentDOM)\n            view.dom.classList.add(\"cm-focused\");\n        this.notifiedFocused = view.hasFocus;\n        this.ensureHandlers(view);\n    }\n    setSelectionOrigin(origin) {\n        this.lastSelectionOrigin = origin;\n        this.lastSelectionTime = Date.now();\n    }\n    ensureHandlers(view) {\n        let handlers = view.state.facet(domEventHandlers);\n        if (handlers == this.customHandlers)\n            return;\n        this.customHandlers = handlers;\n        for (let set of handlers) {\n            for (let type in set)\n                if (this.registeredEvents.indexOf(type) < 0) {\n                    this.registeredEvents.push(type);\n                    (type != \"scroll\" ? view.contentDOM : view.scrollDOM).addEventListener(type, (event) => {\n                        if (!eventBelongsToEditor(view, event))\n                            return;\n                        if (this.runCustomHandlers(type, view, event))\n                            event.preventDefault();\n                    });\n                }\n        }\n    }\n    runCustomHandlers(type, view, event) {\n        for (let handlers of this.customHandlers) {\n            let handler = handlers[type];\n            if (handler) {\n                try {\n                    if (handler(view, event) || event.defaultPrevented)\n                        return true;\n                }\n                catch (e) {\n                    console.error(e);\n                }\n            }\n        }\n        return false;\n    }\n    startMouseSelection(view, event, update) {\n        if (this.mouseSelection)\n            this.mouseSelection.destroy();\n        this.mouseSelection = new MouseSelection(this, view, event, update);\n    }\n    update(update) {\n        if (this.mouseSelection)\n            this.mouseSelection.map(update.changes);\n        this.lastKeyCode = this.lastSelectionTime = 0;\n    }\n    destroy() {\n        if (this.mouseSelection)\n            this.mouseSelection.destroy();\n    }\n}\nclass MouseSelection {\n    constructor(inputState, view, event, update) {\n        this.inputState = inputState;\n        this.view = view;\n        this.update = update;\n        let doc = view.contentDOM.ownerDocument;\n        doc.addEventListener(\"mousemove\", this.move = this.move.bind(this));\n        doc.addEventListener(\"mouseup\", this.up = this.up.bind(this));\n        this.extend = event.shiftKey;\n        this.multiple = view.state.facet(EditorState.allowMultipleSelections) && addsSelectionRange(view, event);\n        this.dragMove = dragMovesSelection$1(view, event);\n        this.startSelection = view.state.selection;\n        let { pos, bias } = this.queryPos(event);\n        this.startPos = this.curPos = pos;\n        this.startBias = this.curBias = bias;\n        this.dragging = isInPrimarySelection(view, this.startPos, event) ? null : false;\n        // When clicking outside of the selection, immediately apply the\n        // effect of starting the selection\n        if (this.dragging === false) {\n            event.preventDefault();\n            this.select();\n        }\n    }\n    queryPos(event) {\n        let pos = this.view.posAtCoords({ x: event.clientX, y: event.clientY });\n        let coords = pos < 0 ? null : this.view.coordsAtPos(pos);\n        let bias = !coords ? 1 :\n            coords.top > event.clientY ? -1 :\n                coords.bottom < event.clientY ? 1 :\n                    coords.left > event.clientX ? -1 : 1;\n        return { pos, bias };\n    }\n    move(event) {\n        if (event.buttons == 0)\n            return this.destroy();\n        if (this.dragging !== false)\n            return;\n        let { pos, bias } = this.queryPos(event);\n        if (pos == this.curPos && bias == this.curBias)\n            return;\n        this.curPos = pos;\n        this.curBias = bias;\n        this.select();\n    }\n    up(event) {\n        if (this.dragging == null)\n            this.select();\n        this.destroy();\n    }\n    destroy() {\n        let doc = this.view.contentDOM.ownerDocument;\n        doc.removeEventListener(\"mousemove\", this.move);\n        doc.removeEventListener(\"mouseup\", this.up);\n        this.inputState.mouseSelection = null;\n    }\n    select() {\n        let selection = this.update(this.view, this.startSelection, this.startPos, this.startBias, this.curPos, this.curBias, this.extend, this.multiple);\n        if (!selection.eq(this.view.state.selection))\n            this.view.dispatch(this.view.state.t().setSelection(selection)\n                .annotate(Transaction.userEvent, \"pointer\")\n                .scrollIntoView());\n    }\n    map(changes) {\n        if (changes.length) {\n            this.startSelection = this.startSelection.map(changes);\n            this.startPos = changes.mapPos(this.startPos);\n            this.curPos = changes.mapPos(this.curPos);\n        }\n        if (this.dragging)\n            this.dragging = this.dragging.map(changes);\n    }\n}\nfunction addsSelectionRange(view, event) {\n    let facet = view.state.facet(clickAddsSelectionRange);\n    return facet.length ? facet[0](event) : browser.mac ? event.metaKey : event.ctrlKey;\n}\nfunction dragMovesSelection$1(view, event) {\n    let facet = view.state.facet(dragMovesSelection);\n    return facet.length ? facet[0](event) : browser.mac ? !event.altKey : !event.ctrlKey;\n}\nfunction isInPrimarySelection(view, pos, event) {\n    let { primary } = view.state.selection;\n    if (primary.empty)\n        return false;\n    if (pos < primary.from || pos > primary.to)\n        return false;\n    if (pos > primary.from && pos < primary.to)\n        return true;\n    // On boundary clicks, check whether the coordinates are inside the\n    // selection's client rectangles\n    let sel = getSelection(view.root);\n    if (sel.rangeCount == 0)\n        return true;\n    let rects = sel.getRangeAt(0).getClientRects();\n    for (let i = 0; i < rects.length; i++) {\n        let rect = rects[i];\n        if (rect.left <= event.clientX && rect.right >= event.clientX &&\n            rect.top <= event.clientY && rect.bottom >= event.clientY)\n            return true;\n    }\n    return false;\n}\nfunction eventBelongsToEditor(view, event) {\n    if (!event.bubbles)\n        return true;\n    if (event.defaultPrevented)\n        return false;\n    for (let node = event.target, cView; node != view.contentDOM; node = node.parentNode)\n        if (!node || node.nodeType == 11 || ((cView = ContentView.get(node)) && cView.ignoreEvent(event)))\n            return false;\n    return true;\n}\nconst handlers = Object.create(null);\n// This is very crude, but unfortunately both these browsers _pretend_\n// that they have a clipboard APIall the objects and methods are\n// there, they just don't work, and they are hard to test.\nconst brokenClipboardAPI = (browser.ie && browser.ie_version < 15) ||\n    (browser.ios && browser.webkit_version < 604);\nfunction capturePaste(view) {\n    let doc = view.dom.ownerDocument;\n    let target = doc.body.appendChild(doc.createElement(\"textarea\"));\n    target.style.cssText = \"position: fixed; left: -10000px; top: 10px\";\n    target.focus();\n    setTimeout(() => {\n        view.focus();\n        doc.body.removeChild(target);\n        doPaste(view, target.value);\n    }, 50);\n}\nfunction doPaste(view, text) {\n    view.dispatch(view.state.t().replaceSelection(text)\n        .annotate(Transaction.userEvent, \"paste\").scrollIntoView());\n}\nfunction mustCapture(event) {\n    let mods = (event.ctrlKey ? 1 /* Ctrl */ : 0) | (event.metaKey ? 8 /* Meta */ : 0) |\n        (event.altKey ? 2 /* Alt */ : 0) | (event.shiftKey ? 4 /* Shift */ : 0);\n    let code = event.keyCode, macCtrl = browser.mac && mods == 1 /* Ctrl */;\n    return code == 8 || (macCtrl && code == 72) || // Backspace, Ctrl-h on Mac\n        code == 46 || (macCtrl && code == 68) || // Delete, Ctrl-d on Mac\n        code == 27 || // Esc\n        (mods == (browser.mac ? 8 /* Meta */ : 1 /* Ctrl */) && // Ctrl/Cmd-[biyz]\n            (code == 66 || code == 73 || code == 89 || code == 90));\n}\nhandlers.keydown = (view, event) => {\n    if (mustCapture(event))\n        event.preventDefault();\n    view.inputState.setSelectionOrigin(\"keyboard\");\n};\nhandlers.touchdown = handlers.touchmove = (view, event) => {\n    view.inputState.setSelectionOrigin(\"pointer\");\n};\nhandlers.mousedown = (view, event) => {\n    if (event.button == 0)\n        view.startMouseSelection(event, updateMouseSelection(event.detail));\n};\nfunction rangeForClick(view, pos, bias, type) {\n    if (type == 1) { // Single click\n        return new SelectionRange(pos);\n    }\n    else if (type == 2) { // Double click\n        return SelectionRange.groupAt(view.state, pos, bias);\n    }\n    else { // Triple click\n        let context = LineContext.get(view, pos);\n        if (context)\n            return new SelectionRange(context.start + context.line.length, context.start);\n        let { start, end } = view.state.doc.lineAt(pos);\n        return new SelectionRange(start, end);\n    }\n}\nfunction updateMouseSelection(type) {\n    return (view, startSelection, startPos, startBias, curPos, curBias, extend, multiple) => {\n        let range = rangeForClick(view, curPos, curBias, type);\n        if (startPos != curPos && !extend) {\n            let startRange = rangeForClick(view, startPos, startBias, type);\n            let from = Math.min(startRange.from, range.from), to = Math.max(startRange.to, range.to);\n            range = from < range.from ? new SelectionRange(from, to) : new SelectionRange(to, from);\n        }\n        if (extend)\n            return startSelection.replaceRange(startSelection.primary.extend(range.from, range.to));\n        else if (multiple)\n            return startSelection.addRange(range);\n        else\n            return EditorSelection.create([range]);\n    };\n}\nhandlers.dragstart = (view, event) => {\n    let { doc, selection: { primary } } = view.state;\n    let { mouseSelection } = view.inputState;\n    if (mouseSelection)\n        mouseSelection.dragging = primary;\n    if (event.dataTransfer) {\n        event.dataTransfer.setData(\"Text\", doc.slice(primary.from, primary.to));\n        event.dataTransfer.effectAllowed = \"copyMove\";\n    }\n};\nhandlers.drop = (view, event) => {\n    if (!event.dataTransfer)\n        return;\n    let dropPos = view.posAtCoords({ x: event.clientX, y: event.clientY });\n    let text = event.dataTransfer.getData(\"Text\");\n    if (dropPos < 0 || !text)\n        return;\n    event.preventDefault();\n    let tr = view.state.t();\n    let { mouseSelection } = view.inputState;\n    if (mouseSelection && mouseSelection.dragging && mouseSelection.dragMove) {\n        tr.replace(mouseSelection.dragging.from, mouseSelection.dragging.to, \"\");\n        dropPos = tr.changes.mapPos(dropPos);\n    }\n    let change = new Change(dropPos, dropPos, view.state.splitLines(text));\n    tr.change(change)\n        .setSelection(EditorSelection.single(dropPos, dropPos + change.length))\n        .annotate(Transaction.userEvent, \"drop\");\n    view.focus();\n    view.dispatch(tr);\n};\nhandlers.paste = (view, event) => {\n    view.observer.flush();\n    let data = brokenClipboardAPI ? null : event.clipboardData;\n    let text = data && data.getData(\"text/plain\");\n    if (text) {\n        doPaste(view, text);\n        event.preventDefault();\n    }\n    else {\n        capturePaste(view);\n    }\n};\nfunction captureCopy(view, text) {\n    // The extra wrapper is somehow necessary on IE/Edge to prevent the\n    // content from being mangled when it is put onto the clipboard\n    let doc = view.dom.ownerDocument;\n    let target = doc.body.appendChild(doc.createElement(\"textarea\"));\n    target.style.cssText = \"position: fixed; left: -10000px; top: 10px\";\n    target.value = text;\n    target.focus();\n    target.selectionEnd = text.length;\n    target.selectionStart = 0;\n    setTimeout(() => {\n        doc.body.removeChild(target);\n        view.focus();\n    }, 50);\n}\nhandlers.copy = handlers.cut = (view, event) => {\n    let range = view.state.selection.primary;\n    if (range.empty)\n        return;\n    let data = brokenClipboardAPI ? null : event.clipboardData;\n    let text = view.state.joinLines(view.state.doc.sliceLines(range.from, range.to));\n    if (data) {\n        event.preventDefault();\n        data.clearData();\n        data.setData(\"text/plain\", text);\n    }\n    else {\n        captureCopy(view, text);\n    }\n    if (event.type == \"cut\") {\n        view.dispatch(view.state.t().replaceSelection([\"\"]).scrollIntoView().annotate(Transaction.userEvent, \"cut\"));\n    }\n};\nhandlers.focus = handlers.blur = view => {\n    setTimeout(() => {\n        if (view.hasFocus != view.inputState.notifiedFocused)\n            view.update([]);\n    }, 10);\n};\nhandlers.beforeprint = view => {\n    view.viewState.printing = true;\n    view.requestMeasure();\n    setTimeout(() => {\n        view.viewState.printing = false;\n        view.requestMeasure();\n    }, 2000);\n};\nfunction forceClearComposition(view) {\n    if (view.docView.compositionDeco.size)\n        view.update([]);\n}\nhandlers.compositionstart = handlers.compositionupdate = view => {\n    if (!view.inputState.composing) {\n        if (view.docView.compositionDeco.size) {\n            view.observer.flush();\n            forceClearComposition(view);\n        }\n        // FIXME possibly set a timeout to clear it again on Android\n        view.inputState.composing = true;\n    }\n};\nhandlers.compositionend = view => {\n    view.inputState.composing = false;\n    setTimeout(() => {\n        if (!view.inputState.composing)\n            forceClearComposition(view);\n    }, 50);\n};\n\nconst observeOptions = {\n    childList: true,\n    characterData: true,\n    subtree: true,\n    characterDataOldValue: true\n};\n// IE11 has very broken mutation observers, so we also listen to\n// DOMCharacterDataModified there\nconst useCharData = browser.ie && browser.ie_version <= 11;\nclass DOMObserver {\n    constructor(view, onChange, onScrollChanged) {\n        this.view = view;\n        this.onChange = onChange;\n        this.onScrollChanged = onScrollChanged;\n        this.active = false;\n        this.ignoreSelection = new DOMSelection;\n        this.charDataQueue = [];\n        this.charDataTimeout = null;\n        this.scrollTargets = [];\n        this.intersection = null;\n        this.intersecting = false;\n        // Timeout for scheduling check of the parents that need scroll handlers\n        this.parentCheck = -1;\n        this.dom = view.contentDOM;\n        this.observer = new MutationObserver(mutations => this.flush(mutations));\n        if (useCharData)\n            this.onCharData = (event) => {\n                this.charDataQueue.push({ target: event.target,\n                    type: \"characterData\",\n                    oldValue: event.prevValue });\n                if (this.charDataTimeout == null)\n                    this.charDataTimeout = setTimeout(() => this.flush(), 20);\n            };\n        this.onSelectionChange = () => {\n            if (this.view.root.activeElement == this.dom)\n                this.flush();\n        };\n        this.start();\n        this.onScroll = this.onScroll.bind(this);\n        window.addEventListener(\"scroll\", this.onScroll);\n        if (typeof IntersectionObserver == \"function\") {\n            this.intersection = new IntersectionObserver(entries => {\n                if (this.parentCheck < 0)\n                    this.parentCheck = setTimeout(this.listenForScroll.bind(this), 1000);\n                if (entries[entries.length - 1].intersectionRatio > 0 != this.intersecting) {\n                    this.intersecting = !this.intersecting;\n                    this.onScroll();\n                }\n            }, {});\n            this.intersection.observe(this.dom);\n        }\n        this.listenForScroll();\n    }\n    onScroll() {\n        if (this.intersecting) {\n            this.flush();\n            this.onScrollChanged();\n        }\n    }\n    listenForScroll() {\n        this.parentCheck = -1;\n        let i = 0, changed = null;\n        for (let dom = this.dom; dom;) {\n            if (dom.nodeType == 1) {\n                if (!changed && i < this.scrollTargets.length && this.scrollTargets[i] == dom)\n                    i++;\n                else if (!changed)\n                    changed = this.scrollTargets.slice(0, i);\n                if (changed)\n                    changed.push(dom);\n                dom = dom.parentNode;\n            }\n            else if (dom.nodeType == 11) { // Shadow root\n                dom = dom.host;\n            }\n            else {\n                break;\n            }\n        }\n        if (i < this.scrollTargets.length && !changed)\n            changed = this.scrollTargets.slice(0, i);\n        if (changed) {\n            for (let dom of this.scrollTargets)\n                dom.removeEventListener(\"scroll\", this.onScroll);\n            for (let dom of this.scrollTargets = changed)\n                dom.addEventListener(\"scroll\", this.onScroll);\n        }\n    }\n    ignore(f) {\n        if (!this.active)\n            return f();\n        try {\n            this.stop();\n            return f();\n        }\n        finally {\n            this.start();\n            this.clear();\n        }\n    }\n    start() {\n        if (this.active)\n            return;\n        this.observer.observe(this.dom, observeOptions);\n        // FIXME is this shadow-root safe?\n        this.dom.ownerDocument.addEventListener(\"selectionchange\", this.onSelectionChange);\n        if (useCharData)\n            this.dom.addEventListener(\"DOMCharacterDataModified\", this.onCharData);\n        this.active = true;\n    }\n    stop() {\n        if (!this.active)\n            return;\n        this.active = false;\n        this.observer.disconnect();\n        this.dom.ownerDocument.removeEventListener(\"selectionchange\", this.onSelectionChange);\n        if (useCharData)\n            this.dom.removeEventListener(\"DOMCharacterDataModified\", this.onCharData);\n    }\n    takeCharRecords() {\n        let result = this.charDataQueue;\n        if (result.length) {\n            this.charDataQueue = [];\n            clearTimeout(this.charDataTimeout);\n            this.charDataTimeout = null;\n        }\n        return result;\n    }\n    clearSelection() {\n        this.ignoreSelection.set(getSelection(this.view.root));\n    }\n    // Throw away any pending changes\n    clear() {\n        this.observer.takeRecords();\n        this.takeCharRecords();\n        this.clearSelection();\n    }\n    // Apply pending changes, if any\n    flush(records = this.observer.takeRecords()) {\n        if (this.charDataQueue.length)\n            records = records.concat(this.takeCharRecords());\n        let selection = getSelection(this.view.root);\n        let newSel = !this.ignoreSelection.eq(selection) && hasSelection(this.dom, selection);\n        if (records.length == 0 && !newSel)\n            return;\n        let from = -1, to = -1, typeOver = false;\n        for (let record of records) {\n            let range = this.readMutation(record);\n            if (!range)\n                continue;\n            if (range.typeOver)\n                typeOver = true;\n            if (from == -1) {\n                ({ from, to } = range);\n            }\n            else {\n                from = Math.min(range.from, from);\n                to = Math.max(range.to, to);\n            }\n        }\n        let apply = from > -1 || newSel;\n        if (!apply || !this.onChange(from, to, typeOver)) {\n            if (this.view.docView.dirty) {\n                this.ignore(() => this.view.docView.sync());\n                this.view.docView.dirty = 0 /* Not */;\n            }\n            this.view.docView.updateSelection();\n        }\n        this.clearSelection();\n    }\n    readMutation(rec) {\n        let cView = this.view.docView.nearest(rec.target);\n        if (!cView || cView.ignoreMutation(rec))\n            return null;\n        cView.markDirty();\n        if (rec.type == \"childList\") {\n            let childBefore = findChild(cView, rec.previousSibling || rec.target.previousSibling, -1);\n            let childAfter = findChild(cView, rec.nextSibling || rec.target.nextSibling, 1);\n            return { from: childBefore ? cView.posAfter(childBefore) : cView.posAtStart,\n                to: childAfter ? cView.posBefore(childAfter) : cView.posAtEnd, typeOver: false };\n        }\n        else { // \"characterData\"\n            return { from: cView.posAtStart, to: cView.posAtEnd, typeOver: rec.target.nodeValue == rec.oldValue };\n        }\n    }\n    destroy() {\n        this.stop();\n        if (this.intersection)\n            this.intersection.disconnect();\n        for (let dom of this.scrollTargets)\n            dom.removeEventListener(\"scroll\", this.onScroll);\n        window.removeEventListener(\"scroll\", this.onScroll);\n        clearTimeout(this.parentCheck);\n    }\n}\nfunction findChild(cView, dom, dir) {\n    while (dom) {\n        let curView = ContentView.get(dom);\n        if (curView && curView.parent == cView)\n            return curView;\n        let parent = dom.parentNode;\n        dom = parent != cView.dom ? parent : dir > 0 ? dom.nextSibling : dom.previousSibling;\n    }\n    return null;\n}\n\nconst LineSep = \"\\ufdda\"; // A Unicode 'non-character', used to denote newlines internally\nfunction applyDOMChange(view, start, end, typeOver) {\n    let change, newSel;\n    let sel = view.state.selection.primary, bounds;\n    if (start > -1 && (bounds = view.docView.domBoundsAround(start, end, 0))) {\n        let { from, to } = bounds;\n        let selPoints = view.docView.impreciseHead || view.docView.impreciseAnchor ? [] : selectionPoints(view.contentDOM, view.root);\n        let reader = new DOMReader(selPoints);\n        reader.readRange(bounds.startDOM, bounds.endDOM);\n        newSel = selectionFromPoints(selPoints, from);\n        let preferredPos = sel.from, preferredSide = null;\n        // Prefer anchoring to end when Backspace is pressed\n        if (view.inputState.lastKeyCode === 8 && view.inputState.lastKeyTime > Date.now() - 100) {\n            preferredPos = sel.to;\n            preferredSide = \"end\";\n        }\n        let diff = findDiff(view.state.doc.slice(from, to, LineSep), reader.text, preferredPos - from, preferredSide);\n        if (diff)\n            change = new Change(from + diff.from, from + diff.toA, reader.text.slice(diff.from, diff.toB).split(LineSep));\n    }\n    else if (view.hasFocus) {\n        let domSel = getSelection(view.root);\n        let { impreciseHead: iHead, impreciseAnchor: iAnchor } = view.docView;\n        let head = iHead && iHead.node == domSel.focusNode && iHead.offset == domSel.focusOffset ? view.state.selection.primary.head\n            : view.docView.posFromDOM(domSel.focusNode, domSel.focusOffset);\n        let anchor = iAnchor && iAnchor.node == domSel.anchorNode && iAnchor.offset == domSel.anchorOffset\n            ? view.state.selection.primary.anchor\n            : selectionCollapsed(domSel) ? head : view.docView.posFromDOM(domSel.anchorNode, domSel.anchorOffset);\n        if (head != sel.head || anchor != sel.anchor)\n            newSel = EditorSelection.single(anchor, head);\n    }\n    if (!change && !newSel)\n        return false;\n    // Heuristic to notice typing over a selected character\n    if (!change && typeOver && !sel.empty && newSel && newSel.primary.empty)\n        change = new Change(sel.from, sel.to, view.state.doc.sliceLines(sel.from, sel.to));\n    if (change) {\n        let startState = view.state;\n        // Android browsers don't fire reasonable key events for enter,\n        // backspace, or delete. So this detects changes that look like\n        // they're caused by those keys, and reinterprets them as key\n        // events.\n        if (browser.android &&\n            ((change.from == sel.from && change.to == sel.to &&\n                change.length == 1 && change.text.length == 2 &&\n                dispatchKey(view, \"Enter\", 10)) ||\n                (change.from == sel.from - 1 && change.to == sel.to && change.length == 0 &&\n                    dispatchKey(view, \"Backspace\", 8)) ||\n                (change.from == sel.from && change.to == sel.to + 1 && change.length == 0 &&\n                    dispatchKey(view, \"Delete\", 46))))\n            return view.state != startState;\n        let tr = startState.t();\n        if (change.from >= sel.from && change.to <= sel.to && change.to - change.from >= (sel.to - sel.from) / 3) {\n            let before = sel.from < change.from ? startState.doc.slice(sel.from, change.from, LineSep) : \"\";\n            let after = sel.to > change.to ? startState.doc.slice(change.to, sel.to, LineSep) : \"\";\n            tr.replaceSelection((before + change.text.join(LineSep) + after).split(LineSep));\n        }\n        else {\n            tr.change(change);\n            if (newSel && !tr.selection.primary.eq(newSel.primary))\n                tr.setSelection(tr.selection.replaceRange(newSel.primary));\n        }\n        view.dispatch(tr.scrollIntoView().annotate(Transaction.userEvent, \"input\"));\n        return true;\n    }\n    else if (newSel && !newSel.primary.eq(sel)) {\n        let tr = view.state.t().setSelection(newSel);\n        if (view.inputState.lastSelectionTime > Date.now() - 50) {\n            if (view.inputState.lastSelectionOrigin == \"keyboard\")\n                tr.scrollIntoView();\n            else\n                tr.annotate(Transaction.userEvent, view.inputState.lastSelectionOrigin);\n        }\n        view.dispatch(tr);\n        return true;\n    }\n    return false;\n}\nfunction findDiff(a, b, preferredPos, preferredSide) {\n    let minLen = Math.min(a.length, b.length);\n    let from = 0;\n    while (from < minLen && a.charCodeAt(from) == b.charCodeAt(from))\n        from++;\n    if (from == minLen && a.length == b.length)\n        return null;\n    let toA = a.length, toB = b.length;\n    while (toA > 0 && toB > 0 && a.charCodeAt(toA - 1) == b.charCodeAt(toB - 1)) {\n        toA--;\n        toB--;\n    }\n    if (preferredSide == \"end\") {\n        let adjust = Math.max(0, from - Math.min(toA, toB));\n        preferredPos -= toA + adjust - from;\n    }\n    if (toA < from && a.length < b.length) {\n        let move = preferredPos <= from && preferredPos >= toA ? from - preferredPos : 0;\n        from -= move;\n        toB = from + (toB - toA);\n        toA = from;\n    }\n    else if (toB < from) {\n        let move = preferredPos <= from && preferredPos >= toB ? from - preferredPos : 0;\n        from -= move;\n        toA = from + (toA - toB);\n        toB = from;\n    }\n    return { from, toA, toB };\n}\nclass DOMReader {\n    constructor(points) {\n        this.points = points;\n        this.text = \"\";\n    }\n    readRange(start, end) {\n        if (!start)\n            return;\n        let parent = start.parentNode;\n        for (let cur = start;;) {\n            this.findPointBefore(parent, cur);\n            this.readNode(cur);\n            let next = cur.nextSibling;\n            if (next == end)\n                break;\n            let view = ContentView.get(cur), nextView = ContentView.get(next);\n            if ((view ? view.breakAfter : isBlockElement(cur)) ||\n                ((nextView ? nextView.breakAfter : isBlockElement(next)) && !(cur.nodeName == \"BR\" && !cur.cmIgnore)))\n                this.text += LineSep;\n            cur = next;\n        }\n        this.findPointBefore(parent, end);\n    }\n    readNode(node) {\n        if (node.cmIgnore)\n            return;\n        let view = ContentView.get(node);\n        let fromView = view && view.overrideDOMText;\n        let text;\n        if (fromView != null)\n            text = fromView.join(LineSep);\n        else if (node.nodeType == 3)\n            text = node.nodeValue;\n        else if (node.nodeName == \"BR\")\n            text = node.nextSibling ? LineSep : \"\";\n        else if (node.nodeType == 1)\n            this.readRange(node.firstChild, null);\n        if (text != null) {\n            this.findPointIn(node, text.length);\n            this.text += text;\n        }\n    }\n    findPointBefore(node, next) {\n        for (let point of this.points)\n            if (point.node == node && node.childNodes[point.offset] == next)\n                point.pos = this.text.length;\n    }\n    findPointIn(node, maxLen) {\n        for (let point of this.points)\n            if (point.node == node)\n                point.pos = this.text.length + Math.min(point.offset, maxLen);\n    }\n}\nfunction isBlockElement(node) {\n    return node.nodeType == 1 && /^(DIV|P|LI|UL|OL|BLOCKQUOTE|DD|DT|H\\d|SECTION|PRE)$/.test(node.nodeName);\n}\nclass DOMPoint {\n    constructor(node, offset) {\n        this.node = node;\n        this.offset = offset;\n        this.pos = -1;\n    }\n}\nfunction selectionPoints(dom, root) {\n    let result = [];\n    if (root.activeElement != dom)\n        return result;\n    let { anchorNode, anchorOffset, focusNode, focusOffset } = getSelection(root);\n    if (anchorNode) {\n        result.push(new DOMPoint(anchorNode, anchorOffset));\n        if (focusNode != anchorNode || focusOffset != anchorOffset)\n            result.push(new DOMPoint(focusNode, focusOffset));\n    }\n    return result;\n}\nfunction selectionFromPoints(points, base) {\n    if (points.length == 0)\n        return null;\n    let anchor = points[0].pos, head = points.length == 2 ? points[1].pos : anchor;\n    return anchor > -1 && head > -1 ? EditorSelection.single(anchor + base, head + base) : null;\n}\nfunction dispatchKey(view, name, code) {\n    let options = { key: name, code: name, keyCode: code, which: code, cancelable: true };\n    let down = new KeyboardEvent(\"keydown\", options);\n    view.contentDOM.dispatchEvent(down);\n    let up = new KeyboardEvent(\"keyup\", options);\n    view.contentDOM.dispatchEvent(up);\n    return down.defaultPrevented || up.defaultPrevented;\n}\n\n// The editor's update state machine looks something like this:\n//\n//     Idle  Updating  Idle (unchecked)  Measuring  Idle\n//                                               \n//                                         Updating (measure)\n//\n// The difference between 'Idle' and 'Idle (unchecked)' lies in\n// whether a layout check has been scheduled. A regular update through\n// the `update` method updates the DOM in a write-only fashion, and\n// relies on a check (scheduled with `requestAnimationFrame`) to make\n// sure everything is where it should be and the viewport covers the\n// visible code. That check continues to measure and then optionally\n// update until it reaches a coherent state.\n/// An editor view represents the editor's user interface. It holds\n/// the editable DOM surface, and possibly other elements such as the\n/// line number gutter. It handles events and dispatches state\n/// transactions for editing actions.\nclass EditorView {\n    /// Construct a new view. You'll usually want to put `view.dom` into\n    /// your document after creating a view, so that the user can see\n    /// it.\n    constructor(config = {}) {\n        this.plugins = [];\n        this.editorAttrs = {};\n        this.contentAttrs = {};\n        /// @internal\n        this.updateState = 2 /* Updating */;\n        /// @internal\n        this.measureScheduled = -1;\n        /// @internal\n        this.measureRequests = [];\n        this.contentDOM = document.createElement(\"div\");\n        this.scrollDOM = document.createElement(\"div\");\n        this.scrollDOM.className = themeClass(\"scroller\");\n        this.scrollDOM.appendChild(this.contentDOM);\n        this.dom = document.createElement(\"div\");\n        this.dom.appendChild(this.scrollDOM);\n        this.dispatch = config.dispatch || ((tr) => this.update([tr]));\n        this.root = (config.root || document);\n        this.viewState = new ViewState(config.state || EditorState.create());\n        this.plugins = this.state.facet(viewPlugin).map(spec => PluginInstance.create(spec, this));\n        this.observer = new DOMObserver(this, (from, to, typeOver) => applyDOMChange(this, from, to, typeOver), () => this.measure());\n        this.docView = new DocView(this);\n        this.inputState = new InputState(this);\n        this.mountStyles();\n        this.updateAttrs();\n        this.updateState = 0 /* Idle */;\n        ensureGlobalHandler();\n        this.requestMeasure();\n    }\n    /// The current editor state.\n    get state() { return this.viewState.state; }\n    /// To be able to display large documents without consuming too much\n    /// memory or overloading the browser, CodeMirror only draws the\n    /// code that is visible (plus a margin around it) to the DOM. This\n    /// property tells you the extent of the current drawn viewport, in\n    /// document positions.\n    get viewport() { return this.viewState.viewport; }\n    /// When there are, for example, large collapsed ranges in the\n    /// viewport, its size can be a lot bigger than the actual visible\n    /// content. Thus, if you are doing something like styling the\n    /// content in the viewport, it is preferable to only do so for\n    /// these ranges, which are the subset of the viewport that is\n    /// actually drawn.\n    get visibleRanges() { return this.viewState.visibleRanges; }\n    /// Update the view for the given array of transactions. This will\n    /// update the visible document and selection to match the state\n    /// produced by the transactions, and notify view plugins of the\n    /// change.\n    update(transactions) {\n        if (this.updateState != 0 /* Idle */)\n            throw new Error(\"Calls to EditorView.update are not allowed while an update is in progress\");\n        this.updateState = 2 /* Updating */;\n        let state = this.state;\n        for (let tr of transactions) {\n            if (tr.startState != state)\n                throw new RangeError(\"Trying to update state with a transaction that doesn't start from the current state.\");\n            state = tr.apply();\n        }\n        let update = new ViewUpdate(this, state, transactions);\n        if (state.doc != this.state.doc || transactions.some(tr => tr.selectionSet && !tr.annotation(Transaction.preserveGoalColumn)))\n            this.inputState.goalColumns.length = 0;\n        let scrollTo = transactions.some(tr => tr.scrolledIntoView) ? state.selection.primary.head : -1;\n        this.viewState.update(update, scrollTo);\n        if (!update.empty)\n            this.updatePlugins(update);\n        let redrawn = this.docView.update(update);\n        this.inputState.ensureHandlers(this);\n        if (this.state.facet(styleModule) != this.styleModules)\n            this.mountStyles();\n        this.updateAttrs();\n        this.updateState = 0 /* Idle */;\n        if (redrawn || scrollTo > -1)\n            this.requestMeasure();\n    }\n    updatePlugins(update) {\n        let prevSpecs = update.prevState.facet(viewPlugin), specs = update.state.facet(viewPlugin);\n        if (prevSpecs != specs) {\n            let newPlugins = [], reused = [];\n            for (let spec of specs) {\n                let found = prevSpecs.indexOf(spec);\n                if (found < 0) {\n                    newPlugins.push(PluginInstance.create(spec, this));\n                }\n                else {\n                    let plugin = this.plugins[found].update(update);\n                    reused.push(plugin);\n                    newPlugins.push(plugin);\n                }\n            }\n            for (let plugin of this.plugins)\n                if (plugin.destroy && reused.indexOf(plugin) < 0)\n                    plugin.destroy();\n            this.plugins = newPlugins;\n        }\n        else {\n            for (let i = 0; i < this.plugins.length; i++)\n                this.plugins[i] = this.plugins[i].update(update);\n        }\n    }\n    /// @internal\n    measure() {\n        if (this.measureScheduled > -1)\n            cancelAnimationFrame(this.measureScheduled);\n        this.measureScheduled = 1; // Prevent requestMeasure calls from scheduling another animation frame\n        for (let i = 0;; i++) {\n            this.updateState = 1 /* Measuring */;\n            let changed = this.viewState.measure(this.docView, i > 0);\n            let measuring = this.measureRequests;\n            if (!changed && !measuring.length)\n                break;\n            this.measureRequests = [];\n            if (i > 5) {\n                console.warn(\"Viewport failed to stabilize\");\n                break;\n            }\n            let measured = measuring.map(m => m.read(this));\n            let update = new ViewUpdate(this, this.state);\n            update.flags |= changed;\n            this.updateState = 2 /* Updating */;\n            this.updatePlugins(update);\n            if (changed)\n                this.docView.update(update);\n            for (let i = 0; i < measuring.length; i++)\n                measuring[i].write(measured[i], this);\n            if (!(changed & 4 /* Viewport */) && this.measureRequests.length == 0)\n                break;\n        }\n        this.updateState = 0 /* Idle */;\n        this.measureScheduled = -1;\n    }\n    updateAttrs() {\n        let editorAttrs = combineAttrs(this.state.facet(editorAttributes), {\n            class: themeClass(\"wrap\") + (this.hasFocus ? \" cm-focused \" : \" \") +\n                baseThemeID + \" \" + this.state.facet(theme).join(\" \")\n        });\n        updateAttrs(this.dom, this.editorAttrs, editorAttrs);\n        this.editorAttrs = editorAttrs;\n        let contentAttrs = combineAttrs(this.state.facet(contentAttributes), {\n            spellcheck: \"false\",\n            contenteditable: \"true\",\n            class: themeClass(\"content\"),\n            style: `${browser.tabSize}: ${this.state.tabSize}`\n        });\n        updateAttrs(this.contentDOM, this.contentAttrs, contentAttrs);\n        this.contentAttrs = contentAttrs;\n    }\n    mountStyles() {\n        this.styleModules = this.state.facet(styleModule);\n        StyleModule.mount(this.root, this.styleModules.concat(baseTheme).reverse());\n    }\n    /// Look up a translation for the given phrase (via the\n    /// [`phrases`](#view.EditorView^phrases) facet), or return the\n    /// original string if no translation is found.\n    phrase(phrase) {\n        for (let map of this.state.facet(phrases)) {\n            if (Object.prototype.hasOwnProperty.call(map, phrase))\n                return map[phrase];\n        }\n        return phrase;\n    }\n    /// Find the DOM parent node and offset (child offset if `node` is\n    /// an element, character offset when it is a text node) at the\n    /// given document position.\n    domAtPos(pos) {\n        return this.docView.domAtPos(pos);\n    }\n    /// Find the document position at the given DOM node. Can be useful\n    /// for associating positions with DOM events. Will raise an error\n    /// when `node` isn't part of the editor content.\n    posAtDOM(node, offset = 0) {\n        return this.docView.posFromDOM(node, offset);\n    }\n    readMeasured() {\n        if (this.updateState == 2 /* Updating */)\n            throw new Error(\"Reading the editor layout isn't allowed during an update\");\n        if (this.updateState == 0 /* Idle */ && this.measureScheduled > -1)\n            this.measure();\n    }\n    /// Make sure plugins get a chance to measure the DOM before the\n    /// next frame. Calling this is preferable to messing with the DOM\n    /// directly from, for example, an even handler, because it'll make\n    /// sure measuring and drawing done by other components is\n    /// synchronized, avoiding unnecessary DOM layout computations.\n    requestMeasure(request) {\n        if (this.measureScheduled < 0)\n            this.measureScheduled = requestAnimationFrame(() => this.measure());\n        if (request) {\n            if (request.key != null)\n                for (let i = 0; i < this.measureRequests.length; i++) {\n                    if (this.measureRequests[i].key === request.key) {\n                        this.measureRequests[i] = request;\n                        return;\n                    }\n                }\n            this.measureRequests.push(request);\n        }\n    }\n    /// Collect all values provided by the active plugins for a given\n    /// field.\n    pluginField(field) {\n        // FIXME make this error when called during plugin updating\n        let result = [];\n        for (let plugin of this.plugins)\n            plugin.takeField(field, result);\n        return result;\n    }\n    /// Get the value of a specific plugin, if present. Note that\n    /// plugins that crash can be dropped from a view, so even when you\n    /// know you registered a given plugin, it is recommended to check\n    /// the return value of this method.\n    plugin(plugin) {\n        for (let inst of this.plugins)\n            if (inst.spec == plugin)\n                return inst.value;\n        return null;\n    }\n    /// Find the line or block widget at the given vertical position.\n    /// `editorTop`, if given, provides the vertical position of the top\n    /// of the editor. It defaults to the editor's screen position\n    /// (which will force a DOM layout).\n    blockAtHeight(height, editorTop) {\n        this.readMeasured();\n        return this.viewState.blockAtHeight(height, ensureTop(editorTop, this.contentDOM));\n    }\n    /// Find information for the line at the given vertical position.\n    /// The resulting block info might hold another array of block info\n    /// structs in its `type` field if this line consists of more than\n    /// one block.\n    lineAtHeight(height, editorTop) {\n        this.readMeasured();\n        return this.viewState.lineAtHeight(height, ensureTop(editorTop, this.contentDOM));\n    }\n    /// Find the height information for the given line.\n    lineAt(pos, editorTop) {\n        this.readMeasured();\n        return this.viewState.lineAt(pos, ensureTop(editorTop, this.contentDOM));\n    }\n    /// Iterate over the height information of the lines in the\n    /// viewport.\n    viewportLines(f, editorTop) {\n        let { from, to } = this.viewport;\n        this.viewState.forEachLine(from, to, f, ensureTop(editorTop, this.contentDOM));\n    }\n    /// The editor's total content height.\n    get contentHeight() {\n        return this.viewState.heightMap.height + this.viewState.paddingTop + this.viewState.paddingBottom;\n    }\n    /// Compute cursor motion from the given position, in the given\n    /// direction, by the given unit. Since this might involve\n    /// temporarily mutating the DOM selection, you can pass the action\n    /// type this will be used for to, in case the editor selection is\n    /// set to the new position right away, avoid an extra DOM selection\n    /// change.\n    movePos(start, direction, granularity = \"character\", action = \"move\") {\n        return movePos(this, start, direction, granularity, action);\n    }\n    /// Get the document position at the given screen coordinates.\n    /// Returns -1 if no valid position could be found.\n    posAtCoords(coords) {\n        this.readMeasured();\n        return posAtCoords(this, coords);\n    }\n    /// Get the screen coordinates at the given document position.\n    coordsAtPos(pos) {\n        this.readMeasured();\n        return this.docView.coordsAt(pos);\n    }\n    /// The default width of a character in the editor. May not\n    /// accurately reflect the width of all characters.\n    get defaultCharacterWidth() { return this.viewState.heightOracle.charWidth; }\n    /// The default height of a line in the editor.\n    get defaultLineHeight() { return this.viewState.heightOracle.lineHeight; }\n    /// The text direction (`direction` CSS property) of the editor.\n    get textDirection() { return this.viewState.heightOracle.direction; }\n    /// Start a custom mouse selection event.\n    startMouseSelection(event, update) {\n        this.focus();\n        this.inputState.startMouseSelection(this, event, update);\n    }\n    /// Check whether the editor has focus.\n    get hasFocus() {\n        return this.root.activeElement == this.contentDOM;\n    }\n    /// Put focus on the editor.\n    focus() {\n        this.observer.ignore(() => {\n            focusPreventScroll(this.contentDOM);\n            this.docView.updateSelection();\n        });\n    }\n    /// Clean up this editor view, removing its element from the\n    /// document, unregistering event handlers, and notifying\n    /// plugins. The view instance can no longer be used after\n    /// calling this.\n    destroy() {\n        for (let plugin of this.plugins)\n            plugin.destroy();\n        this.inputState.destroy();\n        this.dom.remove();\n        this.observer.destroy();\n        if (this.measureScheduled > -1)\n            cancelAnimationFrame(this.measureScheduled);\n    }\n    /// Create a theme extension. The argument object should map [theme\n    /// selectors](#view.themeClass) to styles, which are (potentially\n    /// nested) [style\n    /// declarations](https://github.com/marijnh/style-mod#documentation)\n    /// providing the CSS styling for the selector.\n    static theme(spec) {\n        let prefix = StyleModule.newName();\n        return [theme.of(prefix), styleModule.of(buildTheme(prefix, spec))];\n    }\n    /// Create an extension that adds styles to the base theme.\n    static baseTheme(spec) {\n        return Precedence.Fallback.set(styleModule.of(buildTheme(baseThemeID, spec)));\n    }\n}\n/// Facet that registers [view plugins](#view.ViewPlugin). Usually,\n/// it is more convenient to use\n/// [`ViewPlugin.register`](#view.ViewPlugin^register).\nEditorView.plugin = viewPlugin;\n/// Facet to add a [style\n/// module](https://github.com/marijnh/style-mod#readme) to an editor\n/// view. The view will ensure that the module is registered in its\n/// [document root](#view.EditorConfig.root).\nEditorView.styleModule = styleModule;\n/// Facet that can be used to add DOM event handlers. The value\n/// should be an object mapping event names to handler functions. The\n/// first such function to return true will be assumed to have handled\n/// that event, and no other handlers or built-in behavior will be\n/// activated for it.\nEditorView.domEventHandlers = domEventHandlers;\n/// Facet used to configure whether a given selection drag event\n/// should move or copy the selection. The given predicate will be\n/// called with the `mousedown` event, and can return `true` when\n/// the drag should move the content.\nEditorView.dragMovesSelection = dragMovesSelection;\n/// Facet used to configure whether a given selecting click adds\n/// a new range to the existing selection or replaces it entirely.\nEditorView.clickAddsSelectionRange = clickAddsSelectionRange;\n/// A facet that determines which [decorations](#view.Decoration)\n/// are shown in the view. See also [view\n/// plugins](#view.EditorView^decorations), which have a separate\n/// mechanism for providing decorations.\nEditorView.decorations = decorations;\n/// Registers translation phrases. The\n/// [`phrase`](#view.EditorView.phrase) method will look through all\n/// objects registered with this facet to find translations for\n/// its argument.\nEditorView.phrases = phrases;\n/// Facet that provides attributes for the editor's editable DOM\n/// element.\nEditorView.contentAttributes = contentAttributes;\n/// Facet that provides editor DOM attributes for the editor's\n/// outer element.\nEditorView.editorAttributes = editorAttributes;\nfunction ensureTop(given, dom) {\n    return given == null ? dom.getBoundingClientRect().top : given;\n}\nlet resizeDebounce = -1;\nfunction ensureGlobalHandler() {\n    window.addEventListener(\"resize\", () => {\n        if (resizeDebounce == -1)\n            resizeDebounce = setTimeout(handleResize, 50);\n    });\n}\nfunction handleResize() {\n    resizeDebounce = -1;\n    let found = document.querySelectorAll(\".cm-content\");\n    for (let i = 0; i < found.length; i++) {\n        let docView = ContentView.get(found[i]);\n        if (docView)\n            docView.editorView.requestMeasure();\n    }\n}\n\n/// @internal\nconst __test = { HeightMap, HeightOracle, MeasuredHeights, QueryType };\n\nexport { BlockInfo, BlockType, Decoration, EditorView, PluginField, ViewPlugin, ViewUpdate, WidgetType, __test, themeClass };\n","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar lezer = require('lezer');\n\n// This file was generated by lezer-generator. You probably shouldn't edit it.\nconst \n  noSemi = 180,\n  PostfixOp = 3,\n  insertSemi = 181,\n  templateContent = 182,\n  templateDollarBrace = 183,\n  templateEnd = 184;\n\n/* Hand-written tokenizers for JavaScript tokens that can't be\n   expressed by lezer's built-in tokenizer. */\n\nconst newline = [10, 13, 8232, 8233];\nconst space = [9, 11, 12, 32, 133, 160, 5760, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8239, 8287, 12288];\n\nconst braceR = 125, braceL = 123, semicolon = 59, slash = 47, star = 42,\n      plus = 43, minus = 45, dollar = 36, backtick = 96, backslash = 92;\n\n// FIXME this should technically enter block comments\nfunction newlineBefore(input, pos) {\n  for (let i = pos - 1; i >= 0; i--) {\n    let prev = input.get(i);\n    if (newline.includes(prev)) return true\n    if (!space.includes(prev)) break\n  }\n  return false\n}\n\nconst insertSemicolon = new lezer.ExternalTokenizer((input, token, stack) => {\n  let pos = token.start, next = input.get(pos);\n  if ((next == braceR || next == -1 || newlineBefore(input, pos)) && stack.canShift(insertSemi))\n    token.accept(insertSemi, token.start);\n}, {contextual: true});\n\nconst noSemicolon = new lezer.ExternalTokenizer((input, token, stack) => {\n  let pos = token.start, next = input.get(pos++);\n  if (space.includes(next) || newline.includes(next)) return\n  if (next == slash) {\n    let after = input.get(pos++);\n    if (after == slash || after == star) return\n  }\n  if (next != braceR && next != semicolon && next != -1 && !newlineBefore(input, token.start) &&\n      stack.canShift(noSemi))\n    token.accept(noSemi, token.start);\n}, {contextual: true});\n\nconst postfix = new lezer.ExternalTokenizer((input, token, stack) => {\n  let pos = token.start, next = input.get(pos++);\n  if ((next == plus || next == minus) && next == input.get(pos++) &&\n      !newlineBefore(input, token.start) && stack.canShift(PostfixOp))\n    token.accept(PostfixOp, pos);\n}, {contextual: true});\n\nconst template = new lezer.ExternalTokenizer((input, token) => {\n  let pos = token.start, afterDollar = false;\n  for (;;) {\n    let next = input.get(pos++);\n    if (next < 0) {\n      if (pos - 1 > token.start) token.accept(templateContent, pos - 1);\n      break\n    } else if (next == backtick) {\n      if (pos == token.start + 1) token.accept(templateEnd, pos);\n      else token.accept(templateContent, pos - 1);\n      break\n    } else if (next == braceL && afterDollar) {\n      if (pos == token.start + 2) token.accept(templateDollarBrace, pos);\n      else token.accept(templateContent, pos - 2);\n      break\n    } else if (next == 10 /* \"\\n\" */ && pos > token.start + 1) {\n      // Break up template strings on lines, to avoid huge tokens\n      token.accept(templateContent, pos);\n      break\n    } else if (next == backslash && pos != input.length) {\n      pos++;\n    }\n    afterDollar = next == dollar;\n  }\n});\n\n// This file was generated by lezer-generator. You probably shouldn't edit it.\nconst parser = lezer.Parser.deserialize({\n  states: \"!2bOYOSOOO$QOSO'#FvO&{O!lO'#CmO(tOSO'#CqO*pO!lO'#GkOXOS'#Gk'#GkO,lX#tO'#C{O,vOSO'#D]O/qOSO'#DcO1aOSO'#DmOXOS'#Dv'#DvO3VOSO'#DuO3ZO!lO'#GhO5]OSO'#E^OXOW'#Gh'#GhOXOS'#Gq'#GqO5aOSO'#FeO5eO!fO'#FfOXOS'#G_'#G_OXOS(3Cy(3CyQXOSOOO/qOSO'#D_O5lOSO'#EcO5pOSO'#CjO5zOSO'#DuO6UOSO'#EdO6`OSO'#CcO6|OSO'#ElO7^OSO'#EoO7eOSO'#EuO7eOSO'#EwOYOSO'#EyO7eOSO'#E{O7eOSO'#FOO7iOSO'#FUO7mO!gO'#FYO/qOSO'#F[O7wO!gO'#F^O8RO!gO'#FaO5eO!fO'#FcOXOS,5<R,5<RO8]O!lO'#CmO:qOSO,59]O:uOSO'#FyO:|OSO(3C|O<rOYO'#GmOXOS'#Gm'#GmO>[OSO,59pO>cO`O'#DVO?VOSO'#DvO?jOSO'#GeO?wO!fO'#GdO6UOSO'#GcO@[OSO'#GcO@fOSO'#DnO5pOSO'#DtO5}OSO'#DuO@pO!fO'#FxO/qOSO'#FiOXOS,59h,59hOAWOSO'#DaOB|O`O,5:dO/qOSO,5:dO/qOSO,5:fO/qOSO,5:fO/qOSO,5:fO/qOSO,5:fO/qOSO,5:fO/qOSO,5:fO/qOSO,5:fO/qOSO,5:fO/qOSO,5:fO/qOSO,5:fO/qOSO,5:fOCQOSO,5:uOXOW,5:z,5:zOXOW,5:{,5:{OXOW,5:|,5:|ODpX#tO'#FwO/qOSO'#GjOXXO(3Cz(3CzODzX#tO,59gOEOOSO'#FzOXOS(3C}(3C}OGyOSO,59wOG}O!lO,59}OIyOSO,5:XOI}OSO,59YOJROSO,5:aO/qOSO,5:xOYOSO,5<POXOS'#Gb'#GbOXOS,5<Q,5<QOKqO!lO,59yOXOS'#Cm'#CmOMmOSO,5:}OXOS'#Ce'#CeOMtOSO'#CnO7iOSO,59UONUOSO,59UO5}OSO,59UONYOSO,5:aO5pOSO,59UON^OSO'#CqONnO`O'#CtOXOS'#Ge'#GeO! OO!fO,5;OO! YOSO'#EhO! aOSO'#CjO! eOSO,58}O! iOSO,58}OXOS,58},58}O!#XO!fO,58}O!#cOSO'#EnO!#jOSO'#GsO!#qOSO,5;WO!#uOSO,5;WO5eO!fO,5;WO!#yOSO'#EqOXOS'#Er'#ErOXOS'#Es'#EsOYOSO,5;ZO!%uOSO,5;ZO/qOSO'#DmOYOSO,5;aOYOSO,5;cO!%yOSO,5;eOYOSO,5;gO!%}OSO,5;jO!&ROSO,5;pOXOS,5;t,5;tO/qOSO,5;tO5eO!fO,5;vOXOS,5;x,5;xO!)`OSO,5;xOXOS,5;{,5;{O!)`OSO,5;{OXOS,5;},5;}OXOS1G.w1G.wOXOS,5<U,5<UO!)dOYO-E9hOXOS,5=X,5=XOXOW1G/[1G/[O!*|OSO'#CwOXOS'#Go'#GoO/qOSO'#GoO!+gOSO'#GoO!,QOSO'#DWO!,_O`O'#DWOCQOSO'#DWO!,lOSO'#GnO!,sOSO,59qO!,zOSO'#CvO!-XOSO'#GfO!-`OSO,59`O!-dO`O'#DWO/qOSO,5=OO@[OSO,5<}O!-zOSO'#GPO!.UOSO(3DSOXOS,5<},5<}O!.lO`O'#DqOXOW,5:Y,5:YO/qOSO,5:YO!/VOSO,5:YO7iOSO,5:`ONUOSO,5:`O5}OSO,5:`OXOS,5<T,5<TO!/^O!lO-E9gO!1YOYO'#GpO/qOSO'#GpO!2rOSO,59{OXOW'#Cw'#CwOXOW1G0O1G0OO!2vOSO1G0OO!2zO!lO1G0QO!4vO!lO1G0QO!6rO!lO1G0QO!8nO!lO1G0QO!:jO!lO1G0QO!<fO!lO1G0QO!>bO!lO1G0QO!@^O!lO1G0QO!BYO!lO1G0QO!DUO!lO1G0QO!FQO!lO1G0QO!G|OrO'#CmOCQOSO'#DcO!I{OSO'#DuO!JPOrO1G0aO!KfOrO'#GhO!MXOSO'#E^OCQOSO'#D_OXXO,5<S,5<SO!M]OWO,5=UOXOW1G/R1G/ROXOS,5<V,5<VOXOS1G/c1G/cOXOW1G/s1G/sOXOS1G.t1G.tOXOW1G/{1G/{O!MaO!lO1G0dOXOS1G1k1G1kOXOW1G/e1G/eOXOS1G0i1G0iO/qOSO1G0iOXOS1G.p1G.pO7iOSO1G.pONUOSO1G.pOJROSO1G/{O5}OSO1G.pO6UOSO'#CvO# ]O!fO'#GQO6UOSO'#FqO5eO!fO1G0jOXOS'#DO'#DOO# gOSO'#GrO# qOSO,5;SO# uOSO1G.iOXOS1G.i1G.iO5eO!fO1G.iO# yOSO'#CmO#!TOSO'#GtO#![OSO,5;YO#!`OSO'#GtO#!dOSO'#GTO#!kOSO(3DWOXOS,5=_,5=_O5lOSO1G0rO#!xOSO1G0rOXOS1G0r1G0rO#!|OYO,5=aO#$oOSO,5=aO#$yOSO,5;]O#&lOSO,5;]O6UOSO,5=aOXOS1G0u1G0uOYOSO1G0uOXOS1G0{1G0{OXOS1G0}1G0}O7eOSO1G1PO#&pOSO1G1RO#)wOSO'#FQOXOS1G1U1G1UO7iOSO1G1[O#,xOSO1G1[O5eO!fO1G1`OXOS1G1b1G1bOXOS'#F`'#F`O5eO!fO1G1dO5eO!fO1G1gO#-POSO,5=ZOCQOSO,59bO6UOSO,59bO7iOSO,59rOCQOSO,59rOXOS'#D['#D[ONUOSO,59rO#-TOrO,59rO#.mOSO'#GeOXOS,59b,59bO#.wOSO'#GdO#/ROSO'#F{O#/YO`O(3DOOXOS,5=Y,5=YOXOW1G/]1G/]O#/|OSO'#GOO#0TO`O(3DROXOS,5=Q,5=QOXOS1G.z1G.zO!,_O`O,59rO#0hO!lO1G2jOXOS1G2i1G2iOXOS,5<[,5<[O6UOSO,5<[OXOS-E9n-E9nO#2ZO`O'#F}ONUOSO'#DrO!,hO`O'#DrOXO`(3DQ(3DQO#2tOSO,5:]O#2xO`O'#DrO#3VO`O'#DrO#3gOSO1G/tOXOW1G/t1G/tO/qOSO1G/tOXOW1G/z1G/zO7iOSO1G/zONUOSO1G/zO#3kOSO'#F|O#3rOSO(3DPOXOS,5=[,5=[O!1YOYO,5=[OXOW1G/g1G/gOXOW7+%j7+%jO#5kOrO,59}O#7WOSO,5:aOCQOSO,5:fOCQOSO,5:fOCQOSO,5:fOCQOSO,5:fOCQOSO,5:fOCQOSO,5:fOCQOSO,5:fOCQOSO,5:fOCQOSO,5:fOCQOSO,5:fOCQOSO,5:fO/qOSO7+%{OCQOSO,5:xO#8vOrO,59yO#:cOSO,5:aO#:gO!lO'#FxOXXO1G2p1G2pO#3gOSO7+&TOXOS7+$[7+$[O7iOSO7+$[OXOW7+%g7+%gONUOSO7+$[OXOS,5<],5<]OXOS-E9o-E9oOXOS7+&U7+&UO#<cOSO'#GRO#<jOSO(3DUOXOS,5=^,5=^O#<tO`O,5=^OXOS1G0n1G0nO5eO!fO7+$TOXOS7+$T7+$TO#<xOSO'#GSO#=POSO(3DVOXOS,5=`,5=`OXOS1G0t1G0tO5lOSO,5=`OXOS,5<`,5<`OXOS-E9r-E9rO#=ZOSO7+&^O5eO!fO7+&^O/qOSO1G2{O/qOSO1G2|O#=_OSO1G0wO#?QOSO1G0wO#?UOSO1G0wO#@wO!fO1G2{OXOS7+&a7+&aO5eO!fO7+&kOYOSO7+&mO#A[OSO'#GUOXOS'#Gw'#GwOXOS(3DX(3DXO#D]OSO,5;lO/qOSO'#FRO#DaOSO'#FTOXOS7+&v7+&vO#DeOSO7+&vO6UOSO7+&vOXOS7+&z7+&zOXOS7+'O7+'OOXOS7+'R7+'ROXOS1G2u1G2uO#GoOrO1G.|O#IXOSO1G.|OXOS1G/^1G/^O#IcOrO1G/^O7iOSO1G/^OCQOSO,5=OOXOS,5<W,5<WOCQOSO'#DWOXOS-E9j-E9jOXOS,5<Z,5<ZOXOS-E9m-E9mONUOSO1G/^OXOS3)/Y3)/YOXO`,5<Y,5<YO7iOSO,5:^ONUOSO,5:^OXOW1G/w1G/wO!,hO`O,5:^O#J{O`O,5:^OXOW7+%`7+%`O#3gOSO7+%`OXOW7+%f7+%fO7iOSO7+%fOXOS,5<X,5<XO#KYOYO-E9kO/qOSO,5<XOXOS1G2v1G2vO#LrOrO'#GkO#N_OrO1G0QO$ zOrO1G0QO$#gOrO1G0QO$%SOrO1G0QO$&oOrO1G0QO$([OrO1G0QO$)wOrO1G0QO$+dOrO1G0QO$-POrO1G0QO$.lOrO1G0QO$0XOrO1G0QO$1tOrO1G0aO$3ZO!lO<<IgO$5VOrO1G0dO#7WOSO1G/{OXOS<<Io<<IoOXOS<<Gv<<GvO7iOSO<<GvOXOS,5<^,5<^O$6rOSO-E9pOXOS'#Ej'#EjO$6|OSO1G2xOXOS<<Go<<GoOXOS,5<_,5<_OXOS-E9q-E9qO$7TOSO,5<_O#!TOSO1G2zO$7XOSO<<IxOXOS<<Ix<<IxO$7]OSO7+(gO$7aOSO7+(hOXOS7+&c7+&cO$7eOSO7+&cO$7iOSO7+&cO$9[OSO7+&cO/qOSO7+(gO/qOSO7+(hOXOS<<JV<<JVOXOS<<JX<<JXOXOS,5<a,5<aOXOS1G1W1G1WO$9`OSO,5;mOXOS,5;o,5;oO7iOSO<<JbO$9dOSO<<JbOCQOSO7+$hOXOS7+$x7+$xO$9hOrO1G2jO7iOSO7+$xOXO`1G/x1G/xO7iOSO1G/xONUOSO1G/xO!,hO`O1G/xOXOW<<Hz<<HzOXOW<<IQ<<IQO$;QOYO3)/VO$<jOrO'#FxOCQOSO'#FiOCQOSO7+%{OXOSAN=bAN=bO$>VO`O1G1xOXOS7+(d7+(dO5lOSO1G1yOXOS7+(f7+(fO5eO!fOAN?dOXOS<<LR<<LROXOS<<LS<<LSOXOS<<I}<<I}O$>ZOSO<<I}O$>_OSO<<I}O$@QOSO<<LRO$@UOSO<<LSOXOS1G1X1G1XOXOSAN?|AN?|O7iOSOAN?|O$@YOrO<<HSOXOS<<Hd<<HdOXO`7+%d7+%dO7iOSO7+%dONUOSO7+%dO$ArOrO-E9gO$C_OrO<<IgOXOS'#Ek'#EkOXOS8;$v8;$vOXOS8;$w8;$wOXOSG25OG25OOXOSAN?iAN?iO$DzOSOAN?iOXOSANAmANAmOXOSANAnANAnO$EOOSOG25hOXO`<<IO<<IOO7iOSO<<IOOXOSG25TG25TO7iOSOLD+SOXO`AN>jAN>jOXOS!$'Nn!$'Nn\",\n  stateData: \"$HeSOSTOS%QOS~WjOZ^O[bO_hO`gOcXOfROiVOl^Os^Ot^Ou^Ov^Ow^O!SeO!WWO!XWO!YWO!ZWO![WO!]WO!^WO!_WO!`WO!cfO#XiO#YiO#ZiO#akO#dlO#jmO#lnO#noO#ppO#sqO#yrO#}sO$PtO$RuO$UvO$WwO%SQO%]UO~WjOZ^O[bO_hO`gOcXOfROiVOl^Os^Ot^Ou^Ov^Ow^O!SeO!WWO!XWO!YWO!ZWO![WO!]WO!^WO!_WO!`WO!cfO#XiO#YiO#ZiO#akO#dlO#jmO#lnO#noO#ppO#sqO#yrO#}sO$PtO$RuO$UvO$WwO%SQO%]UO$y$jX~RrX[rXcrXfrXm$SXnrXqrX!`rX!kaX!mrX!orX!prX!qrX!rrX!srX!trX!urX!vrX!wrX!xrX!yrX!zrX!{rX!|rX#OrX#RrX${rX%]rX~Z^O_!YO`!XOcXOd!UOfROi!QOl^Oq|Os^Ot^Ou^Ov^Ow^O!SeO!WWO!XWO!YWO!ZWO![WO!]WO!^WO!_WO!`WO!c!WO%SyO%]UOg$mPg%VP~R!mOc!^Of!`Oq![O!`!cO!m!_O!o!aO!p!bO!q!bO!r!bO!s!dO!t!eO!u!eO!v!eO!w!fO!x!gO!y!hO!z!iO!{!jO!|!kO#O!lO%]UO[%_X${%_X!U%_Xg%_X%`%_Xi%_Xm%_X~$|!rO$}!qO%O$kP~WjOZ^O[bO_hO`gOcXOfROiVOl^Os^Ot^Ou^Ov^Ow^O!SeO!WWO!XWO!YWO!ZWO![WO!]WO!^WO!_WO!`WO!cfO#XiO#YiO#ZiO#akO#dlO#jmO#lnO#noO#ppO#sqO#yrO#}sO$PtO$RuO$UvO$WwO%SQO%]UO!Q$nP~Z^O_!YO`!XOcXOfROi!QOl^Os^Ot^Ou^Ov^Ow^O!SeO!WWO!XWO!YWO!ZWO![WO!]WO!^WO!_WO!`WO!c!WO%SyO%]UO~Z^O_!YO`!XOcXOd!UOfROi!QOl^Os^Ot^Ou^Ov^Ow^O!SeO!WWO!XWO!YWO!ZWO![WO!]WO!^WO!_WO!`WO!c!WO%SyO%]UO!U%VP~!k!zO~n!{O#R!{OR%[X[%[Xc%[Xf%[Xq%[X!`%[X!m%[X!o%[X!p%[X!q%[X!r%[X!s%[X!t%[X!u%[X!v%[X!w%[X!x%[X!y%[X!z%[X!{%[X!|%[X#O%[X${%[X%]%[Xg%[X!U%[X%`%[Xi%[Xm%[X~n!{O~m!|O~[!}O${!}O~%S#QO~c#TO%S#QO%T#SO~`#YOc#TO%S#QO~f#ZOi#[O%S#QO~]#bO_#`O`gOi#_O!cfO#XiO#YiO#ZiO%T#SO~Z#iOi#eO%S#QO%T#SOY%gP~c#jO!W#nO~c#oO~iVO~[!}O$z#wO${!}O~[!}O$z#zO${!}O~[!}O$z#|O${!}O~RrXcrXfrXgaXgrXnaXnrXqaXqrX!`rX!kaX!mrX!orX!prX!qrX!rrX!srX!trX!urX!vrX!wrX!xrX!yrX!zrX!{rX!|rX#OrX#RrX%]rX[rX${rX!UaX!UrX%`rX#hrXirXmrX~g$OO~q|Og$mX~Z^O_!YO`!XOcXOfROi!QOl^Os^Ot^Ou^Ov^Ow^O!SeO!WWO!XWO!YWO!ZWO![WO!]WO!^WO!_WO!`WO!c!WO%SyO%]UOg$^Zq$^Z~R!mOc!^Of!`Oq|O!`!cO!m!_O!o!aO!p!bO!q!bO!r!bO!s!dO!t!eO!u!eO!v!eO!w!fO!x!gO!y!hO!z!iO!{!jO!|!kO#O!lO%]UOg$mP~g$SOg$SO~Z$WOd$ZOf$VOl$WO{$aO|$YO}$YO%T#SO%Z$TO!Q%YP!Q%bP~g%XXn%XXq%XX!k!jX!U%XX!Q%XX~n!{Og%XXq%XX!U%XX~n$bOg%WXq%WX!U%WX[%WX${%WX~q$eOg$sP!U$sP~i$gO!d$iO%S#QO~q![O[$lX${$lX!U$lXg$lXi$lXm$lX~Z^O_!YO`!XOcXOd$qOfROi!QOl^Os^Ot^Ou^Ov^Ow^O!SeO!WWO!XWO!YWO!ZWO![WO!]WO!^WO!_WO!`WO!c!WO%SyO%]UO!U%dP~%Z$sO~Z^O_!YO`!XOcXOfROi!QOl^Os^Ot^Ou^Ov^Ow^O!S%XO!W%SO!X%SO!Y%SO!Z%SO![%SO!]%SO!^%SO!_%SO!`%SO!c!WO%S%RO%]UO~$|!rO$}!qO%O$kX~%O%[O~WjOZ^O[bO_hO`gOcXOfROiVOl^Os^Ot^Ou^Ov^Ow^O!SeO!WWO!XWO!YWO!ZWO![WO!]WO!^WO!_WO!`WO!cfO#XiO#YiO#ZiO#akO#dlO#jmO#lnO#noO#ppO#sqO#yrO#}sO$PtO$RuO$UvO$WwO%SQO%]UO!Q$nX~!Q%^O~c!^Of!`O!m!_O%]UOR!Va[!Vaq!Va!`!Va!o!Va!p!Va!q!Va!r!Va!s!Va!t!Va!u!Va!v!Va!w!Va!x!Va!y!Va!z!Va!{!Va!|!Va#O!Va${!Vag!Va!U!Va%`!Vai!Vam!Va~!U%_O~!U%`O~Z^O_!YO`!XOcXOfROiVOl^Os^Ot^Ou^Ov^Ow^O!SeO!WWO!XWO!YWO!ZWO![WO!]WO!^WO!_WO!`WO!c!WO%SyO%]UO~R!mOc!^Of!`O!`!cO!m!_O!o!aO!p!bO!q!bO!r!bO!s!dO!t!eO!u!eO!v!eO!w!fO!x!gO!y!hO!z!iO!{!jO!|!kO#O!lO%]UO[!Raq!Ra${!Rag!Ra!U!Ra%`!Rai!Ram!Ra~i$gO!d%fO~d!UOf#ZOi#[O%S#QO!U%VP~c#TO~!k%jO~d!UOf#ZOi#[O%S#QOg%VP~Z$^Od%lOl$^O%Z$sO!Q%YP~q%nO[$tP${$tP~%S%pO!Q%fP~`#YO~Y%sO~Z^O_hO`gOcXOfROi!QOl^Os^Ot^Ou^Ov^Ow^O!SeO!WWO!XWO!YWO!ZWO![WO!]WO!^WO!_WO!`WO!cfO%SyO%]UO~Y%sO[!}O${!}O~%S%vO!Q%hP~q%{OY$wP~#]%}O~Y&OO~Z^O[&SO_!YO`!XOcXOfROi!QOl^Os^Ot^Ou^Ov^Ow^O!SeO!WWO!XWO!YWO!ZWO![WO!]WO!^WO!_WO!`WO!c!WO#X&UO#Y&UO#Z&UO%SyO%]UO~c#jO~#j&ZO~i&]O~#z&`O#{&_OW#xaZ#xa[#xa_#xa`#xac#xaf#xai#xal#xas#xat#xau#xav#xaw#xa!S#xa!W#xa!X#xa!Y#xa!Z#xa![#xa!]#xa!^#xa!_#xa!`#xa!c#xa#X#xa#Y#xa#Z#xa#a#xa#d#xa#j#xa#l#xa#n#xa#p#xa#s#xa#y#xa#}#xa$P#xa$R#xa$U#xa$W#xa$y#xa%S#xa%]#xa!Q#xa#q#xa]#xa#v#xa~%S&cO~R!mOc!^Of!`O!`!cO!m!_O!o!aO!p!bO!q!bO!r!bO!s!dO!t!eO!u!eO!v!eO!w!fO!x!gO!y!hO!z!iO!{!jO!|!kO#O!lO%]UOg$^cq$^c~c!OXmkXm!OXnkXqkXq!OX!QkX!Q!OX~m&hOn&gOc%cXm%cXqjXq%cX!QjX!Q%cX~c#TOm&jOqzX!QzX~Z$UOf$VOl$UO%Z&kO~q&rO!Q$oP~!Q&tO!Q&tO~m&hOn&gOqjX!QjX~q&vO!Q$rP~!Q&xO~Z$UOf$VOl$UO|&yO}&yO%T#SO%Z&kO~q$eOg$sX!U$sX~d&}Of#ZOi#[O%S#QOg$dZq$dZ!U$dZ~['SO{'UO|'RO}'RO!g'VO%T#SO%Z&kO!Q$qP~i$gO!d'YO~R!mOc!^Of!`O!`!cO!m!_O!o!aO!p!bO!q!bO!r!bO!s!dO!t!eO!u!eO!v!eO!w!fO!x!gO!y!hO!z!iO!{!jO!|!kO#O!lO%]UO[$]cq$]c${$]c!U$]cg$]c%`$]ci$]cm$]c~R!mOc!^Of!`Oq'_O!`!cO!m!_O!o!aO!p!bO!q!bO!r!bO!s!dO!t!eO!u!eO!v!eO!w!fO!x!gO!y!hO!z!iO!{!jO!|!kO#O!lO%]UO!U$pP~!U'bO~g'cO~R!mOc!^Of!`O!m!_O%]UO[!niq!ni!`!ni!o!ni!p!ni!q!ni!r!ni!s!ni!t!ni!u!ni!v!ni!w!ni!x!ni!y!ni!z!ni!{!ni!|!ni#O!ni${!nig!ni!U!ni%`!nii!nim!ni~R!mOc!^Of!`O!m!_O!o!aO%]UO[!niq!ni!`!ni!p!ni!q!ni!r!ni!s!ni!t!ni!u!ni!v!ni!w!ni!x!ni!y!ni!z!ni!{!ni!|!ni#O!ni${!nig!ni!U!ni%`!nii!nim!ni~R!mOc!^Of!`O!m!_O!o!aO!p!bO!q!bO!r!bO%]UO[!niq!ni!`!ni!s!ni!t!ni!u!ni!v!ni!w!ni!x!ni!y!ni!z!ni!{!ni!|!ni#O!ni${!nig!ni!U!ni%`!nii!nim!ni~R!mOc!^Of!`O!`!cO!m!_O!o!aO!p!bO!q!bO!r!bO%]UO[!niq!ni!s!ni!t!ni!u!ni!v!ni!w!ni!x!ni!y!ni!z!ni!{!ni!|!ni#O!ni${!nig!ni!U!ni%`!nii!nim!ni~R!mOc!^Of!`O!`!cO!m!_O!o!aO!p!bO!q!bO!r!bO!s!dO%]UO[!niq!ni!t!ni!u!ni!v!ni!w!ni!x!ni!y!ni!z!ni!{!ni!|!ni#O!ni${!nig!ni!U!ni%`!nii!nim!ni~R!mOc!^Of!`O!`!cO!m!_O!o!aO!p!bO!q!bO!r!bO!s!dO!t!eO!u!eO!v!eO%]UO[!niq!ni!w!ni!x!ni!y!ni!z!ni!{!ni!|!ni#O!ni${!nig!ni!U!ni%`!nii!nim!ni~R!mOc!^Of!`O!`!cO!m!_O!o!aO!p!bO!q!bO!r!bO!s!dO!t!eO!u!eO!v!eO!w!fO%]UO[!niq!ni!x!ni!y!ni!z!ni!{!ni!|!ni#O!ni${!nig!ni!U!ni%`!nii!nim!ni~R!mOc!^Of!`O!`!cO!m!_O!o!aO!p!bO!q!bO!r!bO!s!dO!t!eO!u!eO!v!eO!w!fO!x!gO%]UO[!niq!ni!y!ni!z!ni!{!ni!|!ni#O!ni${!nig!ni!U!ni%`!nii!nim!ni~R!mOc!^Of!`O!`!cO!m!_O!o!aO!p!bO!q!bO!r!bO!s!dO!t!eO!u!eO!v!eO!w!fO!x!gO!y!hO%]UO[!niq!ni!z!ni!{!ni!|!ni#O!ni${!nig!ni!U!ni%`!nii!nim!ni~R!mOc!^Of!`O!`!cO!m!_O!o!aO!p!bO!q!bO!r!bO!s!dO!t!eO!u!eO!v!eO!w!fO!x!gO!y!hO!z!iO%]UO[!niq!ni!{!ni!|!ni#O!ni${!nig!ni!U!ni%`!nii!nim!ni~R!mOc!^Of!`O!`!cO!m!_O!o!aO!p!bO!q!bO!r!bO!s!dO!t!eO!u!eO!v!eO!w!fO!x!gO!y!hO!z!iO!{!jO%]UO[!niq!ni!|!ni#O!ni${!nig!ni!U!ni%`!nii!nim!ni~RrXcrXfrXnrX!`rX!kaX!mrX!orX!prX!qrX!rrX!srX!trX!urX!vrX!wrX!xrX!yrX!zrX!{rX!|rX#OrX#PrX#RrX%]rXnaXqaXqrX!QaX!QrX~!k'eO~R!mOc!^Of!`O!`'hO!m!_O!o'fO!p'gO!q'gO!r'gO!s'iO!t'jO!u'jO!v'jO!w'kO!x'lO!y'mO!z'nO!{'oO!|'pO#O!lO#P'qO%]UO~n'rO#R'rOR%[Xc%[Xf%[X!`%[X!m%[X!o%[X!p%[X!q%[X!r%[X!s%[X!t%[X!u%[X!v%[X!w%[X!x%[X!y%[X!z%[X!{%[X!|%[X#O%[X#P%[X%]%[Xq%[X!Q%[X~n'rO~%`'vO~R!mOc!^Of!`O!`!cO!m!_O!o!aO!p!bO!q!bO!r!bO!s!dO!t!eO!u!eO!v!eO!w!fO!x!gO!y!hO!z!iO!{!jO!|!kO#O!lO%]UO[#Qiq#Qi${#Qig#Qi!U#Qi%`#Qii#Qim#Qi~q%nO[$tX${$tX~q(QO#](SO!Q$uP~!Q(TO~Z(UO~qaX!QaX#]rX~q(XO!Q$vP~!Q(ZO~#]([O~q%{OY$wX~i#eO%S#QOY$hZq$hZ~Z(`O~n!{O!u(aO#R!{O#h(bOR%[X[%[Xc%[Xf%[Xq%[X!`%[X!m%[X!o%[X!p%[X!q%[X!r%[X!s%[X!t%[X!v%[X!w%[X!x%[X!y%[X!z%[X!{%[X!|%[X#O%[X%]%[X~n!{O!u(aO#h(bO~Z^O[(cO_!YO`!XOcXOfROi!QOl^Os^Ot^Ou^Ov^Ow^O!SeO!WWO!XWO!YWO!ZWO![WO!]WO!^WO!_WO!`WO!c!WO%SyO%]UO~[(eO~#q(iOW#oiZ#oi[#oi_#oi`#oic#oif#oii#oil#ois#oit#oiu#oiv#oiw#oi!S#oi!W#oi!X#oi!Y#oi!Z#oi![#oi!]#oi!^#oi!_#oi!`#oi!c#oi#X#oi#Y#oi#Z#oi#a#oi#d#oi#j#oi#l#oi#n#oi#p#oi#s#oi#y#oi#}#oi$P#oi$R#oi$U#oi$W#oi$y#oi%S#oi%]#oi!Q#oi]#oi#v#oi~WjOZ^O[bO](oO_hO`gOcXOfROiVOl^Os^Ot^Ou^Ov^Ow^O!SeO!WWO!XWO!YWO!ZWO![WO!]WO!^WO!_WO!`WO!cfO#XiO#YiO#ZiO#akO#dlO#jmO#lnO#noO#ppO#sqO#v(nO#yrO#}sO$PtO$RuO$UvO$WwO%SQO%]UO!Q$xP~c(rOiVO~g(vO~R!mOc!^Of!`O!`'hO!m!_O!o'fO!p'gO!q'gO!r'gO!s'iO!t'jO!u'jO!v'jO!w'kO!x'lO!y'mO!z'nO!{'oO!|'pO#O!lO%]UOqza!Qza~n'rOq%XX!Q%XX~n(|Oq%WX!Q%WX~q&rO!Q$oX~Z$UOd)OOf$VOl$UO{$aO|$YO}$YO%T#SO%Z&kOq$`Z!Q$`Z~q&vO!Q$rX~Z$^Od%lOl$^O%Z$sOq$cZ!Q$cZ~R!mOc!^Of!`O!`!cO!m!_O!o!aO!p!bO!q!bO!r!bO!s!dO!t!eO!u!eO!v!eO!w!fO!x!gO!y!hO!z!iO!{!jO!|!kO#O!lO%]UOg%Wiq%Wi!U%Wi[%Wi${%Wi~['SO{'UO|'RO}'RO!g'VO%T#SO%Z&kO!Q$qX~!Q)XO~|)YO})YO%T#SO%Z&kO~{)ZO|)YO})YO%T#SO%Z&kO~i$gO~q'_O!U$pX~Z^O_!YO`!XOcXOd)bOfROi!QOl^Os^Ot^Ou^Ov^Ow^O!SeO!WWO!XWO!YWO!ZWO![WO!]WO!^WO!_WO!`WO!c!WO%SyO%]UOq$aZ!U$aZ~c!^Of!`O!m!_O%]UOR!Va!`!Va!o!Va!p!Va!q!Va!r!Va!s!Va!t!Va!u!Va!v!Va!w!Va!x!Va!y!Va!z!Va!{!Va!|!Va#O!Va#P!Vaq!Va!Q!Va~Z^O_!YO`!XOcXOfROiVOl^Os^Ot^Ou^Ov^Ow^O!S%XO!W%SO!X%SO!Y%SO!Z%SO![%SO!]%SO!^%SO!_%SO!`%SO!c!WO%S%RO%]UO~R!mOc!^Of!`O!`'hO!m!_O!o'fO!p'gO!q'gO!r'gO!s'iO!t'jO!u'jO!v'jO!w'kO!x'lO!y'mO!z'nO!{'oO!|'pO#O!lO%]UO#P!Raq!Ra!Q!Ra~!k)sO~q![O%`$lXR$lX[$lXc$lXf$lX!`$lX!m$lX!o$lX!p$lX!q$lX!r$lX!s$lX!t$lX!u$lX!v$lX!w$lX!x$lX!y$lX!z$lX!{$lX!|$lX#O$lX${$lX%]$lXg$lX!U$lXi$lXm$lX~q(QO!Q$uX~%S%pOq$fZ!Q$fZ~%Z)yO~q(XO!Q$vX~%S%vOq$gZ!Q$gZ~Y*QO~Z^O_!YO`!XOcXOfROi!QOl^Os^Ot^Ou^Ov^Ow^O!SeO!U*UO!WWO!XWO!YWO!ZWO![WO!]WO!^WO!_WO!`WO!c!WO%SyO%]UO~[*WO~Z^O[*WO_!YO`!XOcXOfROi!QOl^Os^Ot^Ou^Ov^Ow^O!SeO!WWO!XWO!YWO!ZWO![WO!]WO!^WO!_WO!`WO!c!WO%SyO%]UO~n$bO!u*YO#h*ZO[%WXq%WX${%WX~WjOZ^O[bO](oO_hO`gOcXOfROiVOl^Os^Ot^Ou^Ov^Ow^O!SeO!WWO!XWO!YWO!ZWO![WO!]WO!^WO!_WO!`WO!cfO#XiO#YiO#ZiO#akO#dlO#jmO#lnO#noO#ppO#sqO#v(nO#yrO#}sO$PtO$RuO$UvO$WwO%SQO%]UO!Q$xX~!Q*_O~m*aO~#{*bOW#xqZ#xq[#xq_#xq`#xqc#xqf#xqi#xql#xqs#xqt#xqu#xqv#xqw#xq!S#xq!W#xq!X#xq!Y#xq!Z#xq![#xq!]#xq!^#xq!_#xq!`#xq!c#xq#X#xq#Y#xq#Z#xq#a#xq#d#xq#j#xq#l#xq#n#xq#p#xq#s#xq#y#xq#}#xq$P#xq$R#xq$U#xq$W#xq$y#xq%S#xq%]#xq!Q#xq#q#xq]#xq#v#xq~R!mOc!^Of!`O!`'hO!m!_O!o'fO!p'gO!q'gO!r'gO!s'iO!t'jO!u'jO!v'jO!w'kO!x'lO!y'mO!z'nO!{'oO!|'pO#O!lO%]UOqji!Qji~n*dOqji!Qji~R!mOc!^Of!`O!`'hO!m!_O!o'fO!p'gO!q'gO!r'gO!s'iO!t'jO!u'jO!v'jO!w'kO!x'lO!y'mO!z'nO!{'oO!|'pO#O!lO%]UOqzi!Qzi~|*kO}*kO%T#SO%Z&kO~R!mOc!^Of!`O!`!cO!m!_O!o!aO!p!bO!q!bO!r!bO!s!dO!t!eO!u!eO!v!eO!w!fO!x!gO!y!hO!z!iO!{!jO!|!kO#O!lO%]UOq$ac!U$ac~R!mOc!^Of!`Oq*pO!`'hO!m!_O!o'fO!p'gO!q'gO!r'gO!s'iO!t'jO!u'jO!v'jO!w'kO!x'lO!y'mO!z'nO!{'oO!|'pO#O!lO%]UO#P%_X!Q%_X~R!mOc!^Of!`O!m!_O%]UO!`!ni!o!ni!p!ni!q!ni!r!ni!s!ni!t!ni!u!ni!v!ni!w!ni!x!ni!y!ni!z!ni!{!ni!|!ni#O!ni#P!niq!ni!Q!ni~R!mOc!^Of!`O!m!_O!o'fO%]UO!`!ni!p!ni!q!ni!r!ni!s!ni!t!ni!u!ni!v!ni!w!ni!x!ni!y!ni!z!ni!{!ni!|!ni#O!ni#P!niq!ni!Q!ni~R!mOc!^Of!`O!m!_O!o'fO!p'gO!q'gO!r'gO%]UO!`!ni!s!ni!t!ni!u!ni!v!ni!w!ni!x!ni!y!ni!z!ni!{!ni!|!ni#O!ni#P!niq!ni!Q!ni~R!mOc!^Of!`O!`'hO!m!_O!o'fO!p'gO!q'gO!r'gO%]UO!s!ni!t!ni!u!ni!v!ni!w!ni!x!ni!y!ni!z!ni!{!ni!|!ni#O!ni#P!niq!ni!Q!ni~R!mOc!^Of!`O!`'hO!m!_O!o'fO!p'gO!q'gO!r'gO!s'iO%]UO!t!ni!u!ni!v!ni!w!ni!x!ni!y!ni!z!ni!{!ni!|!ni#O!ni#P!niq!ni!Q!ni~R!mOc!^Of!`O!`'hO!m!_O!o'fO!p'gO!q'gO!r'gO!s'iO!t'jO!u'jO!v'jO%]UO!w!ni!x!ni!y!ni!z!ni!{!ni!|!ni#O!ni#P!niq!ni!Q!ni~R!mOc!^Of!`O!`'hO!m!_O!o'fO!p'gO!q'gO!r'gO!s'iO!t'jO!u'jO!v'jO!w'kO%]UO!x!ni!y!ni!z!ni!{!ni!|!ni#O!ni#P!niq!ni!Q!ni~R!mOc!^Of!`O!`'hO!m!_O!o'fO!p'gO!q'gO!r'gO!s'iO!t'jO!u'jO!v'jO!w'kO!x'lO%]UO!y!ni!z!ni!{!ni!|!ni#O!ni#P!niq!ni!Q!ni~R!mOc!^Of!`O!`'hO!m!_O!o'fO!p'gO!q'gO!r'gO!s'iO!t'jO!u'jO!v'jO!w'kO!x'lO!y'mO%]UO!z!ni!{!ni!|!ni#O!ni#P!niq!ni!Q!ni~R!mOc!^Of!`O!`'hO!m!_O!o'fO!p'gO!q'gO!r'gO!s'iO!t'jO!u'jO!v'jO!w'kO!x'lO!y'mO!z'nO%]UO!{!ni!|!ni#O!ni#P!niq!ni!Q!ni~R!mOc!^Of!`O!`'hO!m!_O!o'fO!p'gO!q'gO!r'gO!s'iO!t'jO!u'jO!v'jO!w'kO!x'lO!y'mO!z'nO!{'oO%]UO!|!ni#O!ni#P!niq!ni!Q!ni~R!mOc!^Of!`O!`'hO!m!_O!o'fO!p'gO!q'gO!r'gO!s'iO!t'jO!u'jO!v'jO!w'kO!x'lO!y'mO!z'nO!{'oO!|'pO#O!lO#P*qO%]UO~R!mOc!^Of!`O!`!cO!m!_O!o!aO!p!bO!q!bO!r!bO!s!dO!t!eO!u!eO!v!eO!w!fO!x!gO!y!hO!z!iO!{!jO!|!kO%]UO[!}yq!}y#O!}y${!}yg!}y!U!}y%`!}yi!}ym!}y~R!mOc!^Of!`O!`'hO!m!_O!o'fO!p'gO!q'gO!r'gO!s'iO!t'jO!u'jO!v'jO!w'kO!x'lO!y'mO!z'nO!{'oO!|'pO#O!lO%]UO#P#Qiq#Qi!Q#Qi~#]*sOq$fc!Q$fc~q(QO!Q$uP~#]*uO~Z*wO~!U*xO~!U*yO~!U*zO~Z^O_!YO`!XOcXOfROi!QOl^Os^Ot^Ou^Ov^Ow^O!SeO!U*zO!WWO!XWO!YWO!ZWO![WO!]WO!^WO!_WO!`WO!c!WO%SyO%]UO~[*|O~m+PO~!U+RO~R!mOc!^Of!`O!`'hO!m!_O!o'fO!p'gO!q'gO!r'gO!s'iO!t'jO!u'jO!v'jO!w'kO!x'lO!y'mO!z'nO!{'oO!|'pO#O!lO%]UOq%Wi!Q%Wi~R!mOc!^Of!`O!`!cO!m!_O!o!aO!p!bO!q!bO!r!bO!s!dO!t!eO!u!eO!v!eO!w!fO!x!gO!y!hO!z!iO!{!jO!|!kO#O!lO%]UOq$ak!U$ak~q*pOR$lXc$lXf$lX!`$lX!m$lX!o$lX!p$lX!q$lX!r$lX!s$lX!t$lX!u$lX!v$lX!w$lX!x$lX!y$lX!z$lX!{$lX!|$lX#O$lX#P$lX%]$lX!Q$lX~%Z+ZO~!U+_O~Z^O_!YO`!XOcXOfROi!QOl^Os^Ot^Ou^Ov^Ow^O!SeO!U+_O!WWO!XWO!YWO!ZWO![WO!]WO!^WO!_WO!`WO!c!WO%SyO%]UO~!U+aO~!U+bO~R!mOc!^Of!`O!`'hO!m!_O!o'fO!p'gO!q'gO!r'gO!s'iO!t'jO!u'jO!v'jO!w'kO!x'lO!y'mO!z'nO!{'oO!|'pO#O!lO%]UOqjy!Qjy~R!mOc!^Of!`O!`'hO!m!_O!o'fO!p'gO!q'gO!r'gO!s'iO!t'jO!u'jO!v'jO!w'kO!x'lO!y'mO!z'nO!{'oO!|'pO#O!lO%]UOq$]c#P$]c!Q$]c~R!mOc!^Of!`O!`'hO!m!_O!o'fO!p'gO!q'gO!r'gO!s'iO!t'jO!u'jO!v'jO!w'kO!x'lO!y'mO!z'nO!{'oO!|'pO%]UO#O!}y#P!}yq!}y!Q!}y~!U+fO~#{+gOW#x!ZZ#x!Z[#x!Z_#x!Z`#x!Zc#x!Zf#x!Zi#x!Zl#x!Zs#x!Zt#x!Zu#x!Zv#x!Zw#x!Z!S#x!Z!W#x!Z!X#x!Z!Y#x!Z!Z#x!Z![#x!Z!]#x!Z!^#x!Z!_#x!Z!`#x!Z!c#x!Z#X#x!Z#Y#x!Z#Z#x!Z#a#x!Z#d#x!Z#j#x!Z#l#x!Z#n#x!Z#p#x!Z#s#x!Z#y#x!Z#}#x!Z$P#x!Z$R#x!Z$U#x!Z$W#x!Z$y#x!Z%S#x!Z%]#x!Z!Q#x!Z#q#x!Z]#x!Z#v#x!Z~T%ZS%S%Q!pw~%S%Z~\",\n  goto: \"!$O%lPPPPPPP%mP%}PPPP&pPP'U*`PP-bPP-bP/s/zPPP0S3SP4OPPPPP6[6[8WPPP8^8uP6[P:mP6[PPPPPPPPP;s6[PP>O>bP6[6[>fP@hP6[PPPPPPPPPPPPPP6[PP6[P6[6[6[&pBhPPPB|PCPCS%mPCV%mPC]C]C]P%mP%mP%mP%mPP%mPCcCfPCf%mPPP%mP%mP%mPCj%mP%mP%m%mDQDWD^DiDpDvD|ETEZEaEhEnEuE|FSFYF]F`FdFjFmFpFvFyF|GSGVG]GcGfPPPPPPPPGiPPH_IdIlJWJpPJtPNpNtP!!p!!s!!v!#R!#U!#i!#l!#o!#r!#v!#zmbOPVo!t!|#m#p#q#s&W&](i(jQ#WgQ#ajQ#gkS$Y!Q&rQ$m!XQ%k#YQ&y$aS'R$g'PS)Y'U'VR*k)Zn_OPVjo!t!|#m#p#q#s&W&](i(jR%t#b$pYOPVWehot|!Y![!^!`!a!b!c!d!e!f!g!h!i!j!k!l!q!t!z!{!|#b#j#m#o#p#q#s#w$V$b$i$q%S%X%f%j&S&W&]&g&j'Y'_'e'f'g'h'i'j'k'l'm'n'o'p'q'r(a(b(c(e(i(j(n(|)O)b)s*W*Y*Z*d*p*q*|U!RRX$ZQ#RfQ#Vgf#]i!U#T#Z$e%l%n&U&h&}(rQ#fkQ$j!WQ$l!XS%i#W#YQ%w#eQ']$mQ'{%kQ(^%{Q(_%}Q)}(XQ*P([R+]*u#nZOPRVWXeot|![!^!`!a!b!c!d!e!f!g!h!i!j!k!q!t!z!{!|#b#j#m#o#p#q#s#w$V$b$i$q%f%j&S&W&]'Y'_'q(a(b(c(e(i(j(n)b*W*Y*Z*|Q#UgS#Xh!YQ$k!X!S%T!l$Z%S%X&g&j'e'f'g'h'i'j'k'l'm'n'o'p'r(|)O)s*d*p*qU%h#V#W#YQ&i$XS'[$l$mS'y%i%kQ({&lQ)V'QQ)_']Q)v'{Q*g)SQ*i)WQ+V*jR+e+W#h]OPVWeot|![!^!`!a!b!c!d!e!f!g!h!i!j!k!q!t!z!{!|#b#m#o#p#q#s#w$V$b$i$q%f%j&S&W&]'Y'_'q(a(b(c(e(i(j(n)b*W*Y*Z*|S!SRXf#]i!U#T#Z$e%l%n&U&h&}(r!Q%W!l%S%X&g&j'e'f'g'h'i'j'k'l'm'n'o'p'r(|)O)s*d*p*qQ&R#jR&n$ZS$_!Q#[R)R&vU$^!Q#[&vR$t!_$r^OPRVWXeot|![!^!`!a!b!c!d!e!f!g!h!i!j!k!l!q!t!z!{!|#b#j#m#o#p#q#s#w$V$Z$b$i$q%S%X%f%j&S&W&]&g&j'Y'_'e'f'g'h'i'j'k'l'm'n'o'p'q'r(a(b(c(e(i(j(n(|)O)b)s*W*Y*Z*d*p*q*|#T!oS}!w#P$Q$o$p$v$w$x$y$z${$|$}%O%P%Q%U%b&m&z'a'd's(w(z)a)d)e)f)g)h)i)j)k)l)m)n)o)p)q)r*f*n+S+X+Y!sTOPVXot!`!q!t!z!|#b#j#m#o#p#q#s#w$V$i%f%j&S&W&]'Y'e(a(b(c(e(i(j(n)s*W*Y*Z*|#l[OPRVWXeot|![!^!`!a!b!c!d!e!f!g!h!i!j!k!q!t!z!{!|#b#m#o#p#q#s#w$V$b$i$q%f%j&S&W&]'Y'_'q(a(b(c(e(i(j(n)b*W*Y*Z*|!S%V!l$Z%S%X&g&j'e'f'g'h'i'j'k'l'm'n'o'p'r(|)O)s*d*p*qQ%q#_Q%y#eQ&Q#jQ)x(QR*O(X$s^OPRVWXeot|![!^!`!a!b!c!d!e!f!g!h!i!j!k!l!q!t!z!{!|#b#j#m#o#p#q#s#w$V$Z$b$i$q%S%X%f%j&S&W&]&g&j'Y'_'e'f'g'h'i'j'k'l'm'n'o'p'q'r(a(b(c(e(i(j(n(|)O)b)s*W*Y*Z*d*p*q*|Q$[!QR)P&rY$U!Q$Y$a&r&yS'Q$g'PU)W'R'U'VS*j)Y)ZR+W*klbOPVo!t!|#m#p#q#s&W&](i(jQ#urS%a!z'eQ%g#UQ'Z$kQ'x%hS'z%j)sQ(p&_Q(q&`Q(y&iQ)^'[Q)u'yQ*e({Q*h)VQ*m)_Q*r)vQ+Q*bQ+T*gQ+U*iQ+c+RQ+d+VQ+h+eR+i+g#O!nS}!w$Q$o$p$v$w$x$y$z${$|$}%O%P%Q%U%b&m&z'a'd(w(z)a)d)e)f)g)h)i)j)k)l)m)n)o)p)q)r*f*n+S+X+YT%d#P's$r^OPRVWXeot|![!^!`!a!b!c!d!e!f!g!h!i!j!k!l!q!t!z!{!|#b#j#m#o#p#q#s#w$V$Z$b$i$q%S%X%f%j&S&W&]&g&j'Y'_'e'f'g'h'i'j'k'l'm'n'o'p'q'r(a(b(c(e(i(j(n(|)O)b)s*W*Y*Z*d*p*q*|Q#pmQ#qnQ#spQ#tqR(h&ZQ$h!WQ%e#RQ'X$jQ)['WQ)t'wR*l)]T'S$g'P#nZOPRVWXeot|![!^!`!a!b!c!d!e!f!g!h!i!j!k!q!t!z!{!|#b#j#m#o#p#q#s#w$V$b$i$q%f%j&S&W&]'Y'_'q(a(b(c(e(i(j(n)b*W*Y*Z*|S#Xh!Y!T%T!l$Z%S%X&g&j'e'f'g'h'i'j'k'l'm'n'o'p'r(|)O)s*d*p*q#l[OPRVWXeot|![!^!`!a!b!c!d!e!f!g!h!i!j!k!q!t!z!{!|#b#m#o#p#q#s#w$V$b$i$q%f%j&S&W&]'Y'_'q(a(b(c(e(i(j(n)b*W*Y*Z*|!S%V!l$Z%S%X&g&j'e'f'g'h'i'j'k'l'm'n'o'p'r(|)O)s*d*p*qR&Q#jn_OPVjo!t!|#m#p#q#s&W&](i(jR&S#jR#djR)z(SR+[*sQ#fkR(^%{Q#mlR&W#nR&^#tT(k&](jl`OPVo!t!|#m#p#q#s&W&](i(jQ&d#zR&e#|QPORxPQ!pUR%Y!pQ!ZSU$n!Z'u*oR*o)dS{R}R$P{Q!tVR%]!tQ&q$[R(}&qS'^$p'aR)`'^Q'P$gR)U'PQ&u$_R)Q&uS$d!V$cR&|$dQ%m#^R'|%mS(P%q)zR)w(PS(W%w*PR)|(WQ%z#fR(]%zQ(j&]R*^(jRdOR!sUT!]S)dQ!ORR$R}R!vVR&s$[Q'`$pR)c'aR'T$gR&w$_Q$f!VR&{$cR%o#^Q(R%qR*t)zQ(Y%wR*v*PR%|#fR(m&]ScOPS!uV!tQ#roQ%c!|Q&V#mQ&X#pQ&Y#qQ&[#sQ(g&WS(k&](jR*](iQ#OaQ#vsQ#yuQ#{vQ#}wQ%t#dQ&P#iQ&b#xQ(O%oQ(V%uQ(s&aQ(t&dQ(u&eQ){(UQ*R(`Q*[(hR+^*wSzR#ZT!yX#TW!VRX#T#ZS#^i&UQ$c!US&o$Z%lQ'O$eQ'}%nR)T&}b!TRXi!U#T#Z$e%n&}S&p$Z%lQ(f&UQ(x&hR*c(rT$`!Q#[!nSOPVXot!`!q!t!z!|#b#j#m#o#p#q#s#w$V$i%f%j&S&W&]'Y(a(b(c(e(i(j(n*W*Y*Z*|Q}RQ!wWQ#PeQ$Q|Q$o![Q$p!^Q$v!aQ$w!bQ$x!cQ$y!dQ$z!eQ${!fQ$|!gQ$}!hQ%O!iQ%P!jQ%Q!kQ%U!lQ%b!{S&m$Z)OQ&z$bQ'a$qQ'd%SQ's%XQ(w&gQ(z&jQ)a'_S)d'e)sQ)e'fQ)f'gQ)g'hQ)h'iQ)i'jQ)j'kQ)k'lQ)l'mQ)m'nQ)n'oQ)o'pQ)q'qQ)r'rQ*f(|Q*n)bQ+S*dQ+X*pR+Y*qT!rU!plaOPVo!t!|#m#p#q#s&W&](i(jS!xX#oQ#xtQ$u!`Q%Z!qS%a!z'eQ%u#bQ&T#jQ&a#wQ&f$VQ'W$iQ'w%fS'z%j)sQ(d&SQ)]'YQ*S(aQ*T(bQ*V(cQ*X(eQ*`(nQ*{*WQ*}*YQ+O*ZR+`*|R!PRR$]!QS$X!Q&rS&l$Y$aR)S&yR$r!^lbOPVo!t!|#m#p#q#s&W&](i(jR#cjR%r#_R#hkR%x#eT#kl#nT#ll#nT(l&](j\",\n  nodeNames: \" Script  PostfixOp LineComment BlockComment Script ExportDeclaration export Star from String ; default FunctionDeclaration async function VariableDefinition ParamList ( Spread ArrayPattern [ ] ObjectPattern { PatternProperty PropertyName Number : Equals TemplateString SequenceExpression , VariableName BooleanLiteral this null super RegExp ArrayExpression ObjectExpression Property async get set PropertyNameDefinition Block } NewExpression new ArgList ) UnaryExpression await yield void typeof delete LogicOp BitOp ArithOp ArithOp ParenthesizedExpression ClassExpression class extends ClassBody MethodDeclaration static FunctionExpression ArrowFunction ParamList Arrow MemberExpression . BinaryExpression ArithOp ArithOp ArithOp ArithOp BitOp CompareOp in instanceof CompareOp BitOp BitOp BitOp LogicOp LogicOp ConditionalExpression LogicOp LogicOp AssignmentExpression UpdateOp PostfixExpression CallExpression TaggedTemplatExpression ClassDeclaration VariableDeclaration let var const ExportGroup as VariableName VariableName ImportDeclaration import ImportGroup ForStatement for ForSpec ForInSpec ForOfSpec of WhileStatement while WithStatement with DoStatement do IfStatement if else SwitchStatement switch SwitchBody CaseLabel case DefaultLabel TryStatement try catch finally ReturnStatement return ThrowStatement throw BreakStatement break Label ContinueStatement continue DebuggerStatement debugger LabeledStatement ExpressionStatement\",\n  nodeProps: [\n    [lezer.NodeProp.delim, 18,\"( )\",21,\"[ ]\",24,\"{ }\",40,\"[ ]\",41,\"{ }\",47,\"{ }\",51,\"( )\",63,\"( )\",67,\"{ }\",104,\"{ }\",110,\"{ }\",113,\"( )\",128,\"{ }\"]\n  ],\n  repeatNodeCount: 15,\n  tokenData: \"<v~R!SX^$_pq$_qr%Srs%itu&]uv&vvw'Twx'exy(Syz(Xz{(^{|(s|})T}!O)Y!O!P)e!P!Q*u!Q!R5i!R![6c![!]8S!]!^8Z!^!_8`!_!`8x!`!a9b!a!b9x!c!}&]!}#O9}#P#Q:S#Q#R:X#R#S&]#S#T:a#T#o&]#o#p:f#p#q:k#q#r:{#r#s;S#y#z$_$f$g$_$g#BY&]#BY#BZ;X#BZ$IS&]$IS$I_;X$I_$I|&]$I|$JO;X$JO$JT&]$JT$JU;X$JU$KV&]$KV$KW;X$KW&FU&]&FU&FV;X&FV~&]~$dY%Q~X^$_pq$_#y#z$_$f$g$_#BY#BZ$_$IS$I_$_$I|$JO$_$JT$JU$_$KV$KW$_&FU&FV$_~%XP!]~!_!`%[~%aP!w~!_!`%d~%iO!w~~%nUZ~OY%iZr%irs&Qs#O%i#O#P&V#P~%i~&VOZ~~&YPO~%i_&dU%ZS%SZtu&]!Q![&]!c!}&]#R#S&]#T#o&]$g~&]~&{P!q~!_!`'OY'TO#RY~'YQ!z~vw'`!_!`'O~'eO!{~~'jUZ~OY'eZw'ewx&Qx#O'e#O#P'|#P~'e~(PPO~'e~(XOc~~(^O!U~~(eQ%TT!rYz{(k!_!`'O~(pP!o~!_!`'O~(xQ!`~{|)O!_!`'O~)TO!_~~)YOq~~)_Q!`~}!O)O!_!`'O~)jQ!mY!O!P)p!Q![){~)sP!O!P)v~){Od~T*QRlT!Q![){!g!h*Z#X#Y*ZT*^R{|*g}!O*g!Q![*mT*jP!Q![*mT*rPlT!Q![*m~*zZ!pYOY+mZz+mz{-f{!P+m!P!Q3z!Q!_+m!_!`4V!`!}+m!}#O4s#O#P5`#P~+mP+rVwPOY+mZ!P+m!P!Q,X!Q!}+m!}#O,p#O#P-]#P~+mP,^UwP#Z#[,X#]#^,X#a#b,X#g#h,X#i#j,X#m#n,XP,sTOY,pZ#O,p#O#P-S#P#Q+m#Q~,pP-VQOY,pZ~,pP-`QOY+mZ~+m~-kYwPOY-fYZ.ZZz-fz{/O{!P-f!P!Q2v!Q!}-f!}#O0^#O#P2d#P~-f~.^ROz.Zz{.g{~.Z~.jTOz.Zz{.g{!P.Z!P!Q.y!Q~.Z~/OOT~~/TYwPOY-fYZ.ZZz-fz{/O{!P-f!P!Q/s!Q!}-f!}#O0^#O#P2d#P~-f~/zUT~wP#Z#[,X#]#^,X#a#b,X#g#h,X#i#j,X#m#n,X~0aWOY0^YZ.ZZz0^z{0y{#O0^#O#P2Q#P#Q-f#Q~0^~0|YOY0^YZ.ZZz0^z{0y{!P0^!P!Q1l!Q#O0^#O#P2Q#P#Q-f#Q~0^~1qTT~OY,pZ#O,p#O#P-S#P#Q+m#Q~,p~2TTOY0^YZ.ZZz0^z{0y{~0^~2gTOY-fYZ.ZZz-fz{/O{~-f~2{_wPOz.Zz{.g{#Z.Z#Z#[2v#[#].Z#]#^2v#^#a.Z#a#b2v#b#g.Z#g#h2v#h#i.Z#i#j2v#j#m.Z#m#n2v#n~.Z~4PQS~OY3zZ~3zZ4^V#RYwPOY+mZ!P+m!P!Q,X!Q!}+m!}#O,p#O#P-]#P~+mP4vTOY4sZ#O4s#O#P5V#P#Q+m#Q~4sP5YQOY4sZ~4sP5cQOY+mZ~+mT5nVlT!O!P6T!Q![6c!g!h*Z#U#V6t#X#Y*Z#c#d7Y#l#m7hT6YRlT!Q![6T!g!h*Z#X#Y*ZT6hSlT!O!P6T!Q![6c!g!h*Z#X#Y*ZT6wQ!Q!R6}!R!S6}T7SQlT!Q!R6}!R!S6}T7]P!Q!Y7`T7ePlT!Q!Y7`T7kR!Q![7t!c!i7t#T#Z7tT7yRlT!Q![7t!c!i7t#T#Z7tZ8ZOmR#PW~8`O[~~8eQ!t~!^!_8k!_!`8s~8pP!s~!_!`'O~8xO!t~~8}Qn~!_!`9T!`!a9]~9YP!w~!_!`%d~9bO!k~~9gQ!t~!_!`8s!`!a9m~9rQ!s~!_!`'O!`!a8k~9}O#O~~:SOf~~:XOg~~:^P!y~!_!`'O~:fO%]~~:kOi~~:pQ!x~!_!`'O#p#q:v~:{O!|~_;SO!Q]%`Q~;XO!^~~;bf%ZS%SZ%Q~X^$_pq$_tu&]!Q![&]!c!}&]#R#S&]#T#o&]#y#z$_$f$g$_$g#BY&]#BY#BZ;X#BZ$IS&]$IS$I_;X$I_$I|&]$I|$JO;X$JO$JT&]$JT$JU;X$JU$KV&]$KV$KW;X$KW&FU&]&FU&FV;X&FV~&]\",\n  tokenizers: [noSemicolon, postfix, 0, 1, 2, 3, insertSemicolon, template],\n  specializeTable: 8160,\n  specializations: [{export:16, from:21, default:26, async:31, function:32, true:70, false:70, this:72, null:74, super:76, new:100, await:109, yield:111, void:112, typeof:114, delete:116, class:130, extends:132, in:166, instanceof:168, let:202, var:204, const:206, as:211, import:218, for:224, of:233, while:236, with:240, do:244, if:248, else:250, switch:254, case:260, try:266, catch:268, finally:270, return:274, throw:278, break:282, continue:288, debugger:292},\n   {async:87, get:89, set:91, static:139}],\n  tokenPrec: 8152\n});\n\nexports.parser = parser;\n","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/// The default maximum length of a `TreeBuffer` node.\nexports.DefaultBufferLength = 1024;\nvar Iteration = /** @class */ (function () {\n    function Iteration(enter, leave) {\n        this.enter = enter;\n        this.leave = leave;\n        this.result = undefined;\n    }\n    Object.defineProperty(Iteration.prototype, \"done\", {\n        get: function () { return this.result !== undefined; },\n        enumerable: true,\n        configurable: true\n    });\n    Iteration.prototype.doEnter = function (type, start, end) {\n        var value = this.enter(type, start, end);\n        if (value === undefined)\n            return true;\n        if (value !== false)\n            this.result = value;\n        return false;\n    };\n    return Iteration;\n}());\nvar nextPropID = 0;\n/// Each [node type](#tree.NodeType) can have metadata associated with\n/// it in props. Instances of this class represent prop names.\nvar NodeProp = /** @class */ (function () {\n    /// Create a new node prop type. You can optionally pass a\n    /// `deserialize` function.\n    function NodeProp(_a) {\n        var deserialize = (_a === void 0 ? {} : _a).deserialize;\n        this.id = nextPropID++;\n        this.deserialize = deserialize || (function () {\n            throw new Error(\"This node type doesn't define a deserialize function\");\n        });\n    }\n    /// Create a string-valued node prop whose deserialize function is\n    /// the identity function.\n    NodeProp.string = function () { return new NodeProp({ deserialize: function (str) { return str; } }); };\n    /// Create a number-valued node prop whose deserialize function is\n    /// just `Number`.\n    NodeProp.number = function () { return new NodeProp({ deserialize: Number }); };\n    /// Creates a boolean-valued node prop whose deserialize function\n    /// returns true for any input.\n    NodeProp.flag = function () { return new NodeProp({ deserialize: function () { return true; } }); };\n    /// Store a value for this prop in the given object. This can be\n    /// useful when building up a prop object to pass to the\n    /// [`NodeType`](#tree.NodeType) constructor. Returns its first\n    /// argument.\n    NodeProp.prototype.set = function (propObj, value) {\n        propObj[this.id] = value;\n        return propObj;\n    };\n    /// This is meant to be used with\n    /// [`NodeGroup.extend`](#tree.NodeGroup.extend) or\n    /// [`Parser.withProps`](#lezer.Parser.withProps) to compute prop\n    /// values for each node type in the group. Takes a [match\n    /// object](#tree.NodeType.match) or function that returns undefined\n    /// if the node type doesn't get this prop, and the prop's value if\n    /// it does.\n    NodeProp.prototype.add = function (match) {\n        return new NodePropSource(this, typeof match == \"function\" ? match : NodeType.match(match));\n    };\n    /// The special node type that the parser uses to represent parse\n    /// errors has this flag set. (You shouldn't use it for custom nodes\n    /// that represent erroneous content.)\n    NodeProp.error = NodeProp.flag();\n    /// Nodes that were produced by skipped expressions (such as\n    /// comments) have this prop set to true.\n    NodeProp.skipped = NodeProp.flag();\n    /// Prop that is used to describe a rule's delimiters. For example,\n    /// a parenthesized expression node would set this to the string `\"(\n    /// )\"` (the open and close strings separated by a space). This is\n    /// added by the parser generator's `@detectDelim` feature, but you\n    /// can also manually add them.\n    NodeProp.delim = NodeProp.string();\n    /// Indicates that this node indicates a top level document.\n    NodeProp.top = NodeProp.flag();\n    return NodeProp;\n}());\nexports.NodeProp = NodeProp;\n/// Type returned by [`NodeProp.add`](#tree.NodeProp.add). Describes\n/// the way a prop should be added to each node type in a node group.\nvar NodePropSource = /** @class */ (function () {\n    /// @internal\n    function NodePropSource(\n    /// @internal\n    prop, \n    /// @internal\n    f) {\n        this.prop = prop;\n        this.f = f;\n    }\n    return NodePropSource;\n}());\nexports.NodePropSource = NodePropSource;\n/// Each node in a syntax tree has a node type associated with it.\nvar NodeType = /** @class */ (function () {\n    /// @internal\n    function NodeType(\n    /// The name of the node type. Not necessarily unique, but if the\n    /// grammar was written properly, different node types with the\n    /// same name within a node group should play the same semantic\n    /// role.\n    name, \n    /// @internal\n    props, \n    /// The id of this node in its group. Corresponds to the term ids\n    /// used in the parser.\n    id) {\n        this.name = name;\n        this.props = props;\n        this.id = id;\n    }\n    /// Retrieves a node prop for this type. Will return `undefined` if\n    /// the prop isn't present on this node.\n    NodeType.prototype.prop = function (prop) { return this.props[prop.id]; };\n    /// Create a function from node types to arbitrary values by\n    /// specifying an object whose property names are node names. Often\n    /// useful with [`NodeProp.add`](#tree.NodeProp.add). You can put\n    /// multiple node names, separated by spaces, in a single property\n    /// name to map multiple node names to a single value.\n    NodeType.match = function (map) {\n        var direct = Object.create(null);\n        for (var prop in map)\n            for (var _i = 0, _a = prop.split(\" \"); _i < _a.length; _i++) {\n                var name = _a[_i];\n                direct[name] = map[prop];\n            }\n        return function (node) { return direct[node.name]; };\n    };\n    /// An empty dummy node type to use when no actual type is available.\n    NodeType.none = new NodeType(\"\", Object.create(null), 0);\n    return NodeType;\n}());\nexports.NodeType = NodeType;\n/// A node group holds a collection of node types. It is used to\n/// compactly represent trees by storing their type ids, rather than a\n/// full pointer to the type object, in a number array. Each parser\n/// [has](#lezer.Parser.group) a node group, and [tree\n/// buffers](#tree.TreeBuffer) can only store collections of nodes\n/// from the same group. A group can have a maximum of 2**16 (65536)\n/// node types in it, so that the ids fit into 16-bit typed array\n/// slots.\nvar NodeGroup = /** @class */ (function () {\n    /// Create a group with the given types. The `id` property of each\n    /// type should correspond to its position within the array.\n    function NodeGroup(\n    /// The node types in this group, by id.\n    types) {\n        this.types = types;\n        for (var i = 0; i < types.length; i++)\n            if (types[i].id != i)\n                throw new RangeError(\"Node type ids should correspond to array positions when creating a node group\");\n    }\n    /// Create a copy of this group with some node properties added. The\n    /// arguments to this method should be created with\n    /// [`NodeProp.add`](#tree.NodeProp.add).\n    NodeGroup.prototype.extend = function () {\n        var props = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            props[_i] = arguments[_i];\n        }\n        var newTypes = [];\n        for (var _a = 0, _b = this.types; _a < _b.length; _a++) {\n            var type = _b[_a];\n            var newProps = null;\n            for (var _c = 0, props_1 = props; _c < props_1.length; _c++) {\n                var source = props_1[_c];\n                var value = source.f(type);\n                if (value !== undefined) {\n                    if (!newProps) {\n                        newProps = Object.create(null);\n                        for (var prop in type.props)\n                            newProps[prop] = type.props[prop];\n                    }\n                    newProps[source.prop.id] = value;\n                }\n            }\n            newTypes.push(newProps ? new NodeType(type.name, newProps, type.id) : type);\n        }\n        return new NodeGroup(newTypes);\n    };\n    return NodeGroup;\n}());\nexports.NodeGroup = NodeGroup;\n/// A subtree is a representation of part of the syntax tree. It may\n/// either be the tree root, or a tagged node.\nvar Subtree = /** @class */ (function () {\n    function Subtree() {\n    }\n    Object.defineProperty(Subtree.prototype, \"name\", {\n        // Shorthand for `.type.name`.\n        get: function () { return this.type.name; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Subtree.prototype, \"depth\", {\n        /// The depth (number of parent nodes) of this subtree\n        get: function () {\n            var d = 0;\n            for (var p = this.parent; p; p = p.parent)\n                d++;\n            return d;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Subtree.prototype, \"root\", {\n        /// The root of the tree that this subtree is part of\n        get: function () {\n            var cx = this;\n            while (cx.parent)\n                cx = cx.parent;\n            return cx;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /// Find the node at a given position. By default, this will return\n    /// the lowest-depth subtree that covers the position from both\n    /// sides, meaning that nodes starting or ending at the position\n    /// aren't entered. You can pass a `side` of `-1` to enter nodes\n    /// that end at the position, or `1` to enter nodes that start\n    /// there.\n    Subtree.prototype.resolve = function (pos, side) {\n        if (side === void 0) { side = 0; }\n        var result = this.resolveAt(pos);\n        // FIXME this is slightly inefficient in that it scans the result\n        // of resolveAt twice (but further complicating child-finding\n        // logic seems unattractive as well)\n        if (side != 0)\n            for (;;) {\n                var child = (side < 0 ? result.childBefore(pos) : result.childAfter(pos));\n                if (!child || (side < 0 ? child.end : child.start) != pos)\n                    break;\n                result = child;\n            }\n        return result;\n    };\n    Object.defineProperty(Subtree.prototype, \"firstChild\", {\n        /// Get the first child of this subtree.\n        get: function () { return this.childAfter(this.start - 1); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Subtree.prototype, \"lastChild\", {\n        /// Find the last child of this subtree.\n        get: function () { return this.childBefore(this.end + 1); },\n        enumerable: true,\n        configurable: true\n    });\n    return Subtree;\n}());\nexports.Subtree = Subtree;\n/// A piece of syntax tree. There are two ways to approach these\n/// trees: the way they are actually stored in memory, and the\n/// convenient way.\n///\n/// Syntax trees are stored as a tree of `Tree` and `TreeBuffer`\n/// objects. By packing detail information into `TreeBuffer` leaf\n/// nodes, the representation is made a lot more memory-efficient.\n///\n/// However, when you want to actually work with tree nodes, this\n/// representation is very awkward, so most client code will want to\n/// use the `Subtree` interface instead, which provides a view on some\n/// part of this data structure, and can be used (through `resolve`,\n/// for example) to zoom in on any single node.\nvar Tree = /** @class */ (function (_super) {\n    __extends(Tree, _super);\n    /// @internal\n    function Tree(\n    /// @internal\n    type, \n    /// The tree's child nodes. Children small enough to fit in a\n    /// `TreeBuffer` will be represented as such, other children can be\n    /// further `Tree` instances with their own internal structure.\n    children, \n    /// The positions (offsets relative to the start of this tree) of\n    /// the children.\n    positions, \n    /// The total length of this tree @internal\n    length) {\n        var _this = _super.call(this) || this;\n        _this.type = type;\n        _this.children = children;\n        _this.positions = positions;\n        _this.length = length;\n        return _this;\n    }\n    Object.defineProperty(Tree.prototype, \"start\", {\n        /// @internal\n        get: function () { return 0; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Tree.prototype, \"end\", {\n        /// @internal\n        get: function () { return this.length; },\n        enumerable: true,\n        configurable: true\n    });\n    /// @internal\n    Tree.prototype.toString = function () {\n        var children = this.children.map(function (c) { return c.toString(); }).join();\n        return !this.name ? children :\n            (/\\W/.test(this.name) && !this.type.prop(NodeProp.error) ? JSON.stringify(this.name) : this.name) +\n                (children.length ? \"(\" + children + \")\" : \"\");\n    };\n    Tree.prototype.partial = function (start, end, offset, children, positions) {\n        for (var i = 0; i < this.children.length; i++) {\n            var from = this.positions[i];\n            if (from > end)\n                break;\n            var child = this.children[i], to = from + child.length;\n            if (to < start)\n                continue;\n            if (start <= from && end >= to) {\n                children.push(child);\n                positions.push(from + offset);\n            }\n            else if (child instanceof Tree) {\n                child.partial(start - from, end - from, offset + from, children, positions);\n            }\n        }\n    };\n    /// Apply a set of edits to a tree, removing all nodes that were\n    /// touched by the edits, and moving remaining nodes so that their\n    /// positions are updated for insertions/deletions before them. This\n    /// is likely to destroy a lot of the structure of the tree, and\n    /// mostly useful for extracting the nodes that can be reused in a\n    /// subsequent incremental re-parse.\n    Tree.prototype.applyChanges = function (changes) {\n        if (changes.length == 0)\n            return this;\n        var children = [], positions = [];\n        function cutAt(tree, pos, side) {\n            var found = -1;\n            tree.iterate({\n                from: pos,\n                to: side < 0 ? 0 : tree.length,\n                enter: function () { return found < 0 ? undefined : false; },\n                leave: function (type, start, end) {\n                    if (found < 0 && !type.prop(NodeProp.error))\n                        found = side < 0 ? Math.min(pos, end - 1) : Math.max(pos, start + 1);\n                }\n            });\n            return found > -1 ? found : side < 0 ? 0 : tree.length;\n        }\n        var off = 0;\n        for (var i = 0, pos = 0;; i++) {\n            var next = i == changes.length ? null : changes[i];\n            var nextPos = next ? cutAt(this, next.fromA, -1) : this.length;\n            if (nextPos > pos)\n                this.partial(pos, nextPos, off, children, positions);\n            if (!next)\n                break;\n            pos = cutAt(this, next.toA, 1);\n            off += (next.toB - next.fromB) - (next.toA - next.fromA);\n        }\n        return new Tree(NodeType.none, children, positions, this.length + off);\n    };\n    /// Take the part of the tree up to the given position.\n    Tree.prototype.cut = function (at) {\n        if (at >= this.length)\n            return this;\n        var children = [], positions = [];\n        for (var i = 0; i < this.children.length; i++) {\n            var from = this.positions[i];\n            if (from >= at)\n                break;\n            var child = this.children[i], to = from + child.length;\n            children.push(to <= at ? child : child.cut(at - from));\n            positions.push(from);\n        }\n        return new Tree(this.type, children, positions, at);\n    };\n    /// @internal\n    Tree.prototype.iterate = function (_a) {\n        var _b = _a.from, from = _b === void 0 ? this.start : _b, _c = _a.to, to = _c === void 0 ? this.end : _c, enter = _a.enter, leave = _a.leave;\n        var iter = new Iteration(enter, leave);\n        this.iterInner(from, to, 0, iter);\n        return iter.result;\n    };\n    /// @internal\n    Tree.prototype.iterInner = function (from, to, offset, iter) {\n        if (this.type.name && !iter.doEnter(this.type, offset, offset + this.length))\n            return;\n        if (from <= to) {\n            for (var i = 0; i < this.children.length && !iter.done; i++) {\n                var child = this.children[i], start = this.positions[i] + offset, end = start + child.length;\n                if (start > to)\n                    break;\n                if (end < from)\n                    continue;\n                child.iterInner(from, to, start, iter);\n            }\n        }\n        else {\n            for (var i = this.children.length - 1; i >= 0 && !iter.done; i--) {\n                var child = this.children[i], start = this.positions[i] + offset, end = start + child.length;\n                if (end < to)\n                    break;\n                if (start > from)\n                    continue;\n                child.iterInner(from, to, start, iter);\n            }\n        }\n        if (iter.leave && this.type.name)\n            iter.leave(this.type, offset, offset + this.length);\n        return;\n    };\n    /// @internal\n    Tree.prototype.resolveAt = function (pos) {\n        if (cacheRoot == this) {\n            for (var tree = cached;;) {\n                var next = tree.parent;\n                if (!next)\n                    break;\n                if (tree.start < pos && tree.end > pos)\n                    return tree.resolve(pos);\n                tree = next;\n            }\n        }\n        cacheRoot = this;\n        return cached = this.resolveInner(pos, 0, this);\n    };\n    /// @internal\n    Tree.prototype.childBefore = function (pos) {\n        return this.findChild(pos, -1, 0, this);\n    };\n    /// @internal\n    Tree.prototype.childAfter = function (pos) {\n        return this.findChild(pos, 1, 0, this);\n    };\n    /// @internal\n    Tree.prototype.findChild = function (pos, side, start, parent) {\n        for (var i = 0; i < this.children.length; i++) {\n            var childStart = this.positions[i] + start, select = -1;\n            if (childStart >= pos) {\n                if (side < 0 && i > 0)\n                    select = i - 1;\n                else if (side > 0)\n                    select = i;\n                else\n                    break;\n            }\n            if (select < 0 && (childStart + this.children[i].length > pos || side < 0 && i == this.children.length - 1))\n                select = i;\n            if (select >= 0) {\n                var child = this.children[select], childStart_1 = this.positions[select] + start;\n                if (child.length == 0 && childStart_1 == pos)\n                    continue;\n                if (child instanceof Tree) {\n                    if (child.type.name)\n                        return new NodeSubtree(child, childStart_1, parent);\n                    return child.findChild(pos, side, childStart_1, parent);\n                }\n                else {\n                    var found = child.findIndex(pos, side, childStart_1, 0, child.buffer.length);\n                    if (found > -1)\n                        return new BufferSubtree(child, childStart_1, found, parent);\n                }\n            }\n        }\n        return null;\n    };\n    /// @internal\n    Tree.prototype.resolveInner = function (pos, start, parent) {\n        var found = this.findChild(pos, 0, start, parent);\n        return found ? found.resolveAt(pos) : parent;\n    };\n    /// Append another tree to this tree. `other` must have empty space\n    /// big enough to fit this tree at its start.\n    Tree.prototype.append = function (other) {\n        if (other.children.length && other.positions[0] < this.length)\n            throw new Error(\"Can't append overlapping trees\");\n        return new Tree(this.type, this.children.concat(other.children), this.positions.concat(other.positions), other.length);\n    };\n    /// Balance the direct children of this tree.\n    Tree.prototype.balance = function (maxBufferLength) {\n        if (maxBufferLength === void 0) { maxBufferLength = exports.DefaultBufferLength; }\n        return this.children.length <= BalanceBranchFactor ? this\n            : balanceRange(this.type, NodeType.none, this.children, this.positions, 0, this.children.length, 0, maxBufferLength, this.length);\n    };\n    /// Build a tree from a postfix-ordered buffer of node information,\n    /// or a cursor over such a buffer.\n    Tree.build = function (data) { return buildTree(data); };\n    /// The empty tree\n    Tree.empty = new Tree(NodeType.none, [], [], 0);\n    return Tree;\n}(Subtree));\nexports.Tree = Tree;\nTree.prototype.parent = null;\n// Top-level `resolveAt` calls store their last result here, so that\n// if the next call is near the last, parent trees can be cheaply\n// reused.\nvar cacheRoot = Tree.empty;\nvar cached = Tree.empty;\n/// Tree buffers contain (type, start, end, endIndex) quads for each\n/// node. In such a buffer, nodes are stored in prefix order (parents\n/// before children, with the endIndex of the parent indicating which\n/// children belong to it)\nvar TreeBuffer = /** @class */ (function () {\n    /// Create a tree buffer @internal\n    function TreeBuffer(\n    /// @internal\n    buffer, \n    // The total length of the group of nodes in the buffer.\n    length, \n    /// @internal\n    group, \n    /// An optional type tag, used to tag a buffer as being part of a\n    /// repetition @internal\n    type) {\n        if (type === void 0) { type = NodeType.none; }\n        this.buffer = buffer;\n        this.length = length;\n        this.group = group;\n        this.type = type;\n    }\n    /// @internal\n    TreeBuffer.prototype.toString = function () {\n        var parts = [];\n        for (var index = 0; index < this.buffer.length;)\n            index = this.childToString(index, parts);\n        return parts.join(\",\");\n    };\n    /// @internal\n    TreeBuffer.prototype.childToString = function (index, parts) {\n        var id = this.buffer[index], endIndex = this.buffer[index + 3];\n        var type = this.group.types[id], result = type.name;\n        if (/\\W/.test(result) && !type.prop(NodeProp.error))\n            result = JSON.stringify(result);\n        index += 4;\n        if (endIndex > index) {\n            var children = [];\n            while (index < endIndex)\n                index = this.childToString(index, children);\n            result += \"(\" + children.join(\",\") + \")\";\n        }\n        parts.push(result);\n        return index;\n    };\n    /// @internal\n    TreeBuffer.prototype.cut = function (at) {\n        var cutPoint = 0;\n        while (cutPoint < this.buffer.length && this.buffer[cutPoint + 1] < at)\n            cutPoint += 4;\n        var newBuffer = new Uint16Array(cutPoint);\n        for (var i = 0; i < cutPoint; i += 4) {\n            newBuffer[i] = this.buffer[i];\n            newBuffer[i + 1] = this.buffer[i + 1];\n            newBuffer[i + 2] = Math.min(at, this.buffer[i + 2]);\n            newBuffer[i + 3] = Math.min(this.buffer[i + 3], cutPoint);\n        }\n        return new TreeBuffer(newBuffer, Math.min(at, this.length), this.group);\n    };\n    TreeBuffer.prototype.iterate = function (_a) {\n        var _b = _a.from, from = _b === void 0 ? 0 : _b, _c = _a.to, to = _c === void 0 ? this.length : _c, enter = _a.enter, leave = _a.leave;\n        var iter = new Iteration(enter, leave);\n        this.iterInner(from, to, 0, iter);\n        return iter.result;\n    };\n    /// @internal\n    TreeBuffer.prototype.iterInner = function (from, to, offset, iter) {\n        if (from <= to) {\n            for (var index = 0; index < this.buffer.length;)\n                index = this.iterChild(from, to, offset, index, iter);\n        }\n        else {\n            this.iterRev(from, to, offset, 0, this.buffer.length, iter);\n        }\n    };\n    /// @internal\n    TreeBuffer.prototype.iterChild = function (from, to, offset, index, iter) {\n        var type = this.group.types[this.buffer[index++]], start = this.buffer[index++] + offset, end = this.buffer[index++] + offset, endIndex = this.buffer[index++];\n        if (start > to)\n            return this.buffer.length;\n        if (end >= from && iter.doEnter(type, start, end)) {\n            while (index < endIndex && !iter.done)\n                index = this.iterChild(from, to, offset, index, iter);\n            if (iter.leave)\n                iter.leave(type, start, end);\n        }\n        return endIndex;\n    };\n    TreeBuffer.prototype.parentNodesByEnd = function (startIndex, endIndex) {\n        var _this = this;\n        // Build up an array of node indices reflecting the order in which\n        // non-empty nodes end, to avoid having to scan for parent nodes\n        // at every position during reverse iteration.\n        var order = [];\n        var scan = function (index) {\n            var end = _this.buffer[index + 3];\n            if (end == index + 4)\n                return end;\n            for (var i = index + 4; i < end;)\n                i = scan(i);\n            order.push(index);\n            return end;\n        };\n        for (var index = startIndex; index < endIndex;)\n            index = scan(index);\n        return order;\n    };\n    /// @internal\n    TreeBuffer.prototype.iterRev = function (from, to, offset, startIndex, endIndex, iter) {\n        var _this = this;\n        var endOrder = this.parentNodesByEnd(startIndex, endIndex);\n        // Index range for the next non-empty node\n        var nextStart = -1, nextEnd = -1;\n        var takeNext = function () {\n            if (endOrder.length > 0) {\n                nextStart = endOrder.pop();\n                nextEnd = _this.buffer[nextStart + 3];\n            }\n            else {\n                nextEnd = -1;\n            }\n        };\n        takeNext();\n        run: for (var index = endIndex; index > startIndex && !iter.done;) {\n            while (nextEnd == index) {\n                var base = nextStart;\n                var id_1 = this.buffer[base], start_1 = this.buffer[base + 1] + offset, end_1 = this.buffer[base + 2] + offset;\n                takeNext();\n                if (start_1 <= from && end_1 >= to) {\n                    if (!iter.doEnter(this.group.types[id_1], start_1, end_1)) {\n                        // Skip the entire node\n                        index = base;\n                        while (nextEnd > base)\n                            takeNext();\n                        continue run;\n                    }\n                }\n            }\n            var endIndex_1 = this.buffer[--index], end = this.buffer[--index] + offset, start = this.buffer[--index] + offset, id = this.buffer[--index];\n            if (start > from || end < to)\n                continue;\n            if ((endIndex_1 != index + 4 || iter.doEnter(this.group.types[id], start, end)) && iter.leave)\n                iter.leave(this.group.types[id], start, end);\n        }\n    };\n    /// @internal\n    TreeBuffer.prototype.findIndex = function (pos, side, start, from, to) {\n        var lastI = -1;\n        for (var i = from, buf = this.buffer; i < to;) {\n            var start1 = buf[i + 1] + start, end1 = buf[i + 2] + start;\n            var ignore = start1 == end1 && start1 == pos;\n            if (start1 >= pos) {\n                if (side > 0 && !ignore)\n                    return i;\n                break;\n            }\n            if (end1 > pos)\n                return i;\n            if (!ignore)\n                lastI = i;\n            i = buf[i + 3];\n        }\n        return side < 0 ? lastI : -1;\n    };\n    return TreeBuffer;\n}());\nexports.TreeBuffer = TreeBuffer;\nvar NodeSubtree = /** @class */ (function (_super) {\n    __extends(NodeSubtree, _super);\n    function NodeSubtree(node, start, parent) {\n        var _this = _super.call(this) || this;\n        _this.node = node;\n        _this.start = start;\n        _this.parent = parent;\n        return _this;\n    }\n    Object.defineProperty(NodeSubtree.prototype, \"type\", {\n        get: function () { return this.node.type; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(NodeSubtree.prototype, \"end\", {\n        get: function () { return this.start + this.node.length; },\n        enumerable: true,\n        configurable: true\n    });\n    NodeSubtree.prototype.resolveAt = function (pos) {\n        if (pos <= this.start || pos >= this.end)\n            return this.parent.resolveAt(pos);\n        return this.node.resolveInner(pos, this.start, this);\n    };\n    NodeSubtree.prototype.childBefore = function (pos) {\n        return this.node.findChild(pos, -1, this.start, this);\n    };\n    NodeSubtree.prototype.childAfter = function (pos) {\n        return this.node.findChild(pos, 1, this.start, this);\n    };\n    NodeSubtree.prototype.toString = function () { return this.node.toString(); };\n    NodeSubtree.prototype.iterate = function (_a) {\n        var _b = _a.from, from = _b === void 0 ? this.start : _b, _c = _a.to, to = _c === void 0 ? this.end : _c, enter = _a.enter, leave = _a.leave;\n        var iter = new Iteration(enter, leave);\n        this.node.iterInner(from, to, this.start, iter);\n        return iter.result;\n    };\n    return NodeSubtree;\n}(Subtree));\nvar BufferSubtree = /** @class */ (function (_super) {\n    __extends(BufferSubtree, _super);\n    function BufferSubtree(buffer, bufferStart, index, parent) {\n        var _this = _super.call(this) || this;\n        _this.buffer = buffer;\n        _this.bufferStart = bufferStart;\n        _this.index = index;\n        _this.parent = parent;\n        return _this;\n    }\n    Object.defineProperty(BufferSubtree.prototype, \"type\", {\n        get: function () { return this.buffer.group.types[this.buffer.buffer[this.index]]; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(BufferSubtree.prototype, \"start\", {\n        get: function () { return this.buffer.buffer[this.index + 1] + this.bufferStart; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(BufferSubtree.prototype, \"end\", {\n        get: function () { return this.buffer.buffer[this.index + 2] + this.bufferStart; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(BufferSubtree.prototype, \"endIndex\", {\n        get: function () { return this.buffer.buffer[this.index + 3]; },\n        enumerable: true,\n        configurable: true\n    });\n    BufferSubtree.prototype.childBefore = function (pos) {\n        var index = this.buffer.findIndex(pos, -1, this.bufferStart, this.index + 4, this.endIndex);\n        return index < 0 ? null : new BufferSubtree(this.buffer, this.bufferStart, index, this);\n    };\n    BufferSubtree.prototype.childAfter = function (pos) {\n        var index = this.buffer.findIndex(pos, 1, this.bufferStart, this.index + 4, this.endIndex);\n        return index < 0 ? null : new BufferSubtree(this.buffer, this.bufferStart, index, this);\n    };\n    BufferSubtree.prototype.iterate = function (_a) {\n        var _b = _a.from, from = _b === void 0 ? this.start : _b, _c = _a.to, to = _c === void 0 ? this.end : _c, enter = _a.enter, leave = _a.leave;\n        var iter = new Iteration(enter, leave);\n        if (from <= to)\n            this.buffer.iterChild(from, to, this.bufferStart, this.index, iter);\n        else\n            this.buffer.iterRev(from, to, this.bufferStart, this.index, this.endIndex, iter);\n        return iter.result;\n    };\n    BufferSubtree.prototype.resolveAt = function (pos) {\n        if (pos <= this.start || pos >= this.end)\n            return this.parent.resolveAt(pos);\n        var found = this.buffer.findIndex(pos, 0, this.bufferStart, this.index + 4, this.endIndex);\n        return found < 0 ? this : new BufferSubtree(this.buffer, this.bufferStart, found, this).resolveAt(pos);\n    };\n    BufferSubtree.prototype.toString = function () {\n        var result = [];\n        this.buffer.childToString(this.index, result);\n        return result.join(\"\");\n    };\n    return BufferSubtree;\n}(Subtree));\nvar FlatBufferCursor = /** @class */ (function () {\n    function FlatBufferCursor(buffer, index) {\n        this.buffer = buffer;\n        this.index = index;\n    }\n    Object.defineProperty(FlatBufferCursor.prototype, \"id\", {\n        get: function () { return this.buffer[this.index - 4]; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(FlatBufferCursor.prototype, \"start\", {\n        get: function () { return this.buffer[this.index - 3]; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(FlatBufferCursor.prototype, \"end\", {\n        get: function () { return this.buffer[this.index - 2]; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(FlatBufferCursor.prototype, \"size\", {\n        get: function () { return this.buffer[this.index - 1]; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(FlatBufferCursor.prototype, \"pos\", {\n        get: function () { return this.index; },\n        enumerable: true,\n        configurable: true\n    });\n    FlatBufferCursor.prototype.next = function () { this.index -= 4; };\n    FlatBufferCursor.prototype.fork = function () { return new FlatBufferCursor(this.buffer, this.index); };\n    return FlatBufferCursor;\n}());\nvar BalanceBranchFactor = 8;\nfunction buildTree(data) {\n    var _a = data, buffer = _a.buffer, group = _a.group, _b = _a.topID, topID = _b === void 0 ? 0 : _b, _c = _a.maxBufferLength, maxBufferLength = _c === void 0 ? exports.DefaultBufferLength : _c, _d = _a.reused, reused = _d === void 0 ? [] : _d, _e = _a.minRepeatType, minRepeatType = _e === void 0 ? group.types.length : _e;\n    var cursor = Array.isArray(buffer) ? new FlatBufferCursor(buffer, buffer.length) : buffer;\n    var types = group.types;\n    function takeNode(parentStart, minPos, children, positions, tagBuffer) {\n        var id = cursor.id, start = cursor.start, end = cursor.end, size = cursor.size, buffer;\n        var startPos = start - parentStart;\n        if (size < 0) { // Reused node\n            children.push(reused[id]);\n            positions.push(startPos);\n            cursor.next();\n            return;\n        }\n        var type = types[id], node;\n        if (end - start <= maxBufferLength && (buffer = findBufferSize(cursor.pos - minPos))) {\n            // Small enough for a buffer, and no reused nodes inside\n            var data_1 = new Uint16Array(buffer.size - buffer.skip);\n            var endPos = cursor.pos - buffer.size, index = data_1.length;\n            while (cursor.pos > endPos)\n                index = copyToBuffer(buffer.start, data_1, index);\n            node = new TreeBuffer(data_1, end - buffer.start, group, tagBuffer);\n            startPos = buffer.start - parentStart;\n        }\n        else { // Make it a node\n            var endPos = cursor.pos - size;\n            cursor.next();\n            var localChildren = [], localPositions = [];\n            // Check if this is a repeat wrapper. Store the id of the inner\n            // repeat node in the variable if it is\n            var repeating = id >= group.types.length ? id - (group.types.length - minRepeatType) : -1;\n            if (repeating > -1) {\n                type = types[repeating];\n                while (cursor.pos > endPos) {\n                    var isRepeat = cursor.id == repeating; // This starts with an inner repeated node\n                    takeNode(start, endPos, localChildren, localPositions, isRepeat ? type : NodeType.none);\n                }\n            }\n            else {\n                while (cursor.pos > endPos)\n                    takeNode(start, endPos, localChildren, localPositions, NodeType.none);\n            }\n            localChildren.reverse();\n            localPositions.reverse();\n            if (repeating > -1 && localChildren.length > BalanceBranchFactor)\n                node = balanceRange(type, type, localChildren, localPositions, 0, localChildren.length, 0, maxBufferLength, end - start);\n            else\n                node = new Tree(type, localChildren, localPositions, end - start);\n        }\n        children.push(node);\n        positions.push(startPos);\n    }\n    function findBufferSize(maxSize) {\n        // Scan through the buffer to find previous siblings that fit\n        // together in a TreeBuffer, and don't contain any reused nodes\n        // (which can't be stored in a buffer)\n        // If `type` is > -1, only include siblings with that same type\n        // (used to group repeat content into a buffer)\n        var fork = cursor.fork();\n        var size = 0, start = 0, skip = 0, minStart = fork.end - maxBufferLength;\n        scan: for (var minPos = fork.pos - maxSize; fork.pos > minPos;) {\n            var nodeSize = fork.size, startPos = fork.pos - nodeSize;\n            if (nodeSize < 0 || startPos < minPos || fork.start < minStart)\n                break;\n            var localSkipped = fork.id >= minRepeatType ? 4 : 0;\n            var nodeStart = fork.start;\n            fork.next();\n            while (fork.pos > startPos) {\n                if (fork.size < 0)\n                    break scan;\n                if (fork.id >= minRepeatType)\n                    localSkipped += 4;\n                fork.next();\n            }\n            start = nodeStart;\n            size += nodeSize;\n            skip += localSkipped;\n        }\n        return size > 4 ? { size: size, start: start, skip: skip } : null;\n    }\n    function copyToBuffer(bufferStart, buffer, index) {\n        var id = cursor.id, start = cursor.start, end = cursor.end, size = cursor.size;\n        cursor.next();\n        var startIndex = index;\n        if (size > 4) {\n            var endPos = cursor.pos - (size - 4);\n            while (cursor.pos > endPos)\n                index = copyToBuffer(bufferStart, buffer, index);\n        }\n        if (id < minRepeatType) { // Don't copy repeat nodes into buffers\n            buffer[--index] = startIndex;\n            buffer[--index] = end - bufferStart;\n            buffer[--index] = start - bufferStart;\n            buffer[--index] = id;\n        }\n        return index;\n    }\n    var children = [], positions = [];\n    while (cursor.pos > 0)\n        takeNode(0, 0, children, positions, NodeType.none);\n    var length = children.length ? positions[0] + children[0].length : 0;\n    return new Tree(group.types[topID], children.reverse(), positions.reverse(), length);\n}\nfunction balanceRange(outerType, innerType, children, positions, from, to, start, maxBufferLength, length) {\n    var localChildren = [], localPositions = [];\n    if (length <= maxBufferLength) {\n        for (var i = from; i < to; i++) {\n            localChildren.push(children[i]);\n            localPositions.push(positions[i] - start);\n        }\n    }\n    else {\n        var maxChild = Math.max(maxBufferLength, Math.ceil(length * 1.5 / BalanceBranchFactor));\n        for (var i = from; i < to;) {\n            var groupFrom = i, groupStart = positions[i];\n            i++;\n            for (; i < to; i++) {\n                var nextEnd = positions[i] + children[i].length;\n                if (nextEnd - groupStart > maxChild)\n                    break;\n            }\n            if (i == groupFrom + 1) {\n                var only = children[groupFrom];\n                if (only instanceof Tree && only.type == innerType && only.length > maxChild << 1) { // Too big, collapse\n                    for (var j = 0; j < only.children.length; j++) {\n                        localChildren.push(only.children[j]);\n                        localPositions.push(only.positions[j] + groupStart - start);\n                    }\n                    continue;\n                }\n                localChildren.push(only);\n            }\n            else if (i == groupFrom + 1) {\n                localChildren.push(children[groupFrom]);\n            }\n            else {\n                var inner = balanceRange(innerType, innerType, children, positions, groupFrom, i, groupStart, maxBufferLength, positions[i - 1] - groupStart);\n                if (innerType != NodeType.none && !containsType(inner.children, innerType))\n                    inner = new Tree(NodeType.none, inner.children, inner.positions, inner.length);\n                localChildren.push(inner);\n            }\n            localPositions.push(groupStart - start);\n        }\n    }\n    return new Tree(outerType, localChildren, localPositions, length);\n}\nfunction containsType(nodes, type) {\n    for (var _i = 0, nodes_1 = nodes; _i < nodes_1.length; _i++) {\n        var elt = nodes_1[_i];\n        if (elt.type == type)\n            return true;\n    }\n    return false;\n}\n//# sourceMappingURL=tree.js.map","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar lezerTree = require('lezer-tree');\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nfunction __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\n\n/// A parse stack. These are used internally by the parser to track\n/// parsing progress. They also provide some properties and methods\n/// that external code such as a tokenizer can use to get information\n/// about the parse state.\nvar Stack = /** @class */ (function () {\n    /// @internal\n    function Stack(\n    // A group of values that the stack will share with all\n    // split instances\n    ///@internal\n    cx, \n    // Holds state, pos, value stack pos (15 bits array index, 15 bits\n    // buffer index) triplets for all but the top state\n    /// @internal\n    stack, \n    // The current parse state\n    /// @internal\n    state, \n    // The position at which the next reduce should take place. This\n    // can be less than `this.pos` when skipped expressions have been\n    // added to the stack (which should be moved outside of the next\n    // reduction)\n    /// @internal\n    reducePos, \n    // The input position up to which this stack has parsed.\n    pos, \n    // The amount of error-recovery that happened on this stack\n    /// @internal\n    recovered, \n    // The output buffer. Holds (type, start, end, size) quads\n    // representing nodes created by the parser, where `size` is\n    // amount of buffer array entries covered by this node.\n    /// @internal\n    buffer, \n    // The base offset of the buffer. When stacks are split, the split\n    // instance shared the buffer history with its parent up to\n    // `bufferBase`, which is the absolute offset (including the\n    // offset of previous splits) into the buffer at which this stack\n    // starts writing.\n    /// @internal\n    bufferBase, \n    // A parent stack from which this was split off, if any. This is\n    // set up so that it always points to a stack that has some\n    // additional buffer content, never to a stack with an equal\n    // `bufferBase`.\n    /// @internal\n    parent) {\n        this.cx = cx;\n        this.stack = stack;\n        this.state = state;\n        this.reducePos = reducePos;\n        this.pos = pos;\n        this.recovered = recovered;\n        this.buffer = buffer;\n        this.bufferBase = bufferBase;\n        this.parent = parent;\n    }\n    /// @internal\n    Stack.prototype.toString = function () {\n        return \"[\" + this.stack.filter(function (_, i) { return i % 3 == 0; }).concat(this.state) + \"]@\" + this.pos + (this.recovered ? \"!\" + this.recovered : \"\");\n    };\n    // Start an empty stack\n    /// @internal\n    Stack.start = function (cx, pos) {\n        if (pos === void 0) { pos = 0; }\n        return new Stack(cx, [], cx.parser.states[0], pos, pos, 0, [], 0, null);\n    };\n    // Push a state onto the stack, tracking its start position as well\n    // as the buffer base at that point.\n    /// @internal\n    Stack.prototype.pushState = function (state, start) {\n        this.stack.push(this.state, start, this.bufferBase + this.buffer.length);\n        this.state = state;\n    };\n    // Apply a reduce action\n    /// @internal\n    Stack.prototype.reduce = function (action) {\n        var depth = action >> 19 /* ReduceDepthShift */, type = action & 65535 /* ValueMask */;\n        var parser = this.cx.parser;\n        if (depth == 0) {\n            // Zero-depth reductions are a special casethey add stuff to\n            // the stack without popping anything off.\n            if (type < parser.minRepeatTerm)\n                this.storeNode(type, this.reducePos, this.reducePos, 4, true);\n            this.pushState(parser.getGoto(this.state, type, true), this.reducePos);\n            return;\n        }\n        // Find the base index into `this.stack`, content after which will\n        // be dropped. Note that with `StayFlag` reductions we need to\n        // consume two extra frames (the dummy parent node for the skipped\n        // expression and the state that we'll be staying in, which should\n        // be moved to `this.state`).\n        var base = this.stack.length - ((depth - 1) * 3) - (action & 262144 /* StayFlag */ ? 6 : 0);\n        var start = this.stack[base - 2];\n        var bufferBase = this.stack[base - 1], count = this.bufferBase + this.buffer.length - bufferBase;\n        if (type < parser.minRepeatTerm || // Normal term\n            (action & 131072 /* RepeatFlag */) || // Inner repeat marker\n            (type > parser.maxNode && type <= parser.maxRepeatWrap)) { // Repeat wrapper\n            var pos = parser.stateFlag(this.state, 1 /* Skipped */) ? this.pos : this.reducePos;\n            this.storeNode(type, start, pos, count + 4, true);\n        }\n        if (action & 262144 /* StayFlag */) {\n            this.state = this.stack[base];\n        }\n        else {\n            var baseStateID = this.stack[base - 3];\n            this.state = parser.getGoto(baseStateID, type, true);\n        }\n        while (this.stack.length > base)\n            this.stack.pop();\n    };\n    // Shift a value into the buffer\n    /// @internal\n    Stack.prototype.storeNode = function (term, start, end, size, isReduce) {\n        if (size === void 0) { size = 4; }\n        if (isReduce === void 0) { isReduce = false; }\n        if (term == 0 /* Err */) { // Try to omit/merge adjacent error nodes\n            var cur = this, top = this.buffer.length;\n            if (top == 0 && cur.parent) {\n                top = cur.bufferBase - cur.parent.bufferBase;\n                cur = cur.parent;\n            }\n            if (top > 0 && cur.buffer[top - 4] == 0 /* Err */ && cur.buffer[top - 1] > -1) {\n                if (start == end)\n                    return;\n                if (cur.buffer[top - 2] >= start) {\n                    cur.buffer[top - 2] = end;\n                    return;\n                }\n            }\n        }\n        if (!isReduce || this.pos == end) { // Simple case, just append\n            this.buffer.push(term, start, end, size);\n        }\n        else { // There may be skipped nodes that have to be moved forward\n            var index = this.buffer.length;\n            if (index > 0 && this.buffer[index - 4] != 0 /* Err */)\n                while (index > 0 && this.buffer[index - 2] > end) {\n                    // Move this record forward\n                    this.buffer[index] = this.buffer[index - 4];\n                    this.buffer[index + 1] = this.buffer[index - 3];\n                    this.buffer[index + 2] = this.buffer[index - 2];\n                    this.buffer[index + 3] = this.buffer[index - 1];\n                    index -= 4;\n                    if (size > 4)\n                        size -= 4;\n                }\n            this.buffer[index] = term;\n            this.buffer[index + 1] = start;\n            this.buffer[index + 2] = end;\n            this.buffer[index + 3] = size;\n        }\n    };\n    // Apply a shift action\n    /// @internal\n    Stack.prototype.shift = function (action, next, nextEnd) {\n        if (action & 131072 /* GotoFlag */) {\n            this.pushState(action & 65535 /* ValueMask */, this.pos);\n        }\n        else if ((action & 262144 /* StayFlag */) == 0) { // Regular shift\n            var start = this.pos, nextState = action, parser = this.cx.parser;\n            if (nextEnd > this.pos || next <= parser.maxNode) {\n                this.pos = nextEnd;\n                if (!parser.stateFlag(nextState, 1 /* Skipped */))\n                    this.reducePos = nextEnd;\n            }\n            this.pushState(nextState, start);\n            if (next <= parser.maxNode)\n                this.buffer.push(next, start, nextEnd, 4);\n        }\n        else { // Shift-and-stay, which means this is a skipped token\n            if (next <= this.cx.parser.maxNode)\n                this.buffer.push(next, this.pos, nextEnd, 4);\n            this.pos = nextEnd;\n        }\n    };\n    // Apply an action\n    /// @internal\n    Stack.prototype.apply = function (action, next, nextEnd) {\n        if (action & 65536 /* ReduceFlag */)\n            this.reduce(action);\n        else\n            this.shift(action, next, nextEnd);\n    };\n    // Add a prebuilt node into the buffer. This may be a reused node or\n    // the result of running a nested parser.\n    /// @internal\n    Stack.prototype.useNode = function (value, next) {\n        var index = this.cx.reused.length - 1;\n        if (index < 0 || this.cx.reused[index] != value) {\n            this.cx.reused.push(value);\n            index++;\n        }\n        var start = this.pos;\n        this.reducePos = this.pos = start + value.length;\n        this.pushState(next, start);\n        this.buffer.push(index, start, this.reducePos, -1 /* size < 0 means this is a reused value */);\n    };\n    // Split the stack. Due to the buffer sharing and the fact\n    // that `this.stack` tends to stay quite shallow, this isn't very\n    // expensive.\n    /// @internal\n    Stack.prototype.split = function () {\n        var parent = this;\n        var off = parent.buffer.length;\n        // Because the top of the buffer (after this.pos) may be mutated\n        // to reorder reductions and skipped tokens, and shared buffers\n        // should be immutable, this copies any outstanding skipped tokens\n        // to the new buffer, and puts the base pointer before them.\n        while (off > 0 && parent.buffer[off - 2] > parent.reducePos)\n            off -= 4;\n        var buffer = parent.buffer.slice(off), base = parent.bufferBase + off;\n        // Make sure parent points to an actual parent with content, if there is such a parent.\n        while (parent && base == parent.bufferBase)\n            parent = parent.parent;\n        return new Stack(this.cx, this.stack.slice(), this.state, this.reducePos, this.pos, this.recovered, buffer, base, parent);\n    };\n    // Try to recover from an error by 'deleting' (ignoring) one token.\n    /// @internal\n    Stack.prototype.recoverByDelete = function (next, nextEnd) {\n        var isNode = next <= this.cx.parser.maxNode;\n        if (isNode)\n            this.storeNode(next, this.pos, nextEnd);\n        this.storeNode(0 /* Err */, this.pos, nextEnd, isNode ? 8 : 4);\n        this.pos = this.reducePos = nextEnd;\n        this.recovered += 2 /* Token */;\n    };\n    /// Check if the given term would be able to be shifted (optionally\n    /// after some reductions) on this stack. This can be useful for\n    /// external tokenizers that want to make sure they only provide a\n    /// given token when it applies.\n    Stack.prototype.canShift = function (term) {\n        for (var sim = new SimulatedStack(this);;) {\n            var action = this.cx.parser.stateSlot(sim.top, 4 /* DefaultReduce */) || this.cx.parser.hasAction(sim.top, term);\n            if ((action & 65536 /* ReduceFlag */) == 0)\n                return true;\n            if (action == 0)\n                return false;\n            sim.reduce(action);\n        }\n    };\n    Object.defineProperty(Stack.prototype, \"ruleStart\", {\n        /// Find the start position of the rule that is currently being parsed.\n        get: function () {\n            var force = this.cx.parser.stateSlot(this.state, 5 /* ForcedReduce */);\n            if (!(force & 65536 /* ReduceFlag */))\n                return 0;\n            var base = this.stack.length - (3 * (force >> 19 /* ReduceDepthShift */));\n            return this.stack[base + 1];\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /// Find the start position of the innermost instance of any of the\n    /// given term types, or return `-1` when none of them are found.\n    ///\n    /// **Note:** this is only reliable when there is at least some\n    /// state that unambiguously matches the given rule on the stack.\n    /// I.e. if you have a grammar like this, where the difference\n    /// between `a` and `b` is only apparent at the third token:\n    ///\n    ///     a { b | c }\n    ///     b { \"x\" \"y\" \"x\" }\n    ///     c { \"x\" \"y\" \"z\" }\n    ///\n    /// Then a parse state after `\"x\"` will not reliably tell you that\n    /// `b` is on the stack. You _can_ pass `[b, c]` to reliably check\n    /// for either of those two rules (assuming that `a` isn't part of\n    /// some rule that includes other things starting with `\"x\"`).\n    Stack.prototype.startOf = function (types) {\n        for (var frame = this.stack.length; frame >= 0; frame -= 3) {\n            var state = frame == this.stack.length ? this.state : this.stack[frame];\n            var force = this.cx.parser.stateSlot(state, 5 /* ForcedReduce */);\n            if (types.includes(force & 65535 /* ValueMask */)) {\n                var base = frame - (3 * (force >> 19 /* ReduceDepthShift */));\n                return this.stack[base + 1];\n            }\n        }\n        return -1;\n    };\n    // Apply up to Recover.MaxNext recovery actions that conceptually\n    // inserts some missing token or rule.\n    /// @internal\n    Stack.prototype.recoverByInsert = function (next) {\n        var _this = this;\n        var nextStates = this.cx.parser.nextStates(this.state);\n        if (nextStates.length > 4 /* MaxNext */) {\n            var best = nextStates.filter(function (s) { return s != _this.state && _this.cx.parser.hasAction(s, next); });\n            for (var i = 0; best.length < 4 /* MaxNext */ && i < nextStates.length; i++)\n                if (!best.includes(nextStates[i]))\n                    best.push(nextStates[i]);\n            nextStates = best;\n        }\n        var result = [];\n        for (var i = 0; i < nextStates.length && result.length < 4 /* MaxNext */; i++) {\n            if (nextStates[i] == this.state)\n                continue;\n            var stack = this.split();\n            stack.storeNode(0 /* Err */, stack.pos, stack.pos, 4, true);\n            stack.pushState(nextStates[i], this.pos);\n            stack.recovered += 2 /* Token */;\n            result.push(stack);\n        }\n        return result;\n    };\n    // Force a reduce, if possible. Return false if that can't\n    // be done.\n    /// @internal\n    Stack.prototype.forceReduce = function () {\n        var reduce = this.cx.parser.stateSlot(this.state, 5 /* ForcedReduce */);\n        if ((reduce & 65536 /* ReduceFlag */) == 0)\n            return false;\n        if (!this.cx.parser.validAction(this.state, reduce)) {\n            this.storeNode(0 /* Err */, this.reducePos, this.reducePos, 4, true);\n            this.recovered += 1 /* Reduce */;\n        }\n        this.reduce(reduce);\n        return true;\n    };\n    /// @internal\n    Stack.prototype.forceAll = function () {\n        while (!this.cx.parser.stateFlag(this.state, 2 /* Accepting */) && this.forceReduce()) { }\n        return this;\n    };\n    // Convert the stack's buffer to a syntax tree.\n    /// @internal\n    Stack.prototype.toTree = function () {\n        return lezerTree.Tree.build({ buffer: StackBufferCursor.create(this),\n            group: this.cx.parser.group,\n            topID: 1 /* Top */,\n            maxBufferLength: this.cx.maxBufferLength,\n            reused: this.cx.reused,\n            minRepeatType: this.cx.parser.minRepeatTerm });\n    };\n    return Stack;\n}());\nvar Recover;\n(function (Recover) {\n    Recover[Recover[\"Token\"] = 2] = \"Token\";\n    Recover[Recover[\"Reduce\"] = 1] = \"Reduce\";\n    Recover[Recover[\"MaxNext\"] = 4] = \"MaxNext\";\n})(Recover || (Recover = {}));\n// Used to cheaply run some reductions to scan ahead without mutating\n// an entire stack\nvar SimulatedStack = /** @class */ (function () {\n    function SimulatedStack(stack) {\n        this.stack = stack;\n        this.top = stack.state;\n        this.rest = stack.stack;\n        this.offset = this.rest.length;\n    }\n    SimulatedStack.prototype.reduce = function (action) {\n        var term = action & 65535 /* ValueMask */, depth = action >> 19 /* ReduceDepthShift */;\n        if (depth == 0) {\n            if (this.rest == this.stack.stack)\n                this.rest = this.rest.slice();\n            this.rest.push(this.top, 0, 0);\n            this.offset += 3;\n        }\n        else {\n            this.offset -= (depth - 1) * 3;\n        }\n        var goto = this.stack.cx.parser.getGoto(this.rest[this.offset - 3], term, true);\n        this.top = goto;\n    };\n    return SimulatedStack;\n}());\n// This is given to `Tree.build` to build a buffer, and encapsulates\n// the parent-stack-walking necessary to read the nodes.\nvar StackBufferCursor = /** @class */ (function () {\n    function StackBufferCursor(stack, pos, index) {\n        this.stack = stack;\n        this.pos = pos;\n        this.index = index;\n        this.buffer = stack.buffer;\n        if (this.index == 0)\n            this.maybeNext();\n    }\n    StackBufferCursor.create = function (stack) {\n        return new StackBufferCursor(stack, stack.bufferBase + stack.buffer.length, stack.buffer.length);\n    };\n    StackBufferCursor.prototype.maybeNext = function () {\n        var next = this.stack.parent;\n        if (next != null) {\n            this.index = this.stack.bufferBase - next.bufferBase;\n            this.stack = next;\n            this.buffer = next.buffer;\n        }\n    };\n    Object.defineProperty(StackBufferCursor.prototype, \"id\", {\n        get: function () { return this.buffer[this.index - 4]; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(StackBufferCursor.prototype, \"start\", {\n        get: function () { return this.buffer[this.index - 3]; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(StackBufferCursor.prototype, \"end\", {\n        get: function () { return this.buffer[this.index - 2]; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(StackBufferCursor.prototype, \"size\", {\n        get: function () { return this.buffer[this.index - 1]; },\n        enumerable: true,\n        configurable: true\n    });\n    StackBufferCursor.prototype.next = function () {\n        this.index -= 4;\n        this.pos -= 4;\n        if (this.index == 0)\n            this.maybeNext();\n    };\n    StackBufferCursor.prototype.fork = function () {\n        return new StackBufferCursor(this.stack, this.pos, this.index);\n    };\n    return StackBufferCursor;\n}());\n\n/// Tokenizers write the tokens they read into instances of this class.\nvar Token = /** @class */ (function () {\n    function Token() {\n        /// The start of the token. This is set by the parser, and should not\n        /// be mutated by the tokenizer.\n        this.start = -1;\n        /// This starts at -1, and should be updated to a term id when a\n        /// matching token is found.\n        this.value = -1;\n        /// When setting `.value`, you should also set `.end` to the end\n        /// position of the token. (You'll usually want to use the `accept`\n        /// method.)\n        this.end = -1;\n    }\n    /// Accept a token, setting `value` and `end` to the given values.\n    Token.prototype.accept = function (value, end) {\n        this.value = value;\n        this.end = end;\n    };\n    return Token;\n}());\n/// An `InputStream` that is backed by a single, flat string.\nvar StringStream = /** @class */ (function () {\n    function StringStream(string, length) {\n        if (length === void 0) { length = string.length; }\n        this.string = string;\n        this.length = length;\n    }\n    StringStream.prototype.get = function (pos) {\n        return pos < 0 || pos >= this.length ? -1 : this.string.charCodeAt(pos);\n    };\n    StringStream.prototype.read = function (from, to) { return this.string.slice(from, Math.min(this.length, to)); };\n    StringStream.prototype.clip = function (at) { return new StringStream(this.string, at); };\n    return StringStream;\n}());\n/// @internal\nvar TokenGroup = /** @class */ (function () {\n    function TokenGroup(data, id) {\n        this.data = data;\n        this.id = id;\n    }\n    TokenGroup.prototype.token = function (input, token, stack) { readToken(this.data, input, token, stack, this.id); };\n    return TokenGroup;\n}());\nTokenGroup.prototype.contextual = false;\nvar ExternalTokenizer = /** @class */ (function () {\n    function ExternalTokenizer(token, options) {\n        if (options === void 0) { options = {}; }\n        this.token = token;\n        this.contextual = options && options.contextual || false;\n    }\n    return ExternalTokenizer;\n}());\n// Tokenizer data is stored a big uint16 array containing, for each\n// state:\n//\n//  - A group bitmask, indicating what token groups are reachable from\n//    this state, so that paths that can only lead to tokens not in\n//    any of the current groups can be cut off early.\n//\n//  - The position of the end of the state's sequence of accepting\n//    tokens\n//\n//  - The number of outgoing edges for the state\n//\n//  - The accepting tokens, as (token id, group mask) pairs\n//\n//  - The outgoing edges, as (start character, end character, state\n//    index) triples, with end character being exclusive\n//\n// This function interprets that data, running through a stream as\n// long as new states with the a matching group mask can be reached,\n// and updating `token` when it matches a token.\nfunction readToken(data, input, token, stack, group) {\n    var state = 0, groupMask = 1 << group;\n    scan: for (var pos = token.start;;) {\n        if ((groupMask & data[state]) == 0)\n            break;\n        var accEnd = data[state + 1];\n        // Check whether this state can lead to a token in the current group\n        // Accept tokens in this state, possibly overwriting\n        // lower-precedence / shorter tokens\n        for (var i = state + 3; i < accEnd; i += 2)\n            if ((data[i + 1] & groupMask) > 0) {\n                var term = data[i];\n                if (token.value == -1 || token.value == term || stack.cx.parser.overrides(term, token.value)) {\n                    token.accept(term, pos);\n                    break;\n                }\n            }\n        var next = input.get(pos++);\n        // Do a binary search on the state's edges\n        for (var low = 0, high = data[state + 2]; low < high;) {\n            var mid = (low + high) >> 1;\n            var index = accEnd + mid + (mid << 1);\n            var from = data[index], to = data[index + 1];\n            if (next < from)\n                high = mid;\n            else if (next >= to)\n                low = mid + 1;\n            else {\n                state = data[index + 2];\n                continue scan;\n            }\n        }\n        break;\n    }\n}\n\n// See lezer-generator/src/encode.ts for comments about the encoding\n// used here\nfunction decodeArray(input, Type) {\n    if (Type === void 0) { Type = Uint16Array; }\n    var array = null;\n    for (var pos = 0, out = 0; pos < input.length;) {\n        var value = 0;\n        for (;;) {\n            var next = input.charCodeAt(pos++), stop = false;\n            if (next == 126 /* BigValCode */) {\n                value = 65535 /* BigVal */;\n                break;\n            }\n            if (next >= 92 /* Gap2 */)\n                next--;\n            if (next >= 34 /* Gap1 */)\n                next--;\n            var digit = next - 32 /* Start */;\n            if (digit >= 46 /* Base */) {\n                digit -= 46 /* Base */;\n                stop = true;\n            }\n            value += digit;\n            if (stop)\n                break;\n            value *= 46 /* Base */;\n        }\n        if (array)\n            array[out++] = value;\n        else\n            array = new Type(value);\n    }\n    return array;\n}\n\n// Environment variable used to control console output\nvar verbose = typeof process != \"undefined\" && /\\bparse\\b/.test(process.env.LOG);\nvar CacheCursor = /** @class */ (function () {\n    function CacheCursor(tree) {\n        this.start = [0];\n        this.index = [0];\n        this.nextStart = 0;\n        this.trees = [tree];\n    }\n    // `pos` must be >= any previously given `pos` for this cursor\n    CacheCursor.prototype.nodeAt = function (pos) {\n        if (pos < this.nextStart)\n            return null;\n        for (;;) {\n            var last = this.trees.length - 1;\n            if (last < 0) { // End of tree\n                this.nextStart = 1e9;\n                return null;\n            }\n            var top = this.trees[last], index = this.index[last];\n            if (index == top.children.length) {\n                this.trees.pop();\n                this.start.pop();\n                this.index.pop();\n                continue;\n            }\n            var next = top.children[index];\n            var start = this.start[last] + top.positions[index];\n            if (start >= pos)\n                return start == pos ? next : null;\n            if (next instanceof lezerTree.TreeBuffer) {\n                this.index[last]++;\n                this.nextStart = start + next.length;\n            }\n            else {\n                this.index[last]++;\n                if (start + next.length >= pos) { // Enter this node\n                    this.trees.push(next);\n                    this.start.push(start);\n                    this.index.push(0);\n                }\n            }\n        }\n    };\n    return CacheCursor;\n}());\nvar CachedToken = /** @class */ (function (_super) {\n    __extends(CachedToken, _super);\n    function CachedToken() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.extended = -1;\n        _this.mask = 0;\n        return _this;\n    }\n    CachedToken.prototype.clear = function (start) {\n        this.start = start;\n        this.value = this.extended = -1;\n    };\n    return CachedToken;\n}(Token));\nvar dummyToken = new Token;\nvar TokenCache = /** @class */ (function () {\n    function TokenCache(parser) {\n        this.tokens = [];\n        this.mainToken = dummyToken;\n        this.actions = [];\n        this.tokens = parser.tokenizers.map(function (_) { return new CachedToken; });\n    }\n    TokenCache.prototype.getActions = function (stack, input) {\n        var actionIndex = 0;\n        var main = null;\n        var parser = stack.cx.parser, tokenizers = parser.tokenizers;\n        var mask = parser.stateSlot(stack.state, 3 /* TokenizerMask */);\n        for (var i = 0; i < tokenizers.length; i++) {\n            if (((1 << i) & mask) == 0)\n                continue;\n            var tokenizer = tokenizers[i], token = this.tokens[i];\n            if (tokenizer.contextual || token.start != stack.pos || token.mask != mask) {\n                this.updateCachedToken(token, tokenizer, stack, input);\n                token.mask = mask;\n            }\n            var startIndex = actionIndex;\n            if (token.extended > -1)\n                actionIndex = this.addActions(stack, token.extended, token.end, actionIndex);\n            actionIndex = this.addActions(stack, token.value, token.end, actionIndex);\n            if (actionIndex > startIndex) {\n                main = token;\n                break;\n            }\n            if (!main || token.value != 0 /* Err */)\n                main = token;\n        }\n        while (this.actions.length > actionIndex)\n            this.actions.pop();\n        if (!main) {\n            main = dummyToken;\n            main.start = stack.pos;\n            if (stack.pos == input.length)\n                main.accept(stack.cx.parser.eofTerm, stack.pos);\n            else\n                main.accept(0 /* Err */, stack.pos + 1);\n        }\n        this.mainToken = main;\n        return this.actions;\n    };\n    TokenCache.prototype.updateCachedToken = function (token, tokenizer, stack, input) {\n        token.clear(stack.pos);\n        tokenizer.token(input, token, stack);\n        if (token.value > -1) {\n            var parser = stack.cx.parser;\n            var specIndex = findOffset(parser.data, parser.specializeTable, token.value);\n            if (specIndex >= 0) {\n                var found = parser.specializations[specIndex][input.read(token.start, token.end)];\n                if (found != null) {\n                    if ((found & 1) == 0 /* Specialize */)\n                        token.value = found >> 1;\n                    else\n                        token.extended = found >> 1;\n                }\n            }\n        }\n        else if (stack.pos == input.length) {\n            token.accept(stack.cx.parser.eofTerm, stack.pos);\n        }\n        else {\n            token.accept(0 /* Err */, stack.pos + 1);\n        }\n    };\n    TokenCache.prototype.putAction = function (action, token, end, index) {\n        // Don't add duplicate actions\n        for (var i = 0; i < index; i += 3)\n            if (this.actions[i] == action)\n                return index;\n        this.actions[index++] = action;\n        this.actions[index++] = token;\n        this.actions[index++] = end;\n        return index;\n    };\n    TokenCache.prototype.addActions = function (stack, token, end, index) {\n        var state = stack.state, parser = stack.cx.parser, data = parser.data;\n        for (var set = 0; set < 2; set++) {\n            for (var i = parser.stateSlot(state, set ? 2 /* Skip */ : 1 /* Actions */), next = void 0; (next = data[i]) != 65535 /* End */; i += 3) {\n                if (next == token || (next == 0 /* Err */ && index == 0))\n                    index = this.putAction(data[i + 1] | (data[i + 2] << 16), token, end, index);\n            }\n        }\n        return index;\n    };\n    return TokenCache;\n}());\nvar StackContext = /** @class */ (function () {\n    function StackContext(parser, maxBufferLength, input, parent, wrapType // Set to -2 when a stack descending from this nesting event finishes\n    ) {\n        if (parent === void 0) { parent = null; }\n        if (wrapType === void 0) { wrapType = -1; }\n        this.parser = parser;\n        this.maxBufferLength = maxBufferLength;\n        this.input = input;\n        this.parent = parent;\n        this.wrapType = wrapType;\n        this.reused = [];\n        this.tokens = new TokenCache(parser);\n    }\n    return StackContext;\n}());\nvar recoverDist = 5, maxRemainingPerStep = 3, minBufferLengthPrune = 200, forceReduceLimit = 10;\n/// A parse context can be used for step-by-step parsing. After\n/// creating it, you repeatedly call `.advance()` until it returns a\n/// tree to indicate it has reached the end of the parse.\nvar ParseContext = /** @class */ (function () {\n    /// @internal\n    function ParseContext(parser, input, _a) {\n        var _b = _a === void 0 ? {} : _a, _c = _b.cache, cache = _c === void 0 ? undefined : _c, _d = _b.strict, strict = _d === void 0 ? false : _d, _e = _b.bufferLength, bufferLength = _e === void 0 ? lezerTree.DefaultBufferLength : _e;\n        // The position to which the parse has advanced.\n        this.pos = 0;\n        this.recovering = 0;\n        this.tokenCount = 0;\n        this.stacks = [Stack.start(new StackContext(parser, bufferLength, input))];\n        this.strict = strict;\n        this.cache = cache ? new CacheCursor(cache) : null;\n    }\n    /// @internal\n    ParseContext.prototype.putStack = function (stack) {\n        this.stacks.push(stack);\n        if (this.pos < 0 || stack.pos < this.pos)\n            this.pos = stack.pos;\n    };\n    /// Move the parser forward. This will process all parse stacks at\n    /// `this.pos` and try to advance them to a further position. If no\n    /// stack for such a position is found, it'll start error-recovery.\n    ///\n    /// When the parse is finished, this will return a syntax tree. When\n    /// not, it returns `null`.\n    ParseContext.prototype.advance = function () {\n        var stacks = this.stacks, pos = this.pos;\n        // This will now hold stacks beyond `pos`.\n        this.stacks = [];\n        // Will be reset to the next position by `putStack`.\n        this.pos = -1;\n        var stopped = null, stoppedTokens = null;\n        // Keep advancing any stacks at `pos` until they either move\n        // forward or can't be advanced. Gather stacks that can't be\n        // advanced further in `stopped`.\n        for (var i = 0; i < stacks.length; i++) {\n            var stack = stacks[i];\n            for (;;) {\n                if (stack.pos > pos) {\n                    this.putStack(stack);\n                }\n                else {\n                    var result = this.advanceStack(stack, stacks);\n                    if (result) {\n                        stack = result;\n                        continue;\n                    }\n                    else {\n                        if (!stopped) {\n                            stopped = [];\n                            stoppedTokens = [];\n                        }\n                        stopped.push(stack);\n                        var tok = stack.cx.tokens.mainToken;\n                        stoppedTokens.push(tok.value, tok.end);\n                    }\n                }\n                break;\n            }\n        }\n        if (!this.stacks.length) {\n            var finished = stopped && findFinished(stopped);\n            if (finished)\n                return finished.toTree();\n            if (this.strict)\n                throw new SyntaxError(\"No parse at \" + pos);\n            if (!this.recovering)\n                this.recovering = recoverDist;\n        }\n        if (this.recovering && stopped) {\n            var finished = this.runRecovery(stopped, stoppedTokens);\n            if (finished)\n                return finished.forceAll().toTree();\n        }\n        if (this.recovering) {\n            var maxRemaining = this.recovering == 1 ? 1 : this.recovering * maxRemainingPerStep;\n            if (this.stacks.length > maxRemaining) {\n                this.stacks.sort(function (a, b) { return a.recovered - b.recovered; });\n                this.stacks.length = maxRemaining;\n            }\n            if (this.stacks.some(function (s) { return s.reducePos > pos; }))\n                this.recovering--;\n        }\n        else if (this.stacks.length > 1 && this.stacks[0].buffer.length > minBufferLengthPrune) {\n            // Prune stacks that have been running without splitting for a\n            // while, to avoid getting stuck with multiple successful stacks\n            // running endlessly on.\n            var minLen = 1e9, minI = -1;\n            for (var i = 0; i < this.stacks.length; i++) {\n                var stack = this.stacks[i];\n                if (stack.buffer.length < minLen) {\n                    minLen = stack.buffer.length;\n                    minI = i;\n                }\n            }\n            if (minLen > minBufferLengthPrune)\n                this.stacks.splice(minI, 1);\n        }\n        this.tokenCount++;\n        return null;\n    };\n    // Returns an updated version of the given stack, or null if the\n    // stack can't advance normally. When `split` is given, stacks split\n    // off by ambiguous operations will be pushed to that, or given to\n    // `putStack` if they move `pos` forward.\n    ParseContext.prototype.advanceStack = function (stack, split) {\n        var start = stack.pos, _a = stack.cx, input = _a.input, parser = _a.parser;\n        var base = verbose ? stack + \" -> \" : \"\";\n        if (this.cache) {\n            for (var cached = this.cache.nodeAt(start); cached;) {\n                var match = parser.group.types[cached.type.id] == cached.type ? parser.getGoto(stack.state, cached.type.id) : -1;\n                if (match > -1) {\n                    stack.useNode(cached, match);\n                    if (verbose)\n                        console.log(base + stack + (\" (via reuse of \" + parser.getName(cached.type.id) + \")\"));\n                    return stack;\n                }\n                if (!(cached instanceof lezerTree.Tree) || cached.children.length == 0 || cached.positions[0] > 0)\n                    break;\n                var inner = cached.children[0];\n                if (inner instanceof lezerTree.Tree)\n                    cached = inner;\n                else\n                    break;\n            }\n        }\n        var nest = parser.startNested(stack.state);\n        maybeNest: if (nest > -1) {\n            var _b = parser.nested[nest], grammar = _b.grammar, endToken = _b.end, placeholder = _b.placeholder;\n            var filterEnd = undefined, parseNode = null, nested = void 0, wrapType = undefined;\n            if (typeof grammar == \"function\") {\n                var query = grammar(input, stack);\n                if (query.stay)\n                    break maybeNest;\n                (parseNode = query.parseNode, nested = query.parser, filterEnd = query.filterEnd, wrapType = query.wrapType);\n            }\n            else {\n                nested = grammar;\n            }\n            var end = this.scanForNestEnd(stack, endToken, filterEnd);\n            var clippedInput = stack.cx.input.clip(end);\n            if (parseNode || !nested) {\n                var node = parseNode ? parseNode(clippedInput, stack.pos) : lezerTree.Tree.empty;\n                if (node.length != end - stack.pos)\n                    node = new lezerTree.Tree(node.type, node.children, node.positions, end - stack.pos);\n                if (wrapType != null)\n                    node = new lezerTree.Tree(parser.group.types[wrapType], [node], [0], node.length);\n                stack.useNode(node, parser.getGoto(stack.state, placeholder, true));\n                return stack;\n            }\n            else {\n                var newStack = Stack.start(new StackContext(nested, stack.cx.maxBufferLength, clippedInput, stack, wrapType), stack.pos);\n                if (verbose)\n                    console.log(base + newStack + \" (nested)\");\n                return newStack;\n            }\n        }\n        var defaultReduce = parser.stateSlot(stack.state, 4 /* DefaultReduce */);\n        if (defaultReduce > 0) {\n            stack.reduce(defaultReduce);\n            if (verbose)\n                console.log(base + stack + (\" (via always-reduce \" + parser.getName(defaultReduce & 65535 /* ValueMask */) + \")\"));\n            return stack;\n        }\n        var actions = stack.cx.tokens.getActions(stack, input);\n        for (var i = 0; i < actions.length;) {\n            var action = actions[i++], term = actions[i++], end = actions[i++];\n            var last = i == actions.length || !split;\n            var localStack = last ? stack : stack.split();\n            localStack.apply(action, term, end);\n            if (verbose)\n                console.log(base + localStack + (\" (via \" + ((action & 65536 /* ReduceFlag */) == 0 ? \"shift\"\n                    : \"reduce of \" + parser.getName(action & 65535 /* ValueMask */)) + \" for \" + parser.getName(term) + \" @ \" + start + (localStack == stack ? \"\" : \", split\") + \")\"));\n            if (last)\n                return localStack;\n            else if (localStack.pos > start)\n                this.putStack(localStack);\n            else\n                split.push(localStack);\n        }\n        if (stack.cx.parent && stack.pos == input.length)\n            return finishNested(stack);\n        return null;\n    };\n    // Advance a given stack forward as far as it will go. Returns the\n    // (possibly updated) stack if it got stuck, or null if it moved\n    // forward and was given to `putStack`.\n    ParseContext.prototype.advanceFully = function (stack) {\n        var pos = stack.pos;\n        for (;;) {\n            var result = this.advanceStack(stack, null);\n            if (!result)\n                return stack;\n            if (result.pos > pos) {\n                this.putStack(result);\n                return null;\n            }\n            stack = result;\n        }\n    };\n    ParseContext.prototype.runRecovery = function (stacks, tokens) {\n        var finished = null;\n        for (var i = 0; i < stacks.length; i++) {\n            var stack = stacks[i], token = tokens[i << 1], tokenEnd = tokens[(i << 1) + 1];\n            var base = verbose ? stack + \" -> \" : \"\";\n            var force = stack.split(), forceBase = base;\n            for (var j = 0; force.forceReduce() && j < forceReduceLimit; j++) {\n                if (verbose)\n                    console.log(forceBase + force + \" (via force-reduce)\");\n                var stopped = this.advanceFully(force);\n                if (!stopped)\n                    break;\n                force = stopped;\n                if (verbose)\n                    forceBase = stopped + \" -> \";\n            }\n            for (var _i = 0, _a = stack.recoverByInsert(token); _i < _a.length; _i++) {\n                var insert = _a[_i];\n                if (verbose)\n                    console.log(base + insert + \" (via recover-insert)\");\n                this.advanceFully(insert);\n            }\n            if (stack.cx.input.length > stack.pos) {\n                if (tokenEnd == stack.pos) {\n                    tokenEnd++;\n                    token = 0 /* Err */;\n                }\n                stack.recoverByDelete(token, tokenEnd);\n                if (verbose)\n                    console.log(base + stack + (\" (via recover-delete \" + stack.cx.parser.getName(token) + \")\"));\n                this.putStack(stack);\n            }\n            else if (!stack.cx.parent && (!finished || finished.recovered > stack.recovered)) {\n                finished = stack;\n            }\n        }\n        return finished;\n    };\n    /// Force the parse to finish, generating a tree containing the nodes\n    /// parsed so far.\n    ParseContext.prototype.forceFinish = function () {\n        return this.stacks[0].split().forceAll().toTree();\n    };\n    Object.defineProperty(ParseContext.prototype, \"badness\", {\n        /// A value that indicates how successful the parse is so far, as\n        /// the number of error-recovery steps taken divided by the number\n        /// of tokens parsed. Could be used to decide to abort a parse when\n        /// the input doesn't appear to match the grammar at all.\n        get: function () {\n            return this.stacks[0].recovered * 2 /* Token */ / this.tokenCount;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    ParseContext.prototype.scanForNestEnd = function (stack, endToken, filter) {\n        var input = stack.cx.input;\n        for (var pos = stack.pos; pos < input.length; pos++) {\n            dummyToken.start = pos;\n            dummyToken.value = -1;\n            endToken.token(input, dummyToken, stack);\n            if (dummyToken.value > -1 && (!filter || filter(input.read(pos, dummyToken.end))))\n                return pos;\n        }\n        return input.length;\n    };\n    return ParseContext;\n}());\n/// A parser holds the parse tables for a given grammar, as generated\n/// by `lezer-generator`.\nvar Parser = /** @class */ (function () {\n    /// @internal\n    function Parser(\n    /// The parse states for this grammar @internal\n    states, \n    /// A blob of data that the parse states, as well as some\n    /// of `Parser`'s fields, point into @internal\n    data, \n    /// The goto table. See `computeGotoTable` in\n    /// lezer-generator for details on the format @internal\n    goto, \n    /// A node group with the node types used by this parser.\n    group, \n    /// The first repeat-related term id @internal\n    minRepeatTerm, \n    /// The tokenizer objects used by the grammar @internal\n    tokenizers, \n    /// Metadata about nested grammars used in this grammar @internal\n    nested, \n    /// Points into this.data at an array of token types that\n    /// are specialized @internal\n    specializeTable, \n    /// For each specialized token type, this holds an object mapping\n    /// names to numbers, with the first bit indicating whether the\n    /// specialization extends or replaces the original token, and the\n    /// rest of the bits holding the specialized token type. @internal\n    specializations, \n    /// Points into this.data at an array that holds the\n    /// precedence order (higher precedence first) for ambiguous\n    /// tokens @internal\n    tokenPrecTable, \n    /// An optional object mapping term ids to name strings @internal\n    termNames) {\n        if (termNames === void 0) { termNames = null; }\n        this.states = states;\n        this.data = data;\n        this.goto = goto;\n        this.group = group;\n        this.minRepeatTerm = minRepeatTerm;\n        this.tokenizers = tokenizers;\n        this.nested = nested;\n        this.specializeTable = specializeTable;\n        this.specializations = specializations;\n        this.tokenPrecTable = tokenPrecTable;\n        this.termNames = termNames;\n        this.nextStateCache = [];\n        this.maxNode = this.group.types.length - 1;\n        this.maxRepeatWrap = this.group.types.length + (this.group.types.length - minRepeatTerm) - 1;\n        for (var i = 0, l = this.states.length / 6 /* Size */; i < l; i++)\n            this.nextStateCache[i] = null;\n    }\n    /// Parse a given string or stream.\n    Parser.prototype.parse = function (input, options) {\n        if (typeof input == \"string\")\n            input = new StringStream(input);\n        var cx = new ParseContext(this, input, options);\n        for (;;) {\n            var done = cx.advance();\n            if (done)\n                return done;\n        }\n    };\n    /// Create a `ParseContext`.\n    Parser.prototype.startParse = function (input, options) {\n        if (typeof input == \"string\")\n            input = new StringStream(input);\n        return new ParseContext(this, input, options);\n    };\n    /// Get a goto table entry @internal\n    Parser.prototype.getGoto = function (state, term, loose) {\n        if (loose === void 0) { loose = false; }\n        var table = this.goto;\n        if (term >= table[0])\n            return -1;\n        for (var pos = table[term + 1];;) {\n            var groupTag = table[pos++], last = groupTag & 1;\n            var target = table[pos++];\n            if (last && loose)\n                return target;\n            for (var end = pos + (groupTag >> 1); pos < end; pos++)\n                if (table[pos] == state)\n                    return target;\n            if (last)\n                return -1;\n        }\n    };\n    /// Check if this state has an action for a given terminal @internal\n    Parser.prototype.hasAction = function (state, terminal) {\n        var data = this.data;\n        for (var set = 0; set < 2; set++) {\n            for (var i = this.stateSlot(state, set ? 2 /* Skip */ : 1 /* Actions */), next = void 0; (next = data[i]) != 65535 /* End */; i += 3) {\n                if (next == terminal || next == 0 /* Err */)\n                    return data[i + 1] | (data[i + 2] << 16);\n            }\n        }\n        return 0;\n    };\n    /// @internal\n    Parser.prototype.stateSlot = function (state, slot) {\n        return this.states[(state * 6 /* Size */) + slot];\n    };\n    /// @internal\n    Parser.prototype.stateFlag = function (state, flag) {\n        return (this.stateSlot(state, 0 /* Flags */) & flag) > 0;\n    };\n    /// @internal\n    Parser.prototype.startNested = function (state) {\n        var flags = this.stateSlot(state, 0 /* Flags */);\n        return flags & 4 /* StartNest */ ? flags >> 10 /* NestShift */ : -1;\n    };\n    /// @internal\n    Parser.prototype.validAction = function (state, action) {\n        if (action == this.stateSlot(state, 4 /* DefaultReduce */))\n            return true;\n        for (var i = this.stateSlot(state, 1 /* Actions */);; i += 3) {\n            if (this.data[i] == 65535 /* End */)\n                return false;\n            if (action == (this.data[i + 1] | (this.data[i + 2] << 16)))\n                return true;\n        }\n    };\n    /// Get the states that can follow this one through shift actions or\n    /// goto jumps. @internal\n    Parser.prototype.nextStates = function (state) {\n        var cached = this.nextStateCache[state];\n        if (cached)\n            return cached;\n        var result = [];\n        for (var i = this.stateSlot(state, 1 /* Actions */); this.data[i] != 65535 /* End */; i += 3) {\n            if ((this.data[i + 2] & (65536 /* ReduceFlag */ >> 16)) == 0 && !result.includes(this.data[i + 1]))\n                result.push(this.data[i + 1]);\n        }\n        var table = this.goto, max = table[0];\n        for (var term = 0; term < max; term++) {\n            for (var pos = table[term + 1];;) {\n                var groupTag = table[pos++], target = table[pos++];\n                for (var end = pos + (groupTag >> 1); pos < end; pos++)\n                    if (table[pos] == state && !result.includes(target))\n                        result.push(target);\n                if (groupTag & 1)\n                    break;\n            }\n        }\n        return this.nextStateCache[state] = result;\n    };\n    /// @internal\n    Parser.prototype.overrides = function (token, prev) {\n        var iPrev = findOffset(this.data, this.tokenPrecTable, prev);\n        return iPrev < 0 || findOffset(this.data, this.tokenPrecTable, token) < iPrev;\n    };\n    /// Create a new `Parser` instance with different values for (some\n    /// of) the nested grammars. This can be used to, for example, swap\n    /// in a different language for a nested grammar or fill in a nested\n    /// grammar that was left blank by the original grammar.\n    Parser.prototype.withNested = function (spec) {\n        return new Parser(this.states, this.data, this.goto, this.group, this.minRepeatTerm, this.tokenizers, this.nested.map(function (obj) {\n            if (!Object.prototype.hasOwnProperty.call(spec, obj.name))\n                return obj;\n            return { name: obj.name, grammar: spec[obj.name], end: obj.end, placeholder: obj.placeholder };\n        }), this.specializeTable, this.specializations, this.tokenPrecTable, this.termNames);\n    };\n    /// Create a new `Parser` instance whose node types have the given\n    /// props added. You should use [`NodeProp.add`](#tree.NodeProp.add)\n    /// to create the arguments to this method.\n    Parser.prototype.withProps = function () {\n        var _a;\n        var props = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            props[_i] = arguments[_i];\n        }\n        return new Parser(this.states, this.data, this.goto, (_a = this.group).extend.apply(_a, props), this.minRepeatTerm, this.tokenizers, this.nested, this.specializeTable, this.specializations, this.tokenPrecTable, this.termNames);\n    };\n    /// Returns the name associated with a given term. This will only\n    /// work for all terms when the parser was generated with the\n    /// `--names` option. By default, only the names of tagged terms are\n    /// stored.\n    Parser.prototype.getName = function (term) {\n        return this.termNames ? this.termNames[term] : String(term <= this.maxNode && this.group.types[term].name || term);\n    };\n    Object.defineProperty(Parser.prototype, \"eofTerm\", {\n        /// The eof term id is always allocated directly after the node\n        /// types. @internal\n        get: function () { return this.maxRepeatWrap + 1; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Parser.prototype, \"hasNested\", {\n        /// Tells you whether this grammar has any nested grammars.\n        get: function () { return this.nested.length > 0; },\n        enumerable: true,\n        configurable: true\n    });\n    /// (Used by the output of the parser generator) @internal\n    Parser.deserialize = function (spec) {\n        var tokenArray = decodeArray(spec.tokenData);\n        var nodeNames = spec.nodeNames.split(\" \"), minRepeatTerm = nodeNames.length;\n        for (var i = 0; i < spec.repeatNodeCount; i++)\n            nodeNames.push(\"\");\n        var nodeProps = [];\n        for (var i = 0; i < nodeNames.length; i++)\n            nodeProps.push(noProps);\n        function setProp(nodeID, prop, value) {\n            if (nodeProps[nodeID] == noProps)\n                nodeProps[nodeID] = Object.create(null);\n            prop.set(nodeProps[nodeID], prop.deserialize(value));\n        }\n        setProp(0, lezerTree.NodeProp.error, \"\");\n        if (spec.nodeProps)\n            for (var _i = 0, _a = spec.nodeProps; _i < _a.length; _i++) {\n                var propSpec = _a[_i];\n                var prop = propSpec[0];\n                for (var i = 1; i < propSpec.length; i += 2)\n                    setProp(propSpec[i], prop, propSpec[i + 1]);\n            }\n        var group = new lezerTree.NodeGroup(nodeNames.map(function (name, i) { return new lezerTree.NodeType(name, nodeProps[i], i); }));\n        return new Parser(decodeArray(spec.states, Uint32Array), decodeArray(spec.stateData), decodeArray(spec.goto), group, minRepeatTerm, spec.tokenizers.map(function (value) { return typeof value == \"number\" ? new TokenGroup(tokenArray, value) : value; }), (spec.nested || []).map(function (_a) {\n            var name = _a[0], grammar = _a[1], endToken = _a[2], placeholder = _a[3];\n            return ({ name: name, grammar: grammar, end: new TokenGroup(decodeArray(endToken), 0), placeholder: placeholder });\n        }), spec.specializeTable, (spec.specializations || []).map(withoutPrototype), spec.tokenPrec, spec.termNames);\n    };\n    return Parser;\n}());\nvar noProps = Object.create(null);\nfunction findOffset(data, start, term) {\n    for (var i = start, next = void 0; (next = data[i]) != 65535 /* End */; i++)\n        if (next == term)\n            return i - start;\n    return -1;\n}\n// Strip the prototypes from objects, so that they can safely be\n// accessed as maps.\nfunction withoutPrototype(obj) {\n    if (!(obj instanceof Object))\n        return obj;\n    var result = Object.create(null);\n    for (var prop in obj)\n        if (Object.prototype.hasOwnProperty.call(obj, prop))\n            result[prop] = obj[prop];\n    return result;\n}\nfunction findFinished(stacks) {\n    var best = null;\n    for (var _i = 0, stacks_1 = stacks; _i < stacks_1.length; _i++) {\n        var stack = stacks_1[_i];\n        if (stack.pos == stack.cx.input.length &&\n            stack.cx.parser.stateFlag(stack.state, 2 /* Accepting */) &&\n            (!best || best.recovered > stack.recovered))\n            best = stack;\n    }\n    return best;\n}\nfunction finishNested(stack) {\n    if (stack.cx.wrapType == -2)\n        return null; // Another nested stack already finished\n    var parent = stack.cx.parent, tree = stack.forceAll().toTree();\n    var parentParser = parent.cx.parser, info = parentParser.nested[parentParser.startNested(parent.state)];\n    tree = new lezerTree.Tree(tree.type, tree.children, tree.positions.map(function (p) { return p - parent.pos; }), stack.pos - parent.pos);\n    if (stack.cx.wrapType > -1)\n        tree = new lezerTree.Tree(parentParser.group.types[stack.cx.wrapType], [tree], [0], tree.length);\n    stack.cx.wrapType = -2;\n    parent.useNode(tree, parentParser.getGoto(parent.state, info.placeholder, true));\n    if (verbose)\n        console.log(parent + (\" (via unnest \" + (stack.cx.wrapType > -1 ? parentParser.getName(stack.cx.wrapType) : tree.type.name) + \")\"));\n    return parent;\n}\n\nexports.NodeGroup = lezerTree.NodeGroup;\nexports.NodeProp = lezerTree.NodeProp;\nexports.NodeType = lezerTree.NodeType;\nexports.Subtree = lezerTree.Subtree;\nexports.Tree = lezerTree.Tree;\nexports.ExternalTokenizer = ExternalTokenizer;\nexports.ParseContext = ParseContext;\nexports.Parser = Parser;\nexports.Stack = Stack;\nexports.Token = Token;\nexports.TokenGroup = TokenGroup;\n//# sourceMappingURL=index.js.map\n","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","function sym(name, random) {\n  return typeof Symbol == \"undefined\"\n    ? \"__\" + name + (random ? Math.floor(Math.random() * 1e8) : \"\")\n    : random ? Symbol(name) : Symbol.for(name)\n}\n\nconst COUNT = sym(\"\\u037c\"), SET = sym(\"styleSet\", 1), RULES = sym(\"rules\", 1)\nconst top = typeof global == \"undefined\" ? window : global\n\n// :: (Object<Style>, ?{generateClasses: ?boolean})  StyleModule\n// Instances of this class bind the property names from `spec` to CSS\n// class names that assign the styles in the corresponding property\n// values, unless `generateClasses` is `false`, in which case the\n// property names in the spec are treated as plain CSS selectors.\n//\n// A style module can only be used in a given DOM root after it has\n// been _mounted_ there with `StyleModule.mount`.\n//\n// Style modules should be created once and stored somewhere, as\n// opposed to re-creating them every time you need them. The amount of\n// CSS rules generated for a given DOM root is bounded by the amount\n// of style modules that were used. So to avoid leaking rules, don't\n// create these dynamically, but treat them as one-time allocations.\nexport function StyleModule(spec, options) {\n  this[RULES] = []\n  for (let name in spec) {\n    let style = spec[name], specificity = style.specificity || 0\n    let id = StyleModule.newName(), selector = name\n    if ((options && options.generateClasses) !== false) {\n      let className = id\n      selector = \".\" + id\n      for (let i = 0; i < specificity; i++) {\n        let name = \"\\u037c_\" + (i ? i.toString(36) : \"\")\n        selector += \".\" + name\n        className += \" \" + name\n      }\n      this[name] = className\n    }\n    renderStyle(selector, spec[name], this[RULES])\n  }\n}\n\n// :: ()  string\n// Generate a new unique CSS class name.\nStyleModule.newName = () => {\n  let id = top[COUNT] || 1\n  top[COUNT] = id + 1\n  return \"\\u037c\" + id.toString(36)\n}\n\nStyleModule.prototype = Object.create(null)\n\n// :: (union<Document, ShadowRoot>, union<[StyleModule], StyleModule>)\n//\n// Mount the given set of modules in the given DOM root, which ensures\n// that the CSS rules defined by the module are available in that\n// context.\n//\n// Rules are only added to the document once per root.\n//\n// Rule order will follow the order of the modules, so that rules from\n// modules later in the array take precedence of those from earlier\n// modules. If you call this function multiple times for the same root\n// in a way that changes the order of already mounted modules, the old\n// order will be changed.\nStyleModule.mount = function(root, modules) {\n  (root[SET] || new StyleSet(root)).mount(Array.isArray(modules) ? modules : [modules])\n}\n\nclass StyleSet {\n  constructor(root) {\n    this.root = root\n    root[SET] = this\n    this.styleTag = (root.ownerDocument || root).createElement(\"style\")\n    let target = root.head || root\n    target.insertBefore(this.styleTag, target.firstChild)\n    this.modules = []\n  }\n\n  mount(modules) {\n    let sheet = this.styleTag.sheet, reset = !sheet\n    let pos = 0 /* Current rule offset */, j = 0 /* Index into this.modules */\n    for (let i = 0; i < modules.length; i++) {\n      let mod = modules[i], index = this.modules.indexOf(mod)\n      if (index < j && index > -1) { // Ordering conflict\n        this.modules.splice(index, 1)\n        j--\n        index = -1\n      }\n      if (index == -1) {\n        this.modules.splice(j++, 0, mod)\n        if (!reset) for (let k = 0; k < mod[RULES].length; k++)\n          sheet.insertRule(mod[RULES][k], pos++)\n      } else {\n        while (j < index) pos += this.modules[j++][RULES].length\n        pos += mod[RULES].length\n        j++\n      }\n    }\n\n    if (reset) {\n      let text = \"\"\n      for (let i = 0; i < this.modules.length; i++)\n        text += this.modules[i][RULES].join(\"\\n\") + \"\\n\"\n      this.styleTag.textContent = text\n    }\n  }\n}\n\nfunction renderStyle(selector, spec, output) {\n  if (typeof spec != \"object\") throw new RangeError(\"Expected style object, got \" + JSON.stringify(spec))\n  let props = []\n  for (let prop in spec) {\n    if (/^@/.test(prop)) {\n      let local = []\n      renderStyle(selector, spec[prop], local)\n      output.push(prop + \" {\" + local.join(\" \") + \"}\")\n    } else if (/&/.test(prop)) {\n      renderStyle(prop.replace(/&/g, selector), spec[prop], output)\n    } else if (prop != \"specificity\") {\n      if (typeof spec[prop] == \"object\") throw new RangeError(\"The value of a property (\" + prop + \") should be a primitive value.\")\n      props.push(prop.replace(/_.*/, \"\").replace(/[A-Z]/g, l => \"-\" + l.toLowerCase()) + \": \" + spec[prop])\n    }\n  }\n  if (props.length) output.push(selector + \" {\" + props.join(\"; \") + \"}\")\n}\n\n// Style::Object<union<Style,string>>\n//\n// A style is an object that, in the simple case, maps CSS property\n// names to strings holding their values, as in `{color: \"red\",\n// fontWeight: \"bold\"}`. The property names can be given in\n// camel-casethe library will insert a dash before capital letters\n// when converting them to CSS.\n//\n// If you include an underscore in a property name, it and everything\n// after it will be removed from the output, which can be useful when\n// providing a property multiple times, for browser compatibility\n// reasons.\n//\n// A property called `specificity` has a special meaning: if it holds\n// a number _N_, greater than 0, the selector for the class will have\n// _N_ extra dummy classes added, and those dummy classes will also be\n// present in the class name string created for the style. This allows\n// you to create rules that take precedence over other rules, even\n// when they are defined earlier.\n//\n// A property in a style object can also be a sub-selector, which\n// extends the current context to add a pseudo-selector or a child\n// selector. Such a property should contain a `&` character, which\n// will be replaced by the current selector. For example `{\"&:before\":\n// {content: '\"hi\"'}}`. Sub-selectors and regular properties can\n// freely be mixed in a given object. Any property containing a `&` is\n// assumed to be a sub-selector.\n//\n// Finally, a property can specify an @-block to be wrapped around the\n// styles defined inside the object that's the property's value. For\n// example to create a media query you can do `{\"@media screen and\n// (min-width: 400px)\": {...}}`.\n","var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n","import {EditorView} from \"@codemirror/next/view\"\r\nimport {EditorState} from \"@codemirror/next/state\"\r\nimport * as commands from \"@codemirror/next/commands\"\r\nimport {javascript} from \"@codemirror/next/lang-javascript\"\r\nimport {lineNumbers} from \"@codemirror/next/gutter\"\r\nimport {defaultHighlighter} from \"@codemirror/next/highlight\"\r\n\r\nconst helloTypeScriptProgram = \r\n  \"function hello(name: string) {\\n  console.log(`hello ${name}`)\\n}\\n\"\r\n\r\nlet state = EditorState.create({\r\n  doc: helloTypeScriptProgram,\r\n  extensions: [\r\n\r\n    // create a static extension\r\n    // great example of how facets bring value.\r\n    // We could have created multiple consumers of\r\n    // domEventHandlers facet consumers: extensions\r\n    // extensions do the work, but the work \r\n    // is driven by facets\r\n    EditorView.domEventHandlers.of({\r\n      touchstart: onTouchStart,\r\n      touchend: onTouchEnd\r\n    }),\r\n    \r\n    lineNumbers(),\r\n    defaultHighlighter,\r\n\r\n    javascript()\r\n  ]\r\n})\r\n\r\nlet editor = new EditorView({state})\r\n\r\n// move this to its own class\r\nvar clientXStart: number = null;\r\nvar clientYStart: number = null;\r\nfunction onTouchStart(view: EditorView, event: TouchEvent) {\r\n  let {clientX, clientY} = event.changedTouches[0]\r\n  clientXStart = clientX\r\n  clientYStart = clientY\r\n  return false\r\n}\r\n\r\n// TODO: Add long gestures\r\nfunction onTouchEnd(view: EditorView, event: TouchEvent) {\r\n  let {clientX, clientY} = event.changedTouches[0]\r\n  const threshold = 40\r\n  \r\n  if (clientX - clientXStart > threshold) {\r\n    commands.moveWordRight(editor)\r\n    return true\r\n  }\r\n  if (clientXStart - clientX > threshold) {\r\n    commands.moveWordLeft(editor)\r\n    return true\r\n  }\r\n  if (clientY - clientYStart > threshold) {\r\n    commands.moveLineDown(editor)\r\n    return true\r\n  }\r\n  if (clientYStart - clientY > threshold) {\r\n    commands.moveLineUp(editor)\r\n    return true\r\n  }\r\n\r\n  return false\r\n}\r\n\r\n//editor.dom.style.width = \"100vw\"\r\n//editor.dom.style.height = \"100vh\"\r\n\r\nvar style = editor.dom.style\r\nstyle.width = \"100vw\"\r\nstyle.height = \"100vh\"\r\n\r\ndocument.body.style.margin = \"0px\"\r\n\r\ndocument.body.appendChild(editor.dom)\r\n\r\neditor.focus()\r\n"],"sourceRoot":""}